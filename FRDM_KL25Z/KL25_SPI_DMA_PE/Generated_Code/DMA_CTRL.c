/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : DMA_CTRL.c
**     Project     : ProcessorExpert
**     Processor   : MKL25Z128VLK4
**     Component   : DMA_LDD
**     Version     : Component 01.065, Driver 01.07, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-07-08, 11:19, # CodeGen: 1
**     Abstract    :
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
**     Settings    :
**          Component name                                 : DMA_CTRL
**          Device                                         : DMA
**          Channel arbitration type                       : Round robin
**          DMA channels                                   : 4
**            Settings of DMA channel                      : DMA_Channel0
**              Channel                                    : DMA_Channel0
**              Channel arbitration type                   : Round robin
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : INT_DMA0
**                Transfer complete interrupt priority     : high priority
**            Settings of DMA channel                      : DMA_Channel1
**              Channel                                    : DMA_Channel1
**              Channel arbitration type                   : Round robin
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : INT_DMA1
**                Transfer complete interrupt priority     : high priority
**            Settings of DMA channel                      : DMA_Channel2
**              Channel                                    : DMA_Channel2
**              Channel arbitration type                   : Round robin
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : INT_DMA2
**                Transfer complete interrupt priority     : low priority
**            Settings of DMA channel                      : DMA_Channel3
**              Channel                                    : DMA_Channel3
**              Channel arbitration type                   : Round robin
**              Interrupt service                          : Enabled
**                Transfer complete interrupt              : INT_DMA3
**                Transfer complete interrupt priority     : low priority
**          Initialization                                 : 
**            Enabled in init. code                        : no
**            Auto initialization                          : no
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init                         - LDD_TDeviceData* DMA_CTRL_Init(LDD_TUserData *UserDataPtr);
**         Deinit                       - void DMA_CTRL_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         Enable                       - LDD_TError DMA_CTRL_Enable(LDD_TDeviceData *DeviceDataPtr);
**         Disable                      - LDD_TError DMA_CTRL_Disable(LDD_TDeviceData *DeviceDataPtr);
**         AllocateChannel              - LDD_TError DMA_CTRL_AllocateChannel(LDD_TDeviceData *DeviceDataPtr,...
**         EnableChannel                - LDD_TError DMA_CTRL_EnableChannel(LDD_TDeviceData *DeviceDataPtr,...
**         DisableChannel               - LDD_TError DMA_CTRL_DisableChannel(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelSourceAddress      - LDD_TError DMA_CTRL_SetChannelSourceAddress(LDD_TDeviceData *DeviceDataPtr,...
**         SetChannelDestinationAddress - LDD_TError DMA_CTRL_SetChannelDestinationAddress(LDD_TDeviceData...
**         SetChannelByteCount          - LDD_TError DMA_CTRL_SetChannelByteCount(LDD_TDeviceData *DeviceDataPtr,...
**
**     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
**     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/
/*!
** @file DMA_CTRL.c
** @version 01.07
** @brief
**          This embedded component implements initialization
**          and runtime handling of an on-chip DMA controller.
*/         
/*!
**  @addtogroup DMA_CTRL_module DMA_CTRL module documentation
**  @{
*/         

/* MODULE DMA_CTRL. */

#include "Events.h"
#include "DMA_CTRL.h"

/* {Default RTOS Adapter} No RTOS includes */

/* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static DMA_CTRL_TDeviceData DeviceDataPtr__DEFAULT_RTOS_ALLOC;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA_CTRL_TDeviceData * INT_DMA0__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA_CTRL_TDeviceData * INT_DMA1__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA_CTRL_TDeviceData * INT_DMA2__DEFAULT_RTOS_ISRPARAM;
/* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
static DMA_CTRL_TDeviceData * INT_DMA3__DEFAULT_RTOS_ISRPARAM;
/* Channel numbers initialization table */
static const LDD_DMA_TChannelNumber DMA_CTRL_ChannelNumbers[DMA_CTRL_CONFIGURED_CHANNELS_NUMBER] = {
  0x02U,
  0x03U,
  0x00U,
  0x01U
};
/* Channel interrupts enable initialization table */
static const bool DMA_CTRL_ChannelInterrupts[DMA_CTRL_CONFIGURED_CHANNELS_NUMBER] = {
  TRUE,
  TRUE,
  TRUE,
  TRUE
};

/* Internal method prototypes */
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA_CTRL_TDescriptorRecordPtr *DescriptorRecordAddressPtr);
static bool GetChannelNumber(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TChannelNumber *ChannelNumberPtr);
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr);

/*
** ===================================================================
**     Method      :  DMA_CTRL_Init (component DMA_LDD)
*/
/*!
**     @brief
**         Initializes the device according to design-time
**         configuration properties. Allocates memory for the device
**         data structure. 
**         If the <Enable in init. code> is set to "yes" then the
**         device is also enabled (see the description of the Enable
**         method).
**         This method can be called only once. Before the second call
**         of Init the Deinit method must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Pointer to the device data structure. 
*/
/* ===================================================================*/
LDD_TDeviceData* DMA_CTRL_Init(LDD_TUserData *UserDataPtr)
{
  uint8_t i;
  DMA_CTRL_TDeviceData *DeviceDataPtr; /* LDD device structure */
  DMA_CTRL_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */

  /* Allocate HAL device structure */
  /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPtr = &DeviceDataPtr__DEFAULT_RTOS_ALLOC;
  DeviceDataPtr->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  /* Enable device clock gate */
  /* SIM_SCGC7: DMA=1 */
  SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;                                   
  /* SIM_SCGC6: DMAMUX=1 */
  SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;                                   
  /* Transfer compete interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA0__DEFAULT_RTOS_ISRPARAM = DeviceDataPtr;
  /* Transfer compete interrupt vector(s) priority setting */
  /* NVIC_IPR0: PRI_0=0x40 */
  NVIC_IPR0 = (uint32_t)((NVIC_IPR0 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_0(0xBF)
              )) | (uint32_t)(
               NVIC_IP_PRI_0(0x40)
              ));                                  
  /* NVIC_ISER: SETENA|=1 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x01);                                   
  /* Transfer compete interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA1__DEFAULT_RTOS_ISRPARAM = DeviceDataPtr;
  /* Transfer compete interrupt vector(s) priority setting */
  /* NVIC_IPR0: PRI_1=0x40 */
  NVIC_IPR0 = (uint32_t)((NVIC_IPR0 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_1(0xBF)
              )) | (uint32_t)(
               NVIC_IP_PRI_1(0x40)
              ));                                  
  /* NVIC_ISER: SETENA|=2 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x02);                                   
  /* Transfer compete interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA2__DEFAULT_RTOS_ISRPARAM = DeviceDataPtr;
  /* Transfer compete interrupt vector(s) priority setting */
  /* NVIC_IPR0: PRI_2=0x80 */
  NVIC_IPR0 = (uint32_t)((NVIC_IPR0 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_2(0x7F)
              )) | (uint32_t)(
               NVIC_IP_PRI_2(0x80)
              ));                                  
  /* NVIC_ISER: SETENA|=4 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x04);                                   
  /* Transfer compete interrupt vector(s) allocation */
  /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_DMA3__DEFAULT_RTOS_ISRPARAM = DeviceDataPtr;
  /* Transfer compete interrupt vector(s) priority setting */
  /* NVIC_IPR0: PRI_3=0x80 */
  NVIC_IPR0 = (uint32_t)((NVIC_IPR0 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_3(0x7F)
              )) | (uint32_t)(
               NVIC_IP_PRI_3(0x80)
              ));                                  
  /* NVIC_ISER: SETENA|=8 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x08);                                   
  for (i = 0U; i < DMA_CTRL_DMA_CHANNELS_NUMBER; i++) {
    DMA_PDD_WriteControlReg(DMA_BASE_PTR, i, 0U); /* Clear control register. Disable all interrupts and HW requests. */
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, i, DMA_PDD_TRANSFER_COMPLETE_FLAG); /* Clear request interrupt flags */
  }
  /* Initialization of channels record field. */
  for(i = 0U; i < DMA_CTRL_DMA_CHANNELS_NUMBER; i++) {
    DeviceDataPtr->ChannelRecord[i] = NULL; /* Clear pointer to descriptor record of all channels. */
  }
  /* Initialization of channel and descriptor record fields. */
  for(i = 0U; i < DMA_CTRL_CONFIGURED_CHANNELS_NUMBER; i++) {
    DescriptorRecordPtr = &(DeviceDataPtr->DescriptorRecord[i]); /* Store local pointer to descriptor record. */
    DescriptorRecordPtr->ChannelNumber = DMA_CTRL_ChannelNumbers[i]; /* Store associated channel number. */
    DescriptorRecordPtr->DescriptorPtr = NULL; /* Set channel as free. */
    DescriptorRecordPtr->Interrupts = DMA_CTRL_ChannelInterrupts[i]; /* Store associated channel interrupts enabled/disabled status. */
    DescriptorRecordPtr->Initialized = FALSE; /* Set channel as not initialized. */
    DescriptorRecordPtr->Enabled = FALSE; /* Set channel as disabled. */
    DeviceDataPtr->ChannelRecord[DMA_CTRL_ChannelNumbers[i]] = DescriptorRecordPtr; /* Store pointers to descriptor records of fixed channels. */
    DeviceDataPtr->EventMask[DMA_CTRL_ChannelNumbers[i]] = 0U; /* Clear channel event mask. */
  }
  DeviceDataPtr->EnUser = FALSE;       /* Set the flag "device disabled by user" */
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_DMA_CTRL_ID,DeviceDataPtr);
  return ((LDD_TDeviceData *)DeviceDataPtr); /* Return pointer to the data structure */
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_Deinit (component DMA_LDD)
*/
/*!
**     @brief
**         Deinitializes the associated peripheral(s) and frees the
**         component internal data structure.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
*/
/* ===================================================================*/
void DMA_CTRL_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr;                 /* Parameter not used, suppress not used argument warning */
  /* Restoring the interrupt vectors */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_DMA_CTRL_ID);
  /* Deallocation of the device structure */
  /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
  /* Disable device clock gate */
  /* SIM_SCGC7: DMA=0 */
  SIM_SCGC7 &= (uint32_t)~(uint32_t)(SIM_SCGC7_DMA_MASK);                                   
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_Enable (component DMA_LDD)
*/
/*!
**     @brief
**         Enables DMA device.
**         This method is intended to be used together with Disable
**         method to temporary switch On/Off the device after the
**         device is initialized.
**         This method is required if the <Enable in init. code>
**         property is set to "no" value.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_Enable(LDD_TDeviceData *DeviceDataPtr)
{
  ((DMA_CTRL_TDeviceData *)DeviceDataPtr)->EnUser = TRUE;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_Disable (component DMA_LDD)
*/
/*!
**     @brief
**         Disables the DMA device. When the device is disabled, some
**         component methods should not be called. If so, error
**         ERR_DISABLED is reported.
**         This method is intended to be used together with Enable
**         method to temporary switch On/Off the device after the
**         device is initialized.
**         This method is not required. The Deinit method can be used
**         to switch off and uninstall the device.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_Disable(LDD_TDeviceData *DeviceDataPtr)
{
  ((DMA_CTRL_TDeviceData *)DeviceDataPtr)->EnUser = FALSE;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_AllocateChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method allocates DMA channel for the DMA transfer
**         defined by the transfer descriptor input parameter
**         DescriptorPtr. This method must be called before DMA channel
**         is initialized. Otherwise ERR_NOTAVAIL error code is
**         returned after call of DMA_LDD channel methods.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any possible
**                           channel with desired features to be
**                           allocated.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_AllocateChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  DMA_CTRL_TDeviceData *LocalDeviceDataPtr = (DMA_CTRL_TDeviceData *)DeviceDataPtr; /* Auxiliary variable - pointer to an internal state structure */
  DMA_CTRL_TDescriptorRecord *DescriptorRecordPtr; /* Auxiliary local pointer to internal descriptor records. */
  bool ChannelFound = FALSE;
  uint8_t i;                           /* Auxiliary local loop iteration variable. */

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA_CTRL_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  if (!DescriptorPtr->ChannelAutoSelection) { /* Fixed channel wanted? */
    DescriptorRecordPtr = LocalDeviceDataPtr->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Store local pointer to internal descriptor record. */
    if (DescriptorRecordPtr->DescriptorPtr == NULL) { /* Is channel free? */
      /* Allocate channel */
      DescriptorRecordPtr->DescriptorPtr = DescriptorPtr;
      ChannelFound = TRUE;
    }
  }
  else {                               /* Autoselect channel? */
    /* Check channels capable of periodic triggering. */
    i = DMA_CTRL_ALLOCATED_CHANNELS_NUMBER;
    while ((i < (DMA_CTRL_ALLOCATED_CHANNELS_NUMBER + DMA_CTRL_PERIODIC_TRIGGER_CHANNELS_NUMBER)) && (!ChannelFound)) {
      DescriptorRecordPtr = &(LocalDeviceDataPtr->DescriptorRecord[i]); /* Store local pointer to internal descriptor record. */
      if (DescriptorRecordPtr->DescriptorPtr == NULL) { /* Is channel free? */
        if (DescriptorRecordPtr->Interrupts == DescriptorPtr->Interrupts) { /* Are channel interrupt enable bits in requested state? */
          /* Allocate channel */
          DescriptorPtr->ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Store channel number. */
          DescriptorRecordPtr->DescriptorPtr = DescriptorPtr; /* Save pointer to transfer descriptor. */
          ChannelFound = TRUE;         /* Exit search loop. */
        }
      }
      i++;
    }
  }
  if (ChannelFound) {
    return ERR_OK;
  }
  else {
    return ERR_NOTAVAIL;
  }
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_EnableChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method initializes and/or enables the DMA channel
**         allocated for the DMA transfer defined by the transfer
**         descriptor input parameter DescriptorPtr. First call of this
**         method on given DMA channel initializes it and enables HW
**         requests if Peripheral device or Always enabled trigger
**         source is selected in transfer descriptor Trigger source
**         type item. This method can be also used together with
**         Disable method to temporary switch On/Off the DMA channel HW
**         requests. In such case DMA channel registers are not
**         reinitialized again. New initialization of DMA channel can
**         be done via SetChannelDescriptorUpdate method which
**         reinitializes whole channel with new transfer descriptor.
**         After calling of EnableChannel method channel status is set
**         to LDD_DMA_IDLE.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Transfer descriptor data
**                           are inconsistent.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_EnableChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TChannelNumber ChannelNumber;
  DMA_CTRL_TDescriptorRecord *DescriptorRecordPtr;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA_CTRL_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (!VerifyDescriptor(DescriptorPtr)) {
    return ERR_PARAM_DATA;
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Save local auxiliary channel number. */
  if (!DescriptorRecordPtr->Initialized) { /* Is channel already initialized? */
    /* If channel is not initialized yet, initialize and enable it */
    DMA_PDD_WriteControlReg(DMA_BASE_PTR, ChannelNumber, 0U); /* Clear control register. Disable requests. */
    DMA_PDD_ClearDoneFlag(DMA_BASE_PTR, ChannelNumber); /* Clear DMA transfer done status flag. */
    /* Source address */
    DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceAddress);
    /* Source address increment */
    if (DescriptorPtr->SourceAddressIncrement) {
      DMA_PDD_EnableSourceAddressIncrement(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Destination address */
    DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationAddress);
    /* Destination address increment */
    if (DescriptorPtr->DestinationAddressIncrement) {
      DMA_PDD_EnableDestinationAddressIncrement(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Transfer attributes: source transfer size, destination transfer size, source modulo, destination modulo */
    DMA_PDD_SetSourceAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceModuloSize);
    DMA_PDD_SetSourceDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->SourceTransferSize);
    DMA_PDD_SetDestinationAddressModulo(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationModuloSize);
    DMA_PDD_SetDestinationDataTransferSize(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->DestinationTransferSize);
    /* Transfer mode */
    if (DescriptorPtr->TransferMode == LDD_DMA_CYCLE_STEAL_TRANSFERS) {
      DMA_PDD_EnableCycleSteal(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable cycle-steal mode. */
    }
    /* Byte count */
    DMA_PDD_SetByteCount(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->ByteCount);
    /* Auto-align mode settings. */
    if (DescriptorPtr->AutoAlign) {
      DMA_PDD_EnableAutoAlign(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Asynchronous requests settings. */
    if (DescriptorPtr->AsynchronousRequests) {
      DMA_PDD_EnableAsynchronousRequests(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* Channel linking settings. */
    switch (DescriptorPtr->ChannelLinkingMode) {
      case LDD_DMA_LINKING_DISABLED:
        /* Initialization not needed. */
        break;
      case LDD_DMA_CYCLE_STEAL_AND_TRANSFER_COMPLETE_LINKING:
        DMA_PDD_SetChannelLinkingMode(DMA_BASE_PTR, ChannelNumber, DMA_PDD_CYCLE_STEAL_AND_TRANSFER_COMPLETE_LINKING); /* Set channel linking mode. */
        DMA_PDD_SetLinkChannel1(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel); /* Set channel linked after each particular read-write operation. */
        DMA_PDD_SetLinkChannel2(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopLinkedChannel); /* Set channel linked after transfer byte count reaches zero. */
        break;
      case LDD_DMA_CYCLE_STEAL_LINKING:
        DMA_PDD_SetChannelLinkingMode(DMA_BASE_PTR, ChannelNumber, DMA_PDD_CYCLE_STEAL_LINKING); /* Set channel linking mode. */
        DMA_PDD_SetLinkChannel1(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->InnerLoopLinkedChannel); /* Set channel linked after each particular read-write operation. */
        break;
      case LDD_DMA_TRANSFER_COMPLETE_LINKING:
        DMA_PDD_SetChannelLinkingMode(DMA_BASE_PTR, ChannelNumber, DMA_PDD_TRANSFER_COMPLETE_LINKING); /* Set channel linking mode. */
        DMA_PDD_SetLinkChannel1(DMA_BASE_PTR, ChannelNumber, DescriptorPtr->OuterLoopLinkedChannel); /* Set channel linked after transfer byte count reaches zero. */
        break;
    }
    if (DescriptorPtr->DisableAfterRequest) { /* Disable after request? */
      DMA_PDD_EnableRequestAutoDisable(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
    }
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
    DescriptorRecordPtr->Initialized = TRUE; /* Mark channel as initialized. */
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->Interrupts) {   /* Interrupts enabled? */
      DMA_PDD_EnableTransferCompleteInterrupt(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE);
      if (DescriptorPtr->OnComplete) { /* Is transfer complete event enabled? */
        ((DMA_CTRL_TDeviceData *)DeviceDataPtr)->EventMask[ChannelNumber] |= LDD_DMA_ON_COMPLETE;
      }
      if (DescriptorPtr->OnError) {    /* Is transfer error event enabled? */
        ((DMA_CTRL_TDeviceData *)DeviceDataPtr)->EventMask[ChannelNumber] |= LDD_DMA_ON_ERROR;
      }
    }
    /* DMA channel HW requests source settings */
    DMAMUX_PDD_WriteChannelConfigurationReg(DMAMUX0_BASE_PTR, ChannelNumber, 0U); /* Clear DMA MUX channel source register. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need MUX channel nor enabled hardware requests. */
      DMAMUX_PDD_SetChannelSource(DMAMUX0_BASE_PTR, ChannelNumber, DescriptorPtr->TriggerSource); /* Set MUX channel source. */
      if (DescriptorPtr->PeriodicTrigger) { /* Periodic trigger needed? */
        DMAMUX_PDD_EnableTrigger(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE);
      }
      DMAMUX_PDD_EnableChannel(DMAMUX0_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable channel. */
    }
    DMA_PDD_EnablePeripheralRequest(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable HW requests. */
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
  else {
    /* If channel has already been initialized then enable it only */
    /* {Default RTOS Adapter} Critical section begin, general PE function is used */
    EnterCritical();
    DescriptorRecordPtr->Enabled = TRUE; /* Mark channel as enabled. */
    DescriptorPtr->ChannelEnabled = TRUE; /* Mark channel as enabled in transfer descriptor. */
    if (DescriptorPtr->TriggerType != LDD_DMA_SW_TRIGGER) { /* SW trigger doesn't need enabled hardware requests. */
      DMA_PDD_EnablePeripheralRequest(DMA_BASE_PTR, ChannelNumber, PDD_ENABLE); /* Enable HW requests */
    }
    /* {Default RTOS Adapter} Critical section end, general PE function is used */
    ExitCritical();
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_DisableChannel (component DMA_LDD)
*/
/*!
**     @brief
**         The method disables the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor input parameter
**         DescriptorPtr and disables HW requests services. However, it
**         is still possible to start transfer explicitly as SW
**         transfer requests via StartChannelTransfer method. After
**         calling of DisableChannel method channel status is set to
**         LDD_DMA_IDLE.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_DisableChannel(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  LDD_DMA_TRecordNumber ChannelNumber;
  DMA_CTRL_TDescriptorRecord *DescriptorRecordPtr;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA_CTRL_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store pointer to associated descriptor record. */
  if (!GetRecord(DeviceDataPtr, DescriptorPtr, &DescriptorRecordPtr)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  ChannelNumber = DescriptorRecordPtr->ChannelNumber; /* Save local auxiliary channel number. */
  /* {Default RTOS Adapter} Critical section begin, general PE function is used */
  EnterCritical();
  DescriptorRecordPtr->Enabled = FALSE; /* Mark channel as disabled. */
  DescriptorPtr->ChannelEnabled = FALSE; /* Mark channel as disabled in transfer descriptor. */
  DMA_PDD_EnablePeripheralRequest(DMA_BASE_PTR, ChannelNumber, PDD_DISABLE); /* Disable DMA channel transfer request */
  /* {Default RTOS Adapter} Critical section end, general PE function is used */
  ExitCritical();
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_SetChannelSourceAddress (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an source address for data to be transferred
**         by the DMA channel allocated for the DMA transfer defined by
**         the transfer descriptor parameter DescriptorPtr. This method
**         can be used to update DMA transfer source address when DMA
**         channel is enabled. New source address is stored in transfer
**         descriptor and written to associated DMA channel registers.
**         The new source address can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         Address         - Address of source data for a DMA
**                           channel allocated for a DMA transfer
**                           descriptor defined by the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source address
**                           is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_SetChannelSourceAddress(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TAddress Address)
{
  LDD_DMA_TAddress LocalAddress;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA_CTRL_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalAddress = DescriptorPtr->SourceAddress; /* Save actual address. */
  DescriptorPtr->SourceAddress = Address; /* Store new address in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->SourceAddress = LocalAddress; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetSourceAddress(DMA_BASE_PTR, ChannelNumber, Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_SetChannelDestinationAddress (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets an destination address for data to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer destination address when DMA channel is enabled.
**         New destination address is stored in transfer descriptor and
**         written to associated DMA channel registers. The new
**         destination address can be optionally checked for
**         consistency with rest of the transfer descriptor data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         Address         - Address of a destination data to
**                           be transferred to by the DMA channel
**                           allocated for a DMA transfer descriptor
**                           defined by the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected source address
**                           is inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_SetChannelDestinationAddress(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TAddress Address)
{
  LDD_DMA_TAddress LocalAddress;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA_CTRL_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalAddress = DescriptorPtr->DestinationAddress; /* Save actual address. */
  DescriptorPtr->DestinationAddress = Address; /* Store new address in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->DestinationAddress = LocalAddress; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetDestinationAddress(DMA_BASE_PTR, ChannelNumber, Address);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  DMA_CTRL_SetChannelByteCount (component DMA_LDD)
*/
/*!
**     @brief
**         The method sets a byte count (size of data) to be
**         transferred by the DMA channel allocated for the DMA
**         transfer defined by the transfer descriptor input parameter
**         DescriptorPtr. This method can be used to update DMA
**         transfer byte count when DMA channel is enabled. New
**         transfer byte count is stored in transfer descriptor and
**         written to associated DMA channel registers. The new
**         transfer byte count can be optionally checked for
**         consistency with rest of the transfer descriptor data. If
**         nested operation is used, the method sets the minor (inner)
**         loop byte count.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         DescriptorPtr   - Pointer to a DMA
**                           transfer descriptor structure.
**     @param
**         ByteCount       - Byte count (size of data) to
**                           be transferred by the DMA channel allocated
**                           for a DMA transfer descriptor defined by
**                           the TCD parameter.
**     @return
**                         - Error code, possible codes:
**                           - ERR_OK - OK.
**                           - ERR_SPEED - This device does not work in
**                           the active clock configuration.
**                           - ERR_DISABLED - Component or device is
**                           disabled.
**                           - ERR_NOTAVAIL - There is not any DMA
**                           channel allocated for the selected transfer
**                           descriptor.
**                           - ERR_PARAM_DATA - Selected byte count is
**                           inconsistent with rest of transfer
**                           descriptor data.
*/
/* ===================================================================*/
LDD_TError DMA_CTRL_SetChannelByteCount(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TByteCount ByteCount)
{
  LDD_DMA_TByteCount LocalByteCount;
  LDD_DMA_TChannelNumber ChannelNumber;

  /* Device state test - this test can be disabled by setting the "Ignore enable test"
     property to the "yes" value in the "Configuration inspector" */
  if (!((DMA_CTRL_TDeviceData *)(DeviceDataPtr))->EnUser) { /* Is the device disabled by user? */
    return ERR_DISABLED;               /* No, return ERR_DISABLED. */
  }
  /* Check channel allocation for the transfer descriptor and eventually store associated DMA channel number. */
  if (!GetChannelNumber(DeviceDataPtr, DescriptorPtr, &ChannelNumber)) {
    return ERR_NOTAVAIL;               /* No channel allocated for the transfer. */
  }
  /* Transferred byte count range test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  if (ByteCount > DMA_CTRL_MAX_BYTE_COUNT) { /* Test if ByteCount is in correct range. */
    return ERR_PARAM_DATA;
  }   
  /* New transfer descriptor consistency test - this test can be disabled by setting the "Ignore range checking"
     property to the "yes" value in the "Configuration inspector" */
  LocalByteCount = DescriptorPtr->ByteCount; /* Save actual byte count. */
  DescriptorPtr->ByteCount = ByteCount; /* Store new byte count in transfer descriptor. */
  if (!VerifyDescriptor(DescriptorPtr)) { /* Test consistency of new transfer descriptor. */
    DescriptorPtr->ByteCount = LocalByteCount; /* If failed, restore previous value. */
    return ERR_PARAM_DATA;
  }
  DMA_PDD_SetByteCount(DMA_BASE_PTR, ChannelNumber, ByteCount);
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  VerifyDescriptor (component DMA_LDD)
**
**     Description :
**         The method verifies a transfer descriptor of allocated channel 
**         defined by the pointer to its address. Returns TRUE if the 
**         channel's transfer descriptor is correct, FALSE if 
**         inconsistency is detected.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool VerifyDescriptor(LDD_DMA_TTransferDescriptor *DescriptorPtr)
{
  /* Store source transfer size byte divider mask */
  LDD_DMA_TTransferSize SourceDividerMask, DestinationDividerMask;

  switch (DescriptorPtr->SourceTransferSize) {
    case DMA_PDD_8_BIT:
      SourceDividerMask = 0x00U;
      break;
    case DMA_PDD_16_BIT:
      SourceDividerMask = 0x01U;
      break;
    case DMA_PDD_32_BIT:
      SourceDividerMask = 0x03U;
      break;
    default:
      return FALSE;
  }
  switch (DescriptorPtr->DestinationTransferSize) {
    case DMA_PDD_8_BIT:
      DestinationDividerMask = 0x00U;
      break;
    case DMA_PDD_16_BIT:
      DestinationDividerMask = 0x01U;
      break;
    case DMA_PDD_32_BIT:
      DestinationDividerMask = 0x03U;
      break;
    default:
      return FALSE;
  }
  if ((!DescriptorPtr->AutoAlign) || (SourceDividerMask >= DestinationDividerMask)) { /* If source is auto-aligned, check destination only. */
    /* Is minor loop byte count a multiple of the destination transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & DestinationDividerMask) {
      return FALSE;                    /* If no, return. */
    }
    /* Is destination address aligned to destination transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->DestinationAddress) & DestinationDividerMask) {
      return FALSE;                    /* If no, return. */
    }
  }
  if ((!DescriptorPtr->AutoAlign) || (SourceDividerMask < DestinationDividerMask)) { /* If destination is auto-aligned, check source only. */
    /* Is minor loop byte count a multiple of the source transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->ByteCount) & SourceDividerMask) {
      return FALSE;                    /* If no, return. */
    }
    /* Is source address aligned to source transfer size? */
    if ((LDD_DMA_TTransferSize)(DescriptorPtr->SourceAddress) & SourceDividerMask) {
      return FALSE;                    /* If no, return. */
    }
  }
  return TRUE;                         /* Channel descriptor verified. */
}

/*
** ===================================================================
**     Method      :  GetChannelNumber (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Number of allocated 
**         channel is returned indirectly into the ChannelNumber 
**         parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetChannelNumber(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, LDD_DMA_TChannelNumber *ChannelNumber)
{
bool ChannelFound = FALSE;

  if (((DMA_CTRL_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    ChannelFound = TRUE;
    *ChannelNumber = DescriptorPtr->ChannelNumber; /* Save channel number. */
  }
  return ChannelFound;
}

/*
** ===================================================================
**     Method      :  GetRecord (component DMA_LDD)
**
**     Description :
**         The method returns TRUE if some channel is allocated for the 
**         given descriptor, false if it is not. Pointer to the 
**         descriptor record of allocated channel is returned indirectly 
**         into the DescriptorRecordPtr parameter.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static bool GetRecord(LDD_TDeviceData *DeviceDataPtr, LDD_DMA_TTransferDescriptor *DescriptorPtr, DMA_CTRL_TDescriptorRecordPtr *DescriptorRecordAddressPtr)
{
  bool RecordFound = FALSE;

  if (((DMA_CTRL_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]->DescriptorPtr == DescriptorPtr) {
    RecordFound = TRUE;
    *DescriptorRecordAddressPtr = ((DMA_CTRL_TDeviceData *)DeviceDataPtr)->ChannelRecord[DescriptorPtr->ChannelNumber]; /* Save descriptors record address. */
  }
  return RecordFound;
}

/*
** ===================================================================
**     Method      :  TransferCompleteInterrupt (component DMA_LDD)
**
**     Description :
**         Transfer complete interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA_CTRL_Channel0Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA_CTRL_TDeviceData* DeviceDataPtr = INT_DMA0__DEFAULT_RTOS_ISRPARAM;
  if (DMA_PDD_GetChannelErrorFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_0) != 0x00U) {
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_0] & LDD_DMA_ON_ERROR) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_0]->DescriptorPtr->OnErrorEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_0]->DescriptorPtr->UserDataPtr);
    }
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_0, DMA_PDD_TRANSFER_COMPLETE_FLAG);
  } else {
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_0, DMA_PDD_TRANSFER_COMPLETE_FLAG);
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_0] & LDD_DMA_ON_COMPLETE) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_0]->DescriptorPtr->OnCompleteEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_0]->DescriptorPtr->UserDataPtr);
    }
  }
}
/*
** ===================================================================
**     Method      :  TransferCompleteInterrupt (component DMA_LDD)
**
**     Description :
**         Transfer complete interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA_CTRL_Channel1Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA_CTRL_TDeviceData* DeviceDataPtr = INT_DMA1__DEFAULT_RTOS_ISRPARAM;
  if (DMA_PDD_GetChannelErrorFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_1) != 0x00U) {
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_1] & LDD_DMA_ON_ERROR) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_1]->DescriptorPtr->OnErrorEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_1]->DescriptorPtr->UserDataPtr);
    }
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_1, DMA_PDD_TRANSFER_COMPLETE_FLAG);
  } else {
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_1, DMA_PDD_TRANSFER_COMPLETE_FLAG);
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_1] & LDD_DMA_ON_COMPLETE) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_1]->DescriptorPtr->OnCompleteEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_1]->DescriptorPtr->UserDataPtr);
    }
  }
}
/*
** ===================================================================
**     Method      :  TransferCompleteInterrupt (component DMA_LDD)
**
**     Description :
**         Transfer complete interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA_CTRL_Channel2Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA_CTRL_TDeviceData* DeviceDataPtr = INT_DMA2__DEFAULT_RTOS_ISRPARAM;
  if (DMA_PDD_GetChannelErrorFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_2) != 0x00U) {
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_2] & LDD_DMA_ON_ERROR) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_2]->DescriptorPtr->OnErrorEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_2]->DescriptorPtr->UserDataPtr);
    }
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_2, DMA_PDD_TRANSFER_COMPLETE_FLAG);
  } else {
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_2, DMA_PDD_TRANSFER_COMPLETE_FLAG);
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_2] & LDD_DMA_ON_COMPLETE) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_2]->DescriptorPtr->OnCompleteEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_2]->DescriptorPtr->UserDataPtr);
    }
  }
}
/*
** ===================================================================
**     Method      :  TransferCompleteInterrupt (component DMA_LDD)
**
**     Description :
**         Transfer complete interrupt service routine.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(DMA_CTRL_Channel3Interrupt)
{
  /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
  DMA_CTRL_TDeviceData* DeviceDataPtr = INT_DMA3__DEFAULT_RTOS_ISRPARAM;
  if (DMA_PDD_GetChannelErrorFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_3) != 0x00U) {
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_3] & LDD_DMA_ON_ERROR) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_3]->DescriptorPtr->OnErrorEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_3]->DescriptorPtr->UserDataPtr);
    }
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_3, DMA_PDD_TRANSFER_COMPLETE_FLAG);
  } else {
    DMA_PDD_ClearInterruptFlags(DMA_BASE_PTR, DMA_CTRL_CHANNEL_3, DMA_PDD_TRANSFER_COMPLETE_FLAG);
    if (((DeviceDataPtr)->EventMask[DMA_CTRL_CHANNEL_3] & LDD_DMA_ON_COMPLETE) != 0x00U) {
      DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_3]->DescriptorPtr->OnCompleteEventPtr(DeviceDataPtr->ChannelRecord[DMA_CTRL_CHANNEL_3]->DescriptorPtr->UserDataPtr);
    }
  }
}
/* END DMA_CTRL. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.08]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/

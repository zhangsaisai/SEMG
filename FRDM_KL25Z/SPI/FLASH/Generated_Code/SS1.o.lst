   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"SS1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	28
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_SPI1__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_SPI1__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.SS1_Init,"ax",%progbits
  30              		.align	2
  31              		.global	SS1_Init
  32              		.code	16
  33              		.thumb_func
  35              	SS1_Init:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/SS1.c"
   1:../Generated_Code/SS1.c **** /* ###################################################################
   2:../Generated_Code/SS1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/SS1.c **** **     Filename    : SS1.c
   4:../Generated_Code/SS1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/SS1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/SS1.c **** **     Component   : SPISlave_LDD
   7:../Generated_Code/SS1.c **** **     Version     : Component 01.047, Driver 01.02, CPU db: 3.00.000
   8:../Generated_Code/SS1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/SS1.c **** **     Date/Time   : 2015-09-10, 09:38, # CodeGen: 1
  10:../Generated_Code/SS1.c **** **     Abstract    :
  11:../Generated_Code/SS1.c **** **         This component "SPISlave_LDD" implements SLAVE part of synchronous
  12:../Generated_Code/SS1.c **** **         serial master-slave communication.
  13:../Generated_Code/SS1.c **** **     Settings    :
  14:../Generated_Code/SS1.c **** **          Component name                                 : SS1
  15:../Generated_Code/SS1.c **** **          Device                                         : SPI1
  16:../Generated_Code/SS1.c **** **          Interrupt service/event                        : Enabled
  17:../Generated_Code/SS1.c **** **            Input interrupt                              : INT_SPI1
  18:../Generated_Code/SS1.c **** **            Input interrupt priority                     : medium priority
  19:../Generated_Code/SS1.c **** **            Output interrupt                             : INT_SPI1
  20:../Generated_Code/SS1.c **** **            Output interrupt priority                    : medium priority
  21:../Generated_Code/SS1.c **** **          Settings                                       : 
  22:../Generated_Code/SS1.c **** **            Input pin                                    : Enabled
  23:../Generated_Code/SS1.c **** **              Pin                                        : PTE3/SPI1_MISO/SPI1_MOSI
  24:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  25:../Generated_Code/SS1.c **** **            Output pin                                   : Enabled
  26:../Generated_Code/SS1.c **** **              Pin                                        : PTE1/SPI1_MOSI/UART1_RX/SPI1_MISO/I2C1
  27:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  28:../Generated_Code/SS1.c **** **            Clock pin                                    : 
  29:../Generated_Code/SS1.c **** **              Pin                                        : PTE2/SPI1_SCK
  30:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  31:../Generated_Code/SS1.c **** **            Slave select                                 : 
  32:../Generated_Code/SS1.c **** **              Pin                                        : PTE4/SPI1_PCS0
  33:../Generated_Code/SS1.c **** **              Pin signal                                 : 
  34:../Generated_Code/SS1.c **** **              Active level                               : Low
  35:../Generated_Code/SS1.c **** **            Attribute set                                : 
  36:../Generated_Code/SS1.c **** **              Width                                      : 8 bits
  37:../Generated_Code/SS1.c **** **              MSB first                                  : yes
  38:../Generated_Code/SS1.c **** **              Clock polarity                             : Low
  39:../Generated_Code/SS1.c **** **              Clock phase                                : Capture on leading edge
  40:../Generated_Code/SS1.c **** **              Parity                                     : None
  41:../Generated_Code/SS1.c **** **            HW input buffer size                         : Max buffer size
  42:../Generated_Code/SS1.c **** **            HW input watermark                           : 1
  43:../Generated_Code/SS1.c **** **            Receiver DMA                                 : Disabled
  44:../Generated_Code/SS1.c **** **            HW output buffer size                        : Max buffer size
  45:../Generated_Code/SS1.c **** **            HW output watermark                          : 1
  46:../Generated_Code/SS1.c **** **            Transmitter DMA                              : Disabled
  47:../Generated_Code/SS1.c **** **          Initialization                                 : 
  48:../Generated_Code/SS1.c **** **            Enabled in init. code                        : yes
  49:../Generated_Code/SS1.c **** **            Auto initialization                          : no
  50:../Generated_Code/SS1.c **** **            Event mask                                   : 
  51:../Generated_Code/SS1.c **** **              OnBlockSent                                : Enabled
  52:../Generated_Code/SS1.c **** **              OnBlockReceived                            : Enabled
  53:../Generated_Code/SS1.c **** **              OnError                                    : Disabled
  54:../Generated_Code/SS1.c **** **     Contents    :
  55:../Generated_Code/SS1.c **** **         Init                   - LDD_TDeviceData* SS1_Init(LDD_TUserData *UserDataPtr);
  56:../Generated_Code/SS1.c **** **         Deinit                 - void SS1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  57:../Generated_Code/SS1.c **** **         SendBlock              - LDD_TError SS1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TD
  58:../Generated_Code/SS1.c **** **         ReceiveBlock           - LDD_TError SS1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD
  59:../Generated_Code/SS1.c **** **         GetSentDataNum         - uint16_t SS1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);
  60:../Generated_Code/SS1.c **** **         GetReceivedDataNum     - uint16_t SS1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr)
  61:../Generated_Code/SS1.c **** **         GetBlockSentStatus     - bool SS1_GetBlockSentStatus(LDD_TDeviceData *DeviceDataPtr);
  62:../Generated_Code/SS1.c **** **         GetBlockReceivedStatus - bool SS1_GetBlockReceivedStatus(LDD_TDeviceData *DeviceDataPtr)
  63:../Generated_Code/SS1.c **** **
  64:../Generated_Code/SS1.c **** **     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  65:../Generated_Code/SS1.c **** **     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
  66:../Generated_Code/SS1.c **** **     
  67:../Generated_Code/SS1.c **** **     http      : www.freescale.com
  68:../Generated_Code/SS1.c **** **     mail      : support@freescale.com
  69:../Generated_Code/SS1.c **** ** ###################################################################*/
  70:../Generated_Code/SS1.c **** /*!
  71:../Generated_Code/SS1.c **** ** @file SS1.c
  72:../Generated_Code/SS1.c **** ** @version 01.02
  73:../Generated_Code/SS1.c **** ** @brief
  74:../Generated_Code/SS1.c **** **         This component "SPISlave_LDD" implements SLAVE part of synchronous
  75:../Generated_Code/SS1.c **** **         serial master-slave communication.
  76:../Generated_Code/SS1.c **** */         
  77:../Generated_Code/SS1.c **** /*!
  78:../Generated_Code/SS1.c **** **  @addtogroup SS1_module SS1 module documentation
  79:../Generated_Code/SS1.c **** **  @{
  80:../Generated_Code/SS1.c **** */         
  81:../Generated_Code/SS1.c **** 
  82:../Generated_Code/SS1.c **** /* MODULE SS1. */
  83:../Generated_Code/SS1.c **** /*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */
  84:../Generated_Code/SS1.c **** 
  85:../Generated_Code/SS1.c **** #include "Events.h"
  86:../Generated_Code/SS1.c **** #include "SS1.h"
  87:../Generated_Code/SS1.c **** /* {Default RTOS Adapter} No RTOS includes */
  88:../Generated_Code/SS1.c **** 
  89:../Generated_Code/SS1.c **** #ifdef __cplusplus
  90:../Generated_Code/SS1.c **** extern "C" {
  91:../Generated_Code/SS1.c **** #endif 
  92:../Generated_Code/SS1.c **** 
  93:../Generated_Code/SS1.c **** #define AVAILABLE_EVENTS_MASK (LDD_SPISLAVE_ON_BLOCK_RECEIVED | LDD_SPISLAVE_ON_BLOCK_SENT)
  94:../Generated_Code/SS1.c **** 
  95:../Generated_Code/SS1.c **** /* These constants contain pins masks */
  96:../Generated_Code/SS1.c **** #define SS1_AVAILABLE_PIN_MASK (LDD_SPISLAVE_INPUT_PIN | LDD_SPISLAVE_OUTPUT_PIN | LDD_SPISLAVE_CLK
  97:../Generated_Code/SS1.c **** #define BLOCK_SENT      0x01U          /* Data block sent flag */
  98:../Generated_Code/SS1.c **** #define BLOCK_RECEIVED  0x02U          /* Data block received flag */
  99:../Generated_Code/SS1.c **** 
 100:../Generated_Code/SS1.c **** 
 101:../Generated_Code/SS1.c **** 
 102:../Generated_Code/SS1.c **** 
 103:../Generated_Code/SS1.c **** 
 104:../Generated_Code/SS1.c **** 
 105:../Generated_Code/SS1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 106:../Generated_Code/SS1.c **** static SS1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 107:../Generated_Code/SS1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 108:../Generated_Code/SS1.c **** static SS1_TDeviceDataPtr INT_SPI1__DEFAULT_RTOS_ISRPARAM;
 109:../Generated_Code/SS1.c **** /* Internal method prototypes */
 110:../Generated_Code/SS1.c **** 
 111:../Generated_Code/SS1.c **** /*
 112:../Generated_Code/SS1.c **** ** ===================================================================
 113:../Generated_Code/SS1.c **** **     Method      :  SS1_Init (component SPISlave_LDD)
 114:../Generated_Code/SS1.c **** */
 115:../Generated_Code/SS1.c **** /*!
 116:../Generated_Code/SS1.c **** **     @brief
 117:../Generated_Code/SS1.c **** **         Initializes the device. Allocates memory for the device data
 118:../Generated_Code/SS1.c **** **         structure, allocates interrupt vectors and sets interrupt
 119:../Generated_Code/SS1.c **** **         priority, sets pin routing, sets timing, etc.
 120:../Generated_Code/SS1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 121:../Generated_Code/SS1.c **** **         device is also enabled(see the description of the Enable()
 122:../Generated_Code/SS1.c **** **         method). In this case the Enable() method is not necessary
 123:../Generated_Code/SS1.c **** **         and needn't to be generated. 
 124:../Generated_Code/SS1.c **** **         This method can be called only once. Before the second call
 125:../Generated_Code/SS1.c **** **         of Init() the Deinit() must be called first.
 126:../Generated_Code/SS1.c **** **     @param
 127:../Generated_Code/SS1.c **** **         UserDataPtr     - Pointer to the user or
 128:../Generated_Code/SS1.c **** **                           RTOS specific data. This pointer will be
 129:../Generated_Code/SS1.c **** **                           passed as an event or callback parameter.
 130:../Generated_Code/SS1.c **** **     @return
 131:../Generated_Code/SS1.c **** **                         - Device data structure pointer.
 132:../Generated_Code/SS1.c **** */
 133:../Generated_Code/SS1.c **** /* ===================================================================*/
 134:../Generated_Code/SS1.c **** LDD_TDeviceData* SS1_Init(LDD_TUserData *UserDataPtr)
 135:../Generated_Code/SS1.c **** {
  38              		.loc 1 135 0
  39              		.cfi_startproc
  40 0000 80B5     		push	{r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 7, -8
  44              		.cfi_offset 14, -4
  45 0002 84B0     		sub	sp, sp, #16
  46              	.LCFI1:
  47              		.cfi_def_cfa_offset 24
  48 0004 00AF     		add	r7, sp, #0
  49              	.LCFI2:
  50              		.cfi_def_cfa_register 7
  51 0006 7860     		str	r0, [r7, #4]
 136:../Generated_Code/SS1.c ****   /* Allocate LDD device structure */
 137:../Generated_Code/SS1.c ****   SS1_TDeviceDataPtr DeviceDataPrv;
 138:../Generated_Code/SS1.c **** 
 139:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 140:../Generated_Code/SS1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  52              		.loc 1 140 0
  53 0008 3E4B     		ldr	r3, .L3
  54 000a FB60     		str	r3, [r7, #12]
 141:../Generated_Code/SS1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  55              		.loc 1 141 0
  56 000c FB68     		ldr	r3, [r7, #12]
  57 000e 7A68     		ldr	r2, [r7, #4]
  58 0010 9A61     		str	r2, [r3, #24]
 142:../Generated_Code/SS1.c ****   /* Interrupt vector(s) allocation */
 143:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 144:../Generated_Code/SS1.c ****   INT_SPI1__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  59              		.loc 1 144 0
  60 0012 3D4B     		ldr	r3, .L3+4
  61 0014 FA68     		ldr	r2, [r7, #12]
  62 0016 1A60     		str	r2, [r3]
 145:../Generated_Code/SS1.c ****   DeviceDataPrv->ErrFlag = 0x00U;      /* Clear error flags */
  63              		.loc 1 145 0
  64 0018 FB68     		ldr	r3, [r7, #12]
  65 001a 0022     		mov	r2, #0
  66 001c 1A60     		str	r2, [r3]
 146:../Generated_Code/SS1.c ****   /* Clear the receive counters and pointer */
 147:../Generated_Code/SS1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  67              		.loc 1 147 0
  68 001e FB68     		ldr	r3, [r7, #12]
  69 0020 0022     		mov	r2, #0
  70 0022 9A80     		strh	r2, [r3, #4]
 148:../Generated_Code/SS1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  71              		.loc 1 148 0
  72 0024 FB68     		ldr	r3, [r7, #12]
  73 0026 0022     		mov	r2, #0
  74 0028 9A81     		strh	r2, [r3, #12]
 149:../Generated_Code/SS1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  75              		.loc 1 149 0
  76 002a FB68     		ldr	r3, [r7, #12]
  77 002c 0022     		mov	r2, #0
  78 002e 9A60     		str	r2, [r3, #8]
 150:../Generated_Code/SS1.c ****   /* Clear the transmit counters and pointer */
 151:../Generated_Code/SS1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  79              		.loc 1 151 0
  80 0030 FB68     		ldr	r3, [r7, #12]
  81 0032 0022     		mov	r2, #0
  82 0034 DA81     		strh	r2, [r3, #14]
 152:../Generated_Code/SS1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  83              		.loc 1 152 0
  84 0036 FB68     		ldr	r3, [r7, #12]
  85 0038 0022     		mov	r2, #0
  86 003a 9A82     		strh	r2, [r3, #20]
 153:../Generated_Code/SS1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  87              		.loc 1 153 0
  88 003c FB68     		ldr	r3, [r7, #12]
  89 003e 0022     		mov	r2, #0
  90 0040 1A61     		str	r2, [r3, #16]
 154:../Generated_Code/SS1.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset flags */
  91              		.loc 1 154 0
  92 0042 FB68     		ldr	r3, [r7, #12]
  93 0044 0022     		mov	r2, #0
  94 0046 9A75     		strb	r2, [r3, #22]
 155:../Generated_Code/SS1.c ****   /* SIM_SCGC4: SPI1=1 */
 156:../Generated_Code/SS1.c ****   SIM_SCGC4 |= SIM_SCGC4_SPI1_MASK;                                   
  95              		.loc 1 156 0
  96 0048 304A     		ldr	r2, .L3+8
  97 004a 3049     		ldr	r1, .L3+8
  98 004c 304B     		ldr	r3, .L3+12
  99 004e CB58     		ldr	r3, [r1, r3]
 100 0050 8021     		mov	r1, #128
 101 0052 0904     		lsl	r1, r1, #16
 102 0054 1943     		orr	r1, r3
 103 0056 2E4B     		ldr	r3, .L3+12
 104 0058 D150     		str	r1, [r2, r3]
 157:../Generated_Code/SS1.c ****   /* SPI1_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=1,SSOE=0,LSBFE=0 */
 158:../Generated_Code/SS1.c ****   SPI1_C1 = SPI_C1_CPHA_MASK;          /* Clear control register */
 105              		.loc 1 158 0
 106 005a 2E4B     		ldr	r3, .L3+16
 107 005c 0422     		mov	r2, #4
 108 005e 1A70     		strb	r2, [r3]
 159:../Generated_Code/SS1.c ****   /* Interrupt vector(s) priority setting */
 160:../Generated_Code/SS1.c ****   /* NVIC_IPR2: PRI_11=0x80 */
 161:../Generated_Code/SS1.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 109              		.loc 1 161 0
 110 0060 2D4A     		ldr	r2, .L3+20
 111 0062 2D49     		ldr	r1, .L3+20
 112 0064 C223     		mov	r3, #194
 113 0066 9B00     		lsl	r3, r3, #2
 114 0068 CB58     		ldr	r3, [r1, r3]
 115 006a 1B02     		lsl	r3, r3, #8
 116 006c 1B0A     		lsr	r3, r3, #8
 117 006e 8021     		mov	r1, #128
 118 0070 0906     		lsl	r1, r1, #24
 119 0072 1943     		orr	r1, r3
 120 0074 C223     		mov	r3, #194
 121 0076 9B00     		lsl	r3, r3, #2
 122 0078 D150     		str	r1, [r2, r3]
 162:../Generated_Code/SS1.c ****                NVIC_IP_PRI_11(0x7F)
 163:../Generated_Code/SS1.c ****               )) | (uint32_t)(
 164:../Generated_Code/SS1.c ****                NVIC_IP_PRI_11(0x80)
 165:../Generated_Code/SS1.c ****               ));                                  
 166:../Generated_Code/SS1.c ****   /* NVIC_ISER: SETENA|=0x0800 */
 167:../Generated_Code/SS1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0800);                                   
 123              		.loc 1 167 0
 124 007a 274B     		ldr	r3, .L3+20
 125 007c 264A     		ldr	r2, .L3+20
 126 007e 1268     		ldr	r2, [r2]
 127 0080 8021     		mov	r1, #128
 128 0082 0901     		lsl	r1, r1, #4
 129 0084 0A43     		orr	r2, r1
 130 0086 1A60     		str	r2, [r3]
 168:../Generated_Code/SS1.c ****   /* PORTE_PCR3: ISF=0,MUX=5 */
 169:../Generated_Code/SS1.c ****   PORTE_PCR3 = (uint32_t)((PORTE_PCR3 & (uint32_t)~(uint32_t)(
 131              		.loc 1 169 0
 132 0088 244B     		ldr	r3, .L3+24
 133 008a 244A     		ldr	r2, .L3+24
 134 008c D168     		ldr	r1, [r2, #12]
 135 008e 244A     		ldr	r2, .L3+28
 136 0090 0A40     		and	r2, r1
 137 0092 A021     		mov	r1, #160
 138 0094 C900     		lsl	r1, r1, #3
 139 0096 0A43     		orr	r2, r1
 140 0098 DA60     		str	r2, [r3, #12]
 170:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 171:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 172:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 173:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 174:../Generated_Code/SS1.c ****                ));                                  
 175:../Generated_Code/SS1.c ****   /* PORTE_PCR1: ISF=0,MUX=5 */
 176:../Generated_Code/SS1.c ****   PORTE_PCR1 = (uint32_t)((PORTE_PCR1 & (uint32_t)~(uint32_t)(
 141              		.loc 1 176 0
 142 009a 204B     		ldr	r3, .L3+24
 143 009c 1F4A     		ldr	r2, .L3+24
 144 009e 5168     		ldr	r1, [r2, #4]
 145 00a0 1F4A     		ldr	r2, .L3+28
 146 00a2 0A40     		and	r2, r1
 147 00a4 A021     		mov	r1, #160
 148 00a6 C900     		lsl	r1, r1, #3
 149 00a8 0A43     		orr	r2, r1
 150 00aa 5A60     		str	r2, [r3, #4]
 177:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 178:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 179:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 180:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 181:../Generated_Code/SS1.c ****                ));                                  
 182:../Generated_Code/SS1.c ****   /* PORTE_PCR2: ISF=0,MUX=2 */
 183:../Generated_Code/SS1.c ****   PORTE_PCR2 = (uint32_t)((PORTE_PCR2 & (uint32_t)~(uint32_t)(
 151              		.loc 1 183 0
 152 00ac 1B4B     		ldr	r3, .L3+24
 153 00ae 1B4A     		ldr	r2, .L3+24
 154 00b0 9168     		ldr	r1, [r2, #8]
 155 00b2 1B4A     		ldr	r2, .L3+28
 156 00b4 0A40     		and	r2, r1
 157 00b6 8021     		mov	r1, #128
 158 00b8 8900     		lsl	r1, r1, #2
 159 00ba 0A43     		orr	r2, r1
 160 00bc 9A60     		str	r2, [r3, #8]
 184:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 185:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 186:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 187:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 188:../Generated_Code/SS1.c ****                ));                                  
 189:../Generated_Code/SS1.c ****   /* PORTE_PCR4: ISF=0,MUX=2 */
 190:../Generated_Code/SS1.c ****   PORTE_PCR4 = (uint32_t)((PORTE_PCR4 & (uint32_t)~(uint32_t)(
 161              		.loc 1 190 0
 162 00be 174B     		ldr	r3, .L3+24
 163 00c0 164A     		ldr	r2, .L3+24
 164 00c2 1169     		ldr	r1, [r2, #16]
 165 00c4 164A     		ldr	r2, .L3+28
 166 00c6 0A40     		and	r2, r1
 167 00c8 8021     		mov	r1, #128
 168 00ca 8900     		lsl	r1, r1, #2
 169 00cc 0A43     		orr	r2, r1
 170 00ce 1A61     		str	r2, [r3, #16]
 191:../Generated_Code/SS1.c ****                 PORT_PCR_ISF_MASK |
 192:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x05)
 193:../Generated_Code/SS1.c ****                )) | (uint32_t)(
 194:../Generated_Code/SS1.c ****                 PORT_PCR_MUX(0x02)
 195:../Generated_Code/SS1.c ****                ));                                  
 196:../Generated_Code/SS1.c ****   /* SPI1_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=0,SSOE=0,LSBFE=0 */
 197:../Generated_Code/SS1.c ****   SPI1_C1 = 0x00U;                     /* Set Configuration register */
 171              		.loc 1 197 0
 172 00d0 104B     		ldr	r3, .L3+16
 173 00d2 0022     		mov	r2, #0
 174 00d4 1A70     		strb	r2, [r3]
 198:../Generated_Code/SS1.c ****   /* SPI1_C2: SPMIE=0,??=0,TXDMAE=0,MODFEN=0,BIDIROE=0,RXDMAE=0,SPISWAI=0,SPC0=0 */
 199:../Generated_Code/SS1.c ****   SPI1_C2 = 0x00U;                     /* Set Configuration register */
 175              		.loc 1 199 0
 176 00d6 0F4B     		ldr	r3, .L3+16
 177 00d8 0022     		mov	r2, #0
 178 00da 5A70     		strb	r2, [r3, #1]
 200:../Generated_Code/SS1.c ****   /* SPI1_BR: ??=0,SPPR=0,SPR=0 */
 201:../Generated_Code/SS1.c ****   SPI1_BR = (SPI_BR_SPPR(0x00) | SPI_BR_SPR(0x00)); /* Set baud rate register */
 179              		.loc 1 201 0
 180 00dc 0D4B     		ldr	r3, .L3+16
 181 00de 0022     		mov	r2, #0
 182 00e0 9A70     		strb	r2, [r3, #2]
 202:../Generated_Code/SS1.c ****   /* SPI1_C1: SPE=1 */
 203:../Generated_Code/SS1.c ****   SPI1_C1 |= SPI_C1_SPE_MASK;          /* Enable device */
 183              		.loc 1 203 0
 184 00e2 0C4B     		ldr	r3, .L3+16
 185 00e4 0B4A     		ldr	r2, .L3+16
 186 00e6 1278     		ldrb	r2, [r2]
 187 00e8 D2B2     		uxtb	r2, r2
 188 00ea 4021     		mov	r1, #64
 189 00ec 0A43     		orr	r2, r1
 190 00ee D2B2     		uxtb	r2, r2
 191 00f0 1A70     		strb	r2, [r3]
 204:../Generated_Code/SS1.c ****   /* Registration of the device structure */
 205:../Generated_Code/SS1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SS1_ID,DeviceDataPrv);
 192              		.loc 1 205 0
 193 00f2 0C4B     		ldr	r3, .L3+32
 194 00f4 FA68     		ldr	r2, [r7, #12]
 195 00f6 5A60     		str	r2, [r3, #4]
 206:../Generated_Code/SS1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 196              		.loc 1 206 0
 197 00f8 FB68     		ldr	r3, [r7, #12]
 207:../Generated_Code/SS1.c **** }
 198              		.loc 1 207 0
 199 00fa 181C     		mov	r0, r3
 200 00fc BD46     		mov	sp, r7
 201 00fe 04B0     		add	sp, sp, #16
 202              		@ sp needed for prologue
 203 0100 80BD     		pop	{r7, pc}
 204              	.L4:
 205 0102 C046     		.align	2
 206              	.L3:
 207 0104 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 208 0108 00000000 		.word	INT_SPI1__DEFAULT_RTOS_ISRPARAM
 209 010c 00700440 		.word	1074032640
 210 0110 34100000 		.word	4148
 211 0114 00700740 		.word	1074229248
 212 0118 00E100E0 		.word	-536813312
 213 011c 00D00440 		.word	1074057216
 214 0120 FFF8FFFE 		.word	-16779009
 215 0124 00000000 		.word	PE_LDD_DeviceDataList
 216              		.cfi_endproc
 217              	.LFE0:
 219              		.section	.text.SS1_Deinit,"ax",%progbits
 220              		.align	2
 221              		.global	SS1_Deinit
 222              		.code	16
 223              		.thumb_func
 225              	SS1_Deinit:
 226              	.LFB1:
 208:../Generated_Code/SS1.c **** 
 209:../Generated_Code/SS1.c **** /*
 210:../Generated_Code/SS1.c **** ** ===================================================================
 211:../Generated_Code/SS1.c **** **     Method      :  SS1_Deinit (component SPISlave_LDD)
 212:../Generated_Code/SS1.c **** */
 213:../Generated_Code/SS1.c **** /*!
 214:../Generated_Code/SS1.c **** **     @brief
 215:../Generated_Code/SS1.c **** **         This method deinitializes the device. It switches off the
 216:../Generated_Code/SS1.c **** **         device, frees the device data structure memory, interrupts
 217:../Generated_Code/SS1.c **** **         vectors, etc.
 218:../Generated_Code/SS1.c **** **     @param
 219:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 220:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 221:../Generated_Code/SS1.c **** */
 222:../Generated_Code/SS1.c **** /* ===================================================================*/
 223:../Generated_Code/SS1.c **** void SS1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 224:../Generated_Code/SS1.c **** {
 227              		.loc 1 224 0
 228              		.cfi_startproc
 229 0000 80B5     		push	{r7, lr}
 230              	.LCFI3:
 231              		.cfi_def_cfa_offset 8
 232              		.cfi_offset 7, -8
 233              		.cfi_offset 14, -4
 234 0002 82B0     		sub	sp, sp, #8
 235              	.LCFI4:
 236              		.cfi_def_cfa_offset 16
 237 0004 00AF     		add	r7, sp, #0
 238              	.LCFI5:
 239              		.cfi_def_cfa_register 7
 240 0006 7860     		str	r0, [r7, #4]
 225:../Generated_Code/SS1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 226:../Generated_Code/SS1.c ****   /* SPI1_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=1,SSOE=0,LSBFE=0 */
 227:../Generated_Code/SS1.c ****   SPI1_C1 = SPI_C1_CPHA_MASK;          /* Disable device */
 241              		.loc 1 227 0
 242 0008 084B     		ldr	r3, .L6
 243 000a 0422     		mov	r2, #4
 244 000c 1A70     		strb	r2, [r3]
 228:../Generated_Code/SS1.c ****   /* Restoring the interrupt vector */
 229:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 230:../Generated_Code/SS1.c ****   /* Unregistration of the device structure */
 231:../Generated_Code/SS1.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_SS1_ID);
 245              		.loc 1 231 0
 246 000e 084B     		ldr	r3, .L6+4
 247 0010 0022     		mov	r2, #0
 248 0012 5A60     		str	r2, [r3, #4]
 232:../Generated_Code/SS1.c ****   /* Deallocation of the device structure */
 233:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 234:../Generated_Code/SS1.c ****   /* SIM_SCGC4: SPI1=0 */
 235:../Generated_Code/SS1.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_SPI1_MASK);                                   
 249              		.loc 1 235 0
 250 0014 074A     		ldr	r2, .L6+8
 251 0016 0749     		ldr	r1, .L6+8
 252 0018 074B     		ldr	r3, .L6+12
 253 001a C958     		ldr	r1, [r1, r3]
 254 001c 074B     		ldr	r3, .L6+16
 255 001e 1940     		and	r1, r3
 256 0020 054B     		ldr	r3, .L6+12
 257 0022 D150     		str	r1, [r2, r3]
 236:../Generated_Code/SS1.c **** }
 258              		.loc 1 236 0
 259 0024 BD46     		mov	sp, r7
 260 0026 02B0     		add	sp, sp, #8
 261              		@ sp needed for prologue
 262 0028 80BD     		pop	{r7, pc}
 263              	.L7:
 264 002a C046     		.align	2
 265              	.L6:
 266 002c 00700740 		.word	1074229248
 267 0030 00000000 		.word	PE_LDD_DeviceDataList
 268 0034 00700440 		.word	1074032640
 269 0038 34100000 		.word	4148
 270 003c FFFF7FFF 		.word	-8388609
 271              		.cfi_endproc
 272              	.LFE1:
 274              		.section	.text.SS1_ReceiveBlock,"ax",%progbits
 275              		.align	2
 276              		.global	SS1_ReceiveBlock
 277              		.code	16
 278              		.thumb_func
 280              	SS1_ReceiveBlock:
 281              	.LFB2:
 237:../Generated_Code/SS1.c **** 
 238:../Generated_Code/SS1.c **** /*
 239:../Generated_Code/SS1.c **** ** ===================================================================
 240:../Generated_Code/SS1.c **** **     Method      :  SS1_ReceiveBlock (component SPISlave_LDD)
 241:../Generated_Code/SS1.c **** */
 242:../Generated_Code/SS1.c **** /*!
 243:../Generated_Code/SS1.c **** **     @brief
 244:../Generated_Code/SS1.c **** **         This method specifies the number of data to receive. The
 245:../Generated_Code/SS1.c **** **         method returns ERR_BUSY until the specified number of
 246:../Generated_Code/SS1.c **** **         characters is received. The method <CancelBlockReception>
 247:../Generated_Code/SS1.c **** **         can be used to cancel a running receive operation.
 248:../Generated_Code/SS1.c **** **     @param
 249:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 250:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 251:../Generated_Code/SS1.c **** **     @param
 252:../Generated_Code/SS1.c **** **         BufferPtr       - Pointer to A buffer where
 253:../Generated_Code/SS1.c **** **                           received characters will be stored.
 254:../Generated_Code/SS1.c **** **     @param
 255:../Generated_Code/SS1.c **** **         Size            - Size of the block
 256:../Generated_Code/SS1.c **** **     @return
 257:../Generated_Code/SS1.c **** **                         - Error code, possible codes:
 258:../Generated_Code/SS1.c **** **                           ERR_OK - OK
 259:../Generated_Code/SS1.c **** **                           ERR_DISABLED - Component is disabled
 260:../Generated_Code/SS1.c **** **                           ERR_BUSY - The previous receive request is
 261:../Generated_Code/SS1.c **** **                           pending
 262:../Generated_Code/SS1.c **** */
 263:../Generated_Code/SS1.c **** /* ===================================================================*/
 264:../Generated_Code/SS1.c **** LDD_TError SS1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 265:../Generated_Code/SS1.c **** {
 282              		.loc 1 265 0
 283              		.cfi_startproc
 284 0000 80B5     		push	{r7, lr}
 285              	.LCFI6:
 286              		.cfi_def_cfa_offset 8
 287              		.cfi_offset 7, -8
 288              		.cfi_offset 14, -4
 289 0002 84B0     		sub	sp, sp, #16
 290              	.LCFI7:
 291              		.cfi_def_cfa_offset 24
 292 0004 00AF     		add	r7, sp, #0
 293              	.LCFI8:
 294              		.cfi_def_cfa_register 7
 295 0006 F860     		str	r0, [r7, #12]
 296 0008 B960     		str	r1, [r7, #8]
 297 000a BB1D     		add	r3, r7, #6
 298 000c 1A80     		strh	r2, [r3]
 266:../Generated_Code/SS1.c ****   if (((SS1_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq != 0x00U) { /* Is the previous receive ope
 299              		.loc 1 266 0
 300 000e FB68     		ldr	r3, [r7, #12]
 301 0010 9B89     		ldrh	r3, [r3, #12]
 302 0012 002B     		cmp	r3, #0
 303 0014 01D0     		beq	.L9
 267:../Generated_Code/SS1.c ****     return ERR_BUSY;                   /* If yes then error */
 304              		.loc 1 267 0
 305 0016 0823     		mov	r3, #8
 306 0018 39E0     		b	.L10
 307              	.L9:
 268:../Generated_Code/SS1.c ****   }
 269:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 270:../Generated_Code/SS1.c ****   EnterCritical();
 308              		.loc 1 270 0
 309 001a 1F4B     		ldr	r3, .L14
 310 001c 1B78     		ldrb	r3, [r3]
 311 001e DBB2     		uxtb	r3, r3
 312 0020 0133     		add	r3, r3, #1
 313 0022 DBB2     		uxtb	r3, r3
 314 0024 1C4A     		ldr	r2, .L14
 315 0026 191C     		add	r1, r3, #0
 316 0028 1170     		strb	r1, [r2]
 317 002a 012B     		cmp	r3, #1
 318 002c 04D1     		bne	.L11
 319              		.loc 1 270 0 is_stmt 0
 320 002e 1B4B     		ldr	r3, .L14+4
 321              	@ 270 "../Generated_Code/SS1.c" 1
 322 0030 EFF31080 		MRS R0, PRIMASK
 323 0034 72B6     		CPSID i
 324 0036 1870     		STRB R0, [r3]
 325              	@ 0 "" 2
 326              		.code	16
 327              	.L11:
 271:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->InpDataPtr = (uint8_t*)BufferPtr; /* Store a pointer to the 
 328              		.loc 1 271 0 is_stmt 1
 329 0038 FB68     		ldr	r3, [r7, #12]
 330 003a BA68     		ldr	r2, [r7, #8]
 331 003c 9A60     		str	r2, [r3, #8]
 272:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq = Size; /* Store a number of characters to be 
 332              		.loc 1 272 0
 333 003e FB68     		ldr	r3, [r7, #12]
 334 0040 BA1D     		add	r2, r7, #6
 335 0042 1288     		ldrh	r2, [r2]
 336 0044 9A81     		strh	r2, [r3, #12]
 273:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum = 0x00U; /* Set number of received characters
 337              		.loc 1 273 0
 338 0046 FB68     		ldr	r3, [r7, #12]
 339 0048 0022     		mov	r2, #0
 340 004a 9A80     		strh	r2, [r3, #4]
 274:../Generated_Code/SS1.c ****   if ((SPI_PDD_ReadStatusReg(SPI1_BASE_PTR) & SPI_PDD_RX_BUFFER_FULL) != 0U) {
 341              		.loc 1 274 0
 342 004c 144B     		ldr	r3, .L14+8
 343 004e DB78     		ldrb	r3, [r3, #3]
 344 0050 DBB2     		uxtb	r3, r3
 345 0052 DBB2     		uxtb	r3, r3
 346 0054 5BB2     		sxtb	r3, r3
 347 0056 002B     		cmp	r3, #0
 348 0058 01DA     		bge	.L12
 275:../Generated_Code/SS1.c ****     (void)SPI_PDD_ReadData8bit(SPI1_BASE_PTR); /* Dummy read of the data register */
 349              		.loc 1 275 0
 350 005a 114B     		ldr	r3, .L14+8
 351 005c 5B79     		ldrb	r3, [r3, #5]
 352              	.L12:
 276:../Generated_Code/SS1.c ****   }
 277:../Generated_Code/SS1.c ****   //((SS1_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_RECEIVED); /* Clear d
 278:../Generated_Code/SS1.c ****   SPI_PDD_EnableInterruptMask(SPI1_BASE_PTR, SPI_PDD_RX_BUFFER_FULL_OR_FAULT); /* Enable Rx buffer 
 353              		.loc 1 278 0
 354 005e 104B     		ldr	r3, .L14+8
 355 0060 0F4A     		ldr	r2, .L14+8
 356 0062 1278     		ldrb	r2, [r2]
 357 0064 D2B2     		uxtb	r2, r2
 358 0066 8021     		mov	r1, #128
 359 0068 4942     		neg	r1, r1
 360 006a 0A43     		orr	r2, r1
 361 006c D2B2     		uxtb	r2, r2
 362 006e 1A70     		strb	r2, [r3]
 279:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 280:../Generated_Code/SS1.c ****   ExitCritical();
 363              		.loc 1 280 0
 364 0070 094B     		ldr	r3, .L14
 365 0072 1B78     		ldrb	r3, [r3]
 366 0074 DBB2     		uxtb	r3, r3
 367 0076 013B     		sub	r3, r3, #1
 368 0078 DBB2     		uxtb	r3, r3
 369 007a 074A     		ldr	r2, .L14
 370 007c 191C     		add	r1, r3, #0
 371 007e 1170     		strb	r1, [r2]
 372 0080 002B     		cmp	r3, #0
 373 0082 03D1     		bne	.L13
 374              		.loc 1 280 0 is_stmt 0
 375 0084 054B     		ldr	r3, .L14+4
 376              	@ 280 "../Generated_Code/SS1.c" 1
 377 0086 1878     		ldrb r0, [r3]
 378 0088 80F31088 		msr PRIMASK,r0;
 379              		
 380              	@ 0 "" 2
 381              		.code	16
 382              	.L13:
 281:../Generated_Code/SS1.c ****   return ERR_OK;                       /* OK */
 383              		.loc 1 281 0 is_stmt 1
 384 008c 0023     		mov	r3, #0
 385              	.L10:
 282:../Generated_Code/SS1.c **** }
 386              		.loc 1 282 0
 387 008e 181C     		mov	r0, r3
 388 0090 BD46     		mov	sp, r7
 389 0092 04B0     		add	sp, sp, #16
 390              		@ sp needed for prologue
 391 0094 80BD     		pop	{r7, pc}
 392              	.L15:
 393 0096 C046     		.align	2
 394              	.L14:
 395 0098 00000000 		.word	SR_lock
 396 009c 00000000 		.word	SR_reg
 397 00a0 00700740 		.word	1074229248
 398              		.cfi_endproc
 399              	.LFE2:
 401              		.section	.text.SS1_SendBlock,"ax",%progbits
 402              		.align	2
 403              		.global	SS1_SendBlock
 404              		.code	16
 405              		.thumb_func
 407              	SS1_SendBlock:
 408              	.LFB3:
 283:../Generated_Code/SS1.c **** 
 284:../Generated_Code/SS1.c **** /*
 285:../Generated_Code/SS1.c **** ** ===================================================================
 286:../Generated_Code/SS1.c **** **     Method      :  SS1_SendBlock (component SPISlave_LDD)
 287:../Generated_Code/SS1.c **** */
 288:../Generated_Code/SS1.c **** /*!
 289:../Generated_Code/SS1.c **** **     @brief
 290:../Generated_Code/SS1.c **** **         This method sends a block of characters. The method returns
 291:../Generated_Code/SS1.c **** **         ERR_BUSY when the previous block transmission is not
 292:../Generated_Code/SS1.c **** **         completed. The method <CancelBlockTransmission> can be used
 293:../Generated_Code/SS1.c **** **         to cancel a transmit operation.
 294:../Generated_Code/SS1.c **** **     @param
 295:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 296:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 297:../Generated_Code/SS1.c **** **     @param
 298:../Generated_Code/SS1.c **** **         BufferPtr       - Pointer to the block of data
 299:../Generated_Code/SS1.c **** **                           to send.
 300:../Generated_Code/SS1.c **** **     @param
 301:../Generated_Code/SS1.c **** **         Size            - Number of characters in the buffer.
 302:../Generated_Code/SS1.c **** **     @return
 303:../Generated_Code/SS1.c **** **                         - Error code, possible codes:
 304:../Generated_Code/SS1.c **** **                           ERR_OK - OK
 305:../Generated_Code/SS1.c **** **                           ERR_DISABLED - Component is disabled
 306:../Generated_Code/SS1.c **** **                           ERR_BUSY - The previous transmit request is
 307:../Generated_Code/SS1.c **** **                           pending
 308:../Generated_Code/SS1.c **** */
 309:../Generated_Code/SS1.c **** /* ===================================================================*/
 310:../Generated_Code/SS1.c **** LDD_TError SS1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 311:../Generated_Code/SS1.c **** {
 409              		.loc 1 311 0
 410              		.cfi_startproc
 411 0000 80B5     		push	{r7, lr}
 412              	.LCFI9:
 413              		.cfi_def_cfa_offset 8
 414              		.cfi_offset 7, -8
 415              		.cfi_offset 14, -4
 416 0002 84B0     		sub	sp, sp, #16
 417              	.LCFI10:
 418              		.cfi_def_cfa_offset 24
 419 0004 00AF     		add	r7, sp, #0
 420              	.LCFI11:
 421              		.cfi_def_cfa_register 7
 422 0006 F860     		str	r0, [r7, #12]
 423 0008 B960     		str	r1, [r7, #8]
 424 000a BB1D     		add	r3, r7, #6
 425 000c 1A80     		strh	r2, [r3]
 312:../Generated_Code/SS1.c ****   if (((SS1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq != 0x00U) { /* Is the previous transmit op
 426              		.loc 1 312 0
 427 000e FB68     		ldr	r3, [r7, #12]
 428 0010 9B8A     		ldrh	r3, [r3, #20]
 429 0012 002B     		cmp	r3, #0
 430 0014 01D0     		beq	.L17
 313:../Generated_Code/SS1.c ****     return ERR_BUSY;                   /* If yes then error */
 431              		.loc 1 313 0
 432 0016 0823     		mov	r3, #8
 433 0018 36E0     		b	.L18
 434              	.L17:
 314:../Generated_Code/SS1.c ****   }
 315:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 316:../Generated_Code/SS1.c ****   EnterCritical();
 435              		.loc 1 316 0
 436 001a 1D4B     		ldr	r3, .L21
 437 001c 1B78     		ldrb	r3, [r3]
 438 001e DBB2     		uxtb	r3, r3
 439 0020 0133     		add	r3, r3, #1
 440 0022 DBB2     		uxtb	r3, r3
 441 0024 1A4A     		ldr	r2, .L21
 442 0026 191C     		add	r1, r3, #0
 443 0028 1170     		strb	r1, [r2]
 444 002a 012B     		cmp	r3, #1
 445 002c 04D1     		bne	.L19
 446              		.loc 1 316 0 is_stmt 0
 447 002e 194B     		ldr	r3, .L21+4
 448              	@ 316 "../Generated_Code/SS1.c" 1
 449 0030 EFF31080 		MRS R0, PRIMASK
 450 0034 72B6     		CPSID i
 451 0036 1870     		STRB R0, [r3]
 452              	@ 0 "" 2
 453              		.code	16
 454              	.L19:
 317:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->OutDataPtr = (uint8_t*)BufferPtr; /* Set a pointer to the ou
 455              		.loc 1 317 0 is_stmt 1
 456 0038 FB68     		ldr	r3, [r7, #12]
 457 003a BA68     		ldr	r2, [r7, #8]
 458 003c 1A61     		str	r2, [r3, #16]
 318:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq = Size; /* Set the counter of characters to be
 459              		.loc 1 318 0
 460 003e FB68     		ldr	r3, [r7, #12]
 461 0040 BA1D     		add	r2, r7, #6
 462 0042 1288     		ldrh	r2, [r2]
 463 0044 9A82     		strh	r2, [r3, #20]
 319:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum = 0x00U; /* Clear the counter of sent charact
 464              		.loc 1 319 0
 465 0046 FB68     		ldr	r3, [r7, #12]
 466 0048 0022     		mov	r2, #0
 467 004a DA81     		strh	r2, [r3, #14]
 320:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_SENT); /* Clear data bl
 468              		.loc 1 320 0
 469 004c FB68     		ldr	r3, [r7, #12]
 470 004e 9B7D     		ldrb	r3, [r3, #22]
 471 0050 0122     		mov	r2, #1
 472 0052 9343     		bic	r3, r2
 473 0054 DAB2     		uxtb	r2, r3
 474 0056 FB68     		ldr	r3, [r7, #12]
 475 0058 9A75     		strb	r2, [r3, #22]
 321:../Generated_Code/SS1.c ****   SPI_PDD_EnableInterruptMask(SPI1_BASE_PTR, SPI_PDD_TX_BUFFER_EMPTY); /* Enable Tx buffer empty in
 476              		.loc 1 321 0
 477 005a 0F4B     		ldr	r3, .L21+8
 478 005c 0E4A     		ldr	r2, .L21+8
 479 005e 1278     		ldrb	r2, [r2]
 480 0060 D2B2     		uxtb	r2, r2
 481 0062 2021     		mov	r1, #32
 482 0064 0A43     		orr	r2, r1
 483 0066 D2B2     		uxtb	r2, r2
 484 0068 1A70     		strb	r2, [r3]
 322:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 323:../Generated_Code/SS1.c ****   ExitCritical();
 485              		.loc 1 323 0
 486 006a 094B     		ldr	r3, .L21
 487 006c 1B78     		ldrb	r3, [r3]
 488 006e DBB2     		uxtb	r3, r3
 489 0070 013B     		sub	r3, r3, #1
 490 0072 DBB2     		uxtb	r3, r3
 491 0074 064A     		ldr	r2, .L21
 492 0076 191C     		add	r1, r3, #0
 493 0078 1170     		strb	r1, [r2]
 494 007a 002B     		cmp	r3, #0
 495 007c 03D1     		bne	.L20
 496              		.loc 1 323 0 is_stmt 0
 497 007e 054B     		ldr	r3, .L21+4
 498              	@ 323 "../Generated_Code/SS1.c" 1
 499 0080 1878     		ldrb r0, [r3]
 500 0082 80F31088 		msr PRIMASK,r0;
 501              		
 502              	@ 0 "" 2
 503              		.code	16
 504              	.L20:
 324:../Generated_Code/SS1.c ****   return ERR_OK;                       /* OK */
 505              		.loc 1 324 0 is_stmt 1
 506 0086 0023     		mov	r3, #0
 507              	.L18:
 325:../Generated_Code/SS1.c **** }
 508              		.loc 1 325 0
 509 0088 181C     		mov	r0, r3
 510 008a BD46     		mov	sp, r7
 511 008c 04B0     		add	sp, sp, #16
 512              		@ sp needed for prologue
 513 008e 80BD     		pop	{r7, pc}
 514              	.L22:
 515              		.align	2
 516              	.L21:
 517 0090 00000000 		.word	SR_lock
 518 0094 00000000 		.word	SR_reg
 519 0098 00700740 		.word	1074229248
 520              		.cfi_endproc
 521              	.LFE3:
 523              		.section	.text.SS1_GetReceivedDataNum,"ax",%progbits
 524              		.align	2
 525              		.global	SS1_GetReceivedDataNum
 526              		.code	16
 527              		.thumb_func
 529              	SS1_GetReceivedDataNum:
 530              	.LFB4:
 326:../Generated_Code/SS1.c **** 
 327:../Generated_Code/SS1.c **** /*
 328:../Generated_Code/SS1.c **** ** ===================================================================
 329:../Generated_Code/SS1.c **** **     Method      :  SS1_GetReceivedDataNum (component SPISlave_LDD)
 330:../Generated_Code/SS1.c **** */
 331:../Generated_Code/SS1.c **** /*!
 332:../Generated_Code/SS1.c **** **     @brief
 333:../Generated_Code/SS1.c **** **         Returns the number of received characters in the receive
 334:../Generated_Code/SS1.c **** **         buffer. This method is available only if the ReceiveBlock
 335:../Generated_Code/SS1.c **** **         method is enabled.
 336:../Generated_Code/SS1.c **** **     @param
 337:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 338:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 339:../Generated_Code/SS1.c **** **     @return
 340:../Generated_Code/SS1.c **** **                         - The number of characters in the input
 341:../Generated_Code/SS1.c **** **                           buffer.
 342:../Generated_Code/SS1.c **** */
 343:../Generated_Code/SS1.c **** /* ===================================================================*/
 344:../Generated_Code/SS1.c **** uint16_t SS1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr)
 345:../Generated_Code/SS1.c **** {
 531              		.loc 1 345 0
 532              		.cfi_startproc
 533 0000 80B5     		push	{r7, lr}
 534              	.LCFI12:
 535              		.cfi_def_cfa_offset 8
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 14, -4
 538 0002 82B0     		sub	sp, sp, #8
 539              	.LCFI13:
 540              		.cfi_def_cfa_offset 16
 541 0004 00AF     		add	r7, sp, #0
 542              	.LCFI14:
 543              		.cfi_def_cfa_register 7
 544 0006 7860     		str	r0, [r7, #4]
 346:../Generated_Code/SS1.c ****   return (((SS1_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum); /* Return the number of received ch
 545              		.loc 1 346 0
 546 0008 7B68     		ldr	r3, [r7, #4]
 547 000a 9B88     		ldrh	r3, [r3, #4]
 347:../Generated_Code/SS1.c **** }
 548              		.loc 1 347 0
 549 000c 181C     		mov	r0, r3
 550 000e BD46     		mov	sp, r7
 551 0010 02B0     		add	sp, sp, #8
 552              		@ sp needed for prologue
 553 0012 80BD     		pop	{r7, pc}
 554              		.cfi_endproc
 555              	.LFE4:
 557              		.section	.text.SS1_GetSentDataNum,"ax",%progbits
 558              		.align	2
 559              		.global	SS1_GetSentDataNum
 560              		.code	16
 561              		.thumb_func
 563              	SS1_GetSentDataNum:
 564              	.LFB5:
 348:../Generated_Code/SS1.c **** 
 349:../Generated_Code/SS1.c **** /*
 350:../Generated_Code/SS1.c **** ** ===================================================================
 351:../Generated_Code/SS1.c **** **     Method      :  SS1_GetSentDataNum (component SPISlave_LDD)
 352:../Generated_Code/SS1.c **** */
 353:../Generated_Code/SS1.c **** /*!
 354:../Generated_Code/SS1.c **** **     @brief
 355:../Generated_Code/SS1.c **** **         Returns the number of sent characters. This method is
 356:../Generated_Code/SS1.c **** **         available only if method SendBlock is enabled.
 357:../Generated_Code/SS1.c **** **     @param
 358:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 359:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 360:../Generated_Code/SS1.c **** **     @return
 361:../Generated_Code/SS1.c **** **                         - The number of characters in the output
 362:../Generated_Code/SS1.c **** **                           buffer.
 363:../Generated_Code/SS1.c **** */
 364:../Generated_Code/SS1.c **** /* ===================================================================*/
 365:../Generated_Code/SS1.c **** uint16_t SS1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr)
 366:../Generated_Code/SS1.c **** {
 565              		.loc 1 366 0
 566              		.cfi_startproc
 567 0000 80B5     		push	{r7, lr}
 568              	.LCFI15:
 569              		.cfi_def_cfa_offset 8
 570              		.cfi_offset 7, -8
 571              		.cfi_offset 14, -4
 572 0002 82B0     		sub	sp, sp, #8
 573              	.LCFI16:
 574              		.cfi_def_cfa_offset 16
 575 0004 00AF     		add	r7, sp, #0
 576              	.LCFI17:
 577              		.cfi_def_cfa_register 7
 578 0006 7860     		str	r0, [r7, #4]
 367:../Generated_Code/SS1.c ****   return (((SS1_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum); /* Return the number of sent charac
 579              		.loc 1 367 0
 580 0008 7B68     		ldr	r3, [r7, #4]
 581 000a DB89     		ldrh	r3, [r3, #14]
 368:../Generated_Code/SS1.c **** }
 582              		.loc 1 368 0
 583 000c 181C     		mov	r0, r3
 584 000e BD46     		mov	sp, r7
 585 0010 02B0     		add	sp, sp, #8
 586              		@ sp needed for prologue
 587 0012 80BD     		pop	{r7, pc}
 588              		.cfi_endproc
 589              	.LFE5:
 591              		.section	.text.SS1_GetBlockSentStatus,"ax",%progbits
 592              		.align	2
 593              		.global	SS1_GetBlockSentStatus
 594              		.code	16
 595              		.thumb_func
 597              	SS1_GetBlockSentStatus:
 598              	.LFB6:
 369:../Generated_Code/SS1.c **** 
 370:../Generated_Code/SS1.c **** /*
 371:../Generated_Code/SS1.c **** ** ===================================================================
 372:../Generated_Code/SS1.c **** **     Method      :  SS1_GetBlockSentStatus (component SPISlave_LDD)
 373:../Generated_Code/SS1.c **** */
 374:../Generated_Code/SS1.c **** /*!
 375:../Generated_Code/SS1.c **** **     @brief
 376:../Generated_Code/SS1.c **** **         This method returns whether the transmitter is finished
 377:../Generated_Code/SS1.c **** **         transmitting all data block. The status flag is accumulated,
 378:../Generated_Code/SS1.c **** **         after calling this method the status is returned and cleared
 379:../Generated_Code/SS1.c **** **         (set to "false" state). This method is available only if
 380:../Generated_Code/SS1.c **** **         method SendBlock is enabled.
 381:../Generated_Code/SS1.c **** **     @param
 382:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 383:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 384:../Generated_Code/SS1.c **** **     @return
 385:../Generated_Code/SS1.c **** **                         - Return value:
 386:../Generated_Code/SS1.c **** **                           true - Data block is completely transmitted
 387:../Generated_Code/SS1.c **** **                           false - Data block isn't completely
 388:../Generated_Code/SS1.c **** **                           transmitted.
 389:../Generated_Code/SS1.c **** */
 390:../Generated_Code/SS1.c **** /* ===================================================================*/
 391:../Generated_Code/SS1.c **** bool SS1_GetBlockSentStatus(LDD_TDeviceData *DeviceDataPtr)
 392:../Generated_Code/SS1.c **** {
 599              		.loc 1 392 0
 600              		.cfi_startproc
 601 0000 80B5     		push	{r7, lr}
 602              	.LCFI18:
 603              		.cfi_def_cfa_offset 8
 604              		.cfi_offset 7, -8
 605              		.cfi_offset 14, -4
 606 0002 84B0     		sub	sp, sp, #16
 607              	.LCFI19:
 608              		.cfi_def_cfa_offset 24
 609 0004 00AF     		add	r7, sp, #0
 610              	.LCFI20:
 611              		.cfi_def_cfa_register 7
 612 0006 7860     		str	r0, [r7, #4]
 393:../Generated_Code/SS1.c ****   uint8_t Status;                      /* Temporary variable for flag saving */
 394:../Generated_Code/SS1.c **** 
 395:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 396:../Generated_Code/SS1.c ****   EnterCritical();
 613              		.loc 1 396 0
 614 0008 194B     		ldr	r3, .L31
 615 000a 1B78     		ldrb	r3, [r3]
 616 000c DBB2     		uxtb	r3, r3
 617 000e 0133     		add	r3, r3, #1
 618 0010 DBB2     		uxtb	r3, r3
 619 0012 174A     		ldr	r2, .L31
 620 0014 191C     		add	r1, r3, #0
 621 0016 1170     		strb	r1, [r2]
 622 0018 012B     		cmp	r3, #1
 623 001a 04D1     		bne	.L28
 624              		.loc 1 396 0 is_stmt 0
 625 001c 154B     		ldr	r3, .L31+4
 626              	@ 396 "../Generated_Code/SS1.c" 1
 627 001e EFF31080 		MRS R0, PRIMASK
 628 0022 72B6     		CPSID i
 629 0024 1870     		STRB R0, [r3]
 630              	@ 0 "" 2
 631              		.code	16
 632              	.L28:
 397:../Generated_Code/SS1.c ****   Status = ((SS1_TDeviceDataPtr)DeviceDataPtr)->SerFlag; /* Save flag for return */
 633              		.loc 1 397 0 is_stmt 1
 634 0026 3B1C     		mov	r3, r7
 635 0028 0F33     		add	r3, r3, #15
 636 002a 7A68     		ldr	r2, [r7, #4]
 637 002c 927D     		ldrb	r2, [r2, #22]
 638 002e 1A70     		strb	r2, [r3]
 398:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_SENT); /* Clear data bl
 639              		.loc 1 398 0
 640 0030 7B68     		ldr	r3, [r7, #4]
 641 0032 9B7D     		ldrb	r3, [r3, #22]
 642 0034 0122     		mov	r2, #1
 643 0036 9343     		bic	r3, r2
 644 0038 DAB2     		uxtb	r2, r3
 645 003a 7B68     		ldr	r3, [r7, #4]
 646 003c 9A75     		strb	r2, [r3, #22]
 399:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 400:../Generated_Code/SS1.c ****   ExitCritical();
 647              		.loc 1 400 0
 648 003e 0C4B     		ldr	r3, .L31
 649 0040 1B78     		ldrb	r3, [r3]
 650 0042 DBB2     		uxtb	r3, r3
 651 0044 013B     		sub	r3, r3, #1
 652 0046 DBB2     		uxtb	r3, r3
 653 0048 094A     		ldr	r2, .L31
 654 004a 191C     		add	r1, r3, #0
 655 004c 1170     		strb	r1, [r2]
 656 004e 002B     		cmp	r3, #0
 657 0050 03D1     		bne	.L29
 658              		.loc 1 400 0 is_stmt 0
 659 0052 084B     		ldr	r3, .L31+4
 660              	@ 400 "../Generated_Code/SS1.c" 1
 661 0054 1878     		ldrb r0, [r3]
 662 0056 80F31088 		msr PRIMASK,r0;
 663              		
 664              	@ 0 "" 2
 665              		.code	16
 666              	.L29:
 401:../Generated_Code/SS1.c ****   return (bool)(((Status & BLOCK_SENT) != 0U)? TRUE : FALSE); /* Return saved status */
 667              		.loc 1 401 0 is_stmt 1
 668 005a 3B1C     		mov	r3, r7
 669 005c 0F33     		add	r3, r3, #15
 670 005e 1A78     		ldrb	r2, [r3]
 671 0060 0123     		mov	r3, #1
 672 0062 1340     		and	r3, r2
 673 0064 DBB2     		uxtb	r3, r3
 402:../Generated_Code/SS1.c **** }
 674              		.loc 1 402 0
 675 0066 181C     		mov	r0, r3
 676 0068 BD46     		mov	sp, r7
 677 006a 04B0     		add	sp, sp, #16
 678              		@ sp needed for prologue
 679 006c 80BD     		pop	{r7, pc}
 680              	.L32:
 681 006e C046     		.align	2
 682              	.L31:
 683 0070 00000000 		.word	SR_lock
 684 0074 00000000 		.word	SR_reg
 685              		.cfi_endproc
 686              	.LFE6:
 688              		.section	.text.SS1_GetBlockReceivedStatus,"ax",%progbits
 689              		.align	2
 690              		.global	SS1_GetBlockReceivedStatus
 691              		.code	16
 692              		.thumb_func
 694              	SS1_GetBlockReceivedStatus:
 695              	.LFB7:
 403:../Generated_Code/SS1.c **** 
 404:../Generated_Code/SS1.c **** /*
 405:../Generated_Code/SS1.c **** ** ===================================================================
 406:../Generated_Code/SS1.c **** **     Method      :  SS1_GetBlockReceivedStatus (component SPISlave_LDD)
 407:../Generated_Code/SS1.c **** */
 408:../Generated_Code/SS1.c **** /*!
 409:../Generated_Code/SS1.c **** **     @brief
 410:../Generated_Code/SS1.c **** **         This method returns whether the receiver is finished
 411:../Generated_Code/SS1.c **** **         reception of all data block. The status flag is accumulated,
 412:../Generated_Code/SS1.c **** **         after calling this method the status is returned and cleared
 413:../Generated_Code/SS1.c **** **         (set to "false" state). This method is available only if
 414:../Generated_Code/SS1.c **** **         method ReceiveBlock is enabled.
 415:../Generated_Code/SS1.c **** **     @param
 416:../Generated_Code/SS1.c **** **         DeviceDataPtr   - Device data structure
 417:../Generated_Code/SS1.c **** **                           pointer returned by <Init> method.
 418:../Generated_Code/SS1.c **** **     @return
 419:../Generated_Code/SS1.c **** **                         - Return value:
 420:../Generated_Code/SS1.c **** **                           true - Data block is completely received
 421:../Generated_Code/SS1.c **** **                           false - Data block isn't completely received
 422:../Generated_Code/SS1.c **** */
 423:../Generated_Code/SS1.c **** /* ===================================================================*/
 424:../Generated_Code/SS1.c **** bool SS1_GetBlockReceivedStatus(LDD_TDeviceData *DeviceDataPtr)
 425:../Generated_Code/SS1.c **** {
 696              		.loc 1 425 0
 697              		.cfi_startproc
 698 0000 80B5     		push	{r7, lr}
 699              	.LCFI21:
 700              		.cfi_def_cfa_offset 8
 701              		.cfi_offset 7, -8
 702              		.cfi_offset 14, -4
 703 0002 84B0     		sub	sp, sp, #16
 704              	.LCFI22:
 705              		.cfi_def_cfa_offset 24
 706 0004 00AF     		add	r7, sp, #0
 707              	.LCFI23:
 708              		.cfi_def_cfa_register 7
 709 0006 7860     		str	r0, [r7, #4]
 426:../Generated_Code/SS1.c ****   uint8_t Status;                      /* Temporary variable for flag saving */
 427:../Generated_Code/SS1.c **** 
 428:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 429:../Generated_Code/SS1.c ****   EnterCritical();
 710              		.loc 1 429 0
 711 0008 1A4B     		ldr	r3, .L39
 712 000a 1B78     		ldrb	r3, [r3]
 713 000c DBB2     		uxtb	r3, r3
 714 000e 0133     		add	r3, r3, #1
 715 0010 DBB2     		uxtb	r3, r3
 716 0012 184A     		ldr	r2, .L39
 717 0014 191C     		add	r1, r3, #0
 718 0016 1170     		strb	r1, [r2]
 719 0018 012B     		cmp	r3, #1
 720 001a 04D1     		bne	.L34
 721              		.loc 1 429 0 is_stmt 0
 722 001c 164B     		ldr	r3, .L39+4
 723              	@ 429 "../Generated_Code/SS1.c" 1
 724 001e EFF31080 		MRS R0, PRIMASK
 725 0022 72B6     		CPSID i
 726 0024 1870     		STRB R0, [r3]
 727              	@ 0 "" 2
 728              		.code	16
 729              	.L34:
 430:../Generated_Code/SS1.c ****   Status = ((SS1_TDeviceDataPtr)DeviceDataPtr)->SerFlag; /* Save flag for return */
 730              		.loc 1 430 0 is_stmt 1
 731 0026 3B1C     		mov	r3, r7
 732 0028 0F33     		add	r3, r3, #15
 733 002a 7A68     		ldr	r2, [r7, #4]
 734 002c 927D     		ldrb	r2, [r2, #22]
 735 002e 1A70     		strb	r2, [r3]
 431:../Generated_Code/SS1.c ****   ((SS1_TDeviceDataPtr)DeviceDataPtr)->SerFlag &= (uint8_t)(~(uint8_t)BLOCK_RECEIVED); /* Clear dat
 736              		.loc 1 431 0
 737 0030 7B68     		ldr	r3, [r7, #4]
 738 0032 9B7D     		ldrb	r3, [r3, #22]
 739 0034 0222     		mov	r2, #2
 740 0036 9343     		bic	r3, r2
 741 0038 DAB2     		uxtb	r2, r3
 742 003a 7B68     		ldr	r3, [r7, #4]
 743 003c 9A75     		strb	r2, [r3, #22]
 432:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 433:../Generated_Code/SS1.c ****   ExitCritical();
 744              		.loc 1 433 0
 745 003e 0D4B     		ldr	r3, .L39
 746 0040 1B78     		ldrb	r3, [r3]
 747 0042 DBB2     		uxtb	r3, r3
 748 0044 013B     		sub	r3, r3, #1
 749 0046 DBB2     		uxtb	r3, r3
 750 0048 0A4A     		ldr	r2, .L39
 751 004a 191C     		add	r1, r3, #0
 752 004c 1170     		strb	r1, [r2]
 753 004e 002B     		cmp	r3, #0
 754 0050 03D1     		bne	.L35
 755              		.loc 1 433 0 is_stmt 0
 756 0052 094B     		ldr	r3, .L39+4
 757              	@ 433 "../Generated_Code/SS1.c" 1
 758 0054 1878     		ldrb r0, [r3]
 759 0056 80F31088 		msr PRIMASK,r0;
 760              		
 761              	@ 0 "" 2
 762              		.code	16
 763              	.L35:
 434:../Generated_Code/SS1.c ****   return (bool)(((Status & BLOCK_RECEIVED) != 0U)? TRUE : FALSE); /* Return saved status */
 764              		.loc 1 434 0 is_stmt 1
 765 005a 3B1C     		mov	r3, r7
 766 005c 0F33     		add	r3, r3, #15
 767 005e 1A78     		ldrb	r2, [r3]
 768 0060 0223     		mov	r3, #2
 769 0062 1340     		and	r3, r2
 770 0064 01D0     		beq	.L36
 771              		.loc 1 434 0 is_stmt 0
 772 0066 0123     		mov	r3, #1
 773 0068 00E0     		b	.L37
 774              	.L36:
 775              		.loc 1 434 0
 776 006a 0023     		mov	r3, #0
 777              	.L37:
 435:../Generated_Code/SS1.c **** }
 778              		.loc 1 435 0 is_stmt 1
 779 006c 181C     		mov	r0, r3
 780 006e BD46     		mov	sp, r7
 781 0070 04B0     		add	sp, sp, #16
 782              		@ sp needed for prologue
 783 0072 80BD     		pop	{r7, pc}
 784              	.L40:
 785              		.align	2
 786              	.L39:
 787 0074 00000000 		.word	SR_lock
 788 0078 00000000 		.word	SR_reg
 789              		.cfi_endproc
 790              	.LFE7:
 792              		.section	.text.SS1_Interrupt,"ax",%progbits
 793              		.align	2
 794              		.global	SS1_Interrupt
 795              		.code	16
 796              		.thumb_func
 798              	SS1_Interrupt:
 799              	.LFB8:
 436:../Generated_Code/SS1.c **** 
 437:../Generated_Code/SS1.c **** /*
 438:../Generated_Code/SS1.c **** ** ===================================================================
 439:../Generated_Code/SS1.c **** **     Method      :  SS1_Interrupt (component SPISlave_LDD)
 440:../Generated_Code/SS1.c **** **
 441:../Generated_Code/SS1.c **** **     Description :
 442:../Generated_Code/SS1.c **** **         The ISR function handling the device receive/transmit 
 443:../Generated_Code/SS1.c **** **         interrupt.
 444:../Generated_Code/SS1.c **** **         This method is internal. It is used by Processor Expert only.
 445:../Generated_Code/SS1.c **** ** ===================================================================
 446:../Generated_Code/SS1.c **** */
 447:../Generated_Code/SS1.c **** PE_ISR(SS1_Interrupt)
 448:../Generated_Code/SS1.c **** {
 800              		.loc 1 448 0
 801              		.cfi_startproc
 802 0000 80B5     		push	{r7, lr}
 803              	.LCFI24:
 804              		.cfi_def_cfa_offset 8
 805              		.cfi_offset 7, -8
 806              		.cfi_offset 14, -4
 807 0002 82B0     		sub	sp, sp, #8
 808              	.LCFI25:
 809              		.cfi_def_cfa_offset 16
 810 0004 00AF     		add	r7, sp, #0
 811              	.LCFI26:
 812              		.cfi_def_cfa_register 7
 449:../Generated_Code/SS1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 450:../Generated_Code/SS1.c ****   SS1_TDeviceDataPtr DeviceDataPrv = INT_SPI1__DEFAULT_RTOS_ISRPARAM;
 813              		.loc 1 450 0
 814 0006 3B4B     		ldr	r3, .L45
 815 0008 1B68     		ldr	r3, [r3]
 816 000a 7B60     		str	r3, [r7, #4]
 451:../Generated_Code/SS1.c ****   uint8_t StatReg = SPI_PDD_ReadStatusReg(SPI1_BASE_PTR); /* Read status register */
 817              		.loc 1 451 0
 818 000c 3A4A     		ldr	r2, .L45+4
 819 000e FB1C     		add	r3, r7, #3
 820 0010 D278     		ldrb	r2, [r2, #3]
 821 0012 1A70     		strb	r2, [r3]
 452:../Generated_Code/SS1.c **** 
 453:../Generated_Code/SS1.c ****   (void)DeviceDataPrv;                 /* Supress unused variable warning if needed */
 454:../Generated_Code/SS1.c ****   if ((StatReg & SPI_PDD_RX_BUFFER_FULL) != 0U) { /* Is any char in HW Rx buffer? */
 822              		.loc 1 454 0
 823 0014 FB1C     		add	r3, r7, #3
 824 0016 1B78     		ldrb	r3, [r3]
 825 0018 5BB2     		sxtb	r3, r3
 826 001a 002B     		cmp	r3, #0
 827 001c 2FDA     		bge	.L42
 455:../Generated_Code/SS1.c ****     if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 828              		.loc 1 455 0
 829 001e 7B68     		ldr	r3, [r7, #4]
 830 0020 9B89     		ldrh	r3, [r3, #12]
 831 0022 002B     		cmp	r3, #0
 832 0024 2BD0     		beq	.L42
 456:../Generated_Code/SS1.c ****       *(DeviceDataPrv->InpDataPtr++) = SPI_PDD_ReadData8bit(SPI1_BASE_PTR); /* Put a character to t
 833              		.loc 1 456 0
 834 0026 7B68     		ldr	r3, [r7, #4]
 835 0028 9B68     		ldr	r3, [r3, #8]
 836 002a 334A     		ldr	r2, .L45+4
 837 002c 5279     		ldrb	r2, [r2, #5]
 838 002e D2B2     		uxtb	r2, r2
 839 0030 1A70     		strb	r2, [r3]
 840 0032 5A1C     		add	r2, r3, #1
 841 0034 7B68     		ldr	r3, [r7, #4]
 842 0036 9A60     		str	r2, [r3, #8]
 457:../Generated_Code/SS1.c ****       DeviceDataPrv->InpRecvDataNum++; /* Increment received char. counter */
 843              		.loc 1 457 0
 844 0038 7B68     		ldr	r3, [r7, #4]
 845 003a 9B88     		ldrh	r3, [r3, #4]
 846 003c 0133     		add	r3, r3, #1
 847 003e 9AB2     		uxth	r2, r3
 848 0040 7B68     		ldr	r3, [r7, #4]
 849 0042 9A80     		strh	r2, [r3, #4]
 458:../Generated_Code/SS1.c ****       if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested numb
 850              		.loc 1 458 0
 851 0044 7B68     		ldr	r3, [r7, #4]
 852 0046 9A88     		ldrh	r2, [r3, #4]
 853 0048 7B68     		ldr	r3, [r7, #4]
 854 004a 9B89     		ldrh	r3, [r3, #12]
 855 004c 9A42     		cmp	r2, r3
 856 004e 16D1     		bne	.L42
 459:../Generated_Code/SS1.c ****         SPI_PDD_DisableInterruptMask(SPI1_BASE_PTR, SPI_PDD_RX_BUFFER_FULL_OR_FAULT); /* Disable Rx
 857              		.loc 1 459 0
 858 0050 294B     		ldr	r3, .L45+4
 859 0052 294A     		ldr	r2, .L45+4
 860 0054 1278     		ldrb	r2, [r2]
 861 0056 D1B2     		uxtb	r1, r2
 862 0058 7F22     		mov	r2, #127
 863 005a 0A40     		and	r2, r1
 864 005c D2B2     		uxtb	r2, r2
 865 005e 1A70     		strb	r2, [r3]
 460:../Generated_Code/SS1.c ****         DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters t
 866              		.loc 1 460 0
 867 0060 7B68     		ldr	r3, [r7, #4]
 868 0062 0022     		mov	r2, #0
 869 0064 9A81     		strh	r2, [r3, #12]
 461:../Generated_Code/SS1.c ****         DeviceDataPrv->SerFlag |= BLOCK_RECEIVED; /* Set data block received flag */
 870              		.loc 1 461 0
 871 0066 7B68     		ldr	r3, [r7, #4]
 872 0068 9B7D     		ldrb	r3, [r3, #22]
 873 006a 0222     		mov	r2, #2
 874 006c 1343     		orr	r3, r2
 875 006e DAB2     		uxtb	r2, r3
 876 0070 7B68     		ldr	r3, [r7, #4]
 877 0072 9A75     		strb	r2, [r3, #22]
 462:../Generated_Code/SS1.c ****         SS1_OnBlockReceived(DeviceDataPrv->UserData);
 878              		.loc 1 462 0
 879 0074 7B68     		ldr	r3, [r7, #4]
 880 0076 9B69     		ldr	r3, [r3, #24]
 881 0078 181C     		mov	r0, r3
 882 007a FFF7FEFF 		bl	SS1_OnBlockReceived
 883              	.L42:
 463:../Generated_Code/SS1.c ****       }
 464:../Generated_Code/SS1.c ****     }
 465:../Generated_Code/SS1.c ****   }
 466:../Generated_Code/SS1.c ****   if ((StatReg & SPI_PDD_TX_BUFFER_EMPTYG) != 0U) { /* Is HW Tx buffer empty? */
 884              		.loc 1 466 0
 885 007e FB1C     		add	r3, r7, #3
 886 0080 1A78     		ldrb	r2, [r3]
 887 0082 2023     		mov	r3, #32
 888 0084 1340     		and	r3, r2
 889 0086 31D0     		beq	.L41
 467:../Generated_Code/SS1.c ****     if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent charac
 890              		.loc 1 467 0
 891 0088 7B68     		ldr	r3, [r7, #4]
 892 008a DA89     		ldrh	r2, [r3, #14]
 893 008c 7B68     		ldr	r3, [r7, #4]
 894 008e 9B8A     		ldrh	r3, [r3, #20]
 895 0090 9A42     		cmp	r2, r3
 896 0092 23D2     		bcs	.L44
 468:../Generated_Code/SS1.c ****       SPI_PDD_WriteData8Bit(SPI1_BASE_PTR, (*((uint8_t *)DeviceDataPrv->OutDataPtr++))); /* Put a c
 897              		.loc 1 468 0
 898 0094 184A     		ldr	r2, .L45+4
 899 0096 7B68     		ldr	r3, [r7, #4]
 900 0098 1B69     		ldr	r3, [r3, #16]
 901 009a 1978     		ldrb	r1, [r3]
 902 009c 5171     		strb	r1, [r2, #5]
 903 009e 5A1C     		add	r2, r3, #1
 904 00a0 7B68     		ldr	r3, [r7, #4]
 905 00a2 1A61     		str	r2, [r3, #16]
 469:../Generated_Code/SS1.c ****       DeviceDataPrv->OutSentDataNum++; /* Increment the counter of sent characters. */
 906              		.loc 1 469 0
 907 00a4 7B68     		ldr	r3, [r7, #4]
 908 00a6 DB89     		ldrh	r3, [r3, #14]
 909 00a8 0133     		add	r3, r3, #1
 910 00aa 9AB2     		uxth	r2, r3
 911 00ac 7B68     		ldr	r3, [r7, #4]
 912 00ae DA81     		strh	r2, [r3, #14]
 470:../Generated_Code/SS1.c ****       if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 913              		.loc 1 470 0
 914 00b0 7B68     		ldr	r3, [r7, #4]
 915 00b2 DA89     		ldrh	r2, [r3, #14]
 916 00b4 7B68     		ldr	r3, [r7, #4]
 917 00b6 9B8A     		ldrh	r3, [r3, #20]
 918 00b8 9A42     		cmp	r2, r3
 919 00ba 17D1     		bne	.L41
 471:../Generated_Code/SS1.c ****         DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by Send
 920              		.loc 1 471 0
 921 00bc 7B68     		ldr	r3, [r7, #4]
 922 00be 0022     		mov	r2, #0
 923 00c0 9A82     		strh	r2, [r3, #20]
 472:../Generated_Code/SS1.c ****         DeviceDataPrv->SerFlag |= BLOCK_SENT; /* Set data block sent flag */
 924              		.loc 1 472 0
 925 00c2 7B68     		ldr	r3, [r7, #4]
 926 00c4 9B7D     		ldrb	r3, [r3, #22]
 927 00c6 0122     		mov	r2, #1
 928 00c8 1343     		orr	r3, r2
 929 00ca DAB2     		uxtb	r2, r3
 930 00cc 7B68     		ldr	r3, [r7, #4]
 931 00ce 9A75     		strb	r2, [r3, #22]
 473:../Generated_Code/SS1.c ****         SS1_OnBlockSent(DeviceDataPrv->UserData);
 932              		.loc 1 473 0
 933 00d0 7B68     		ldr	r3, [r7, #4]
 934 00d2 9B69     		ldr	r3, [r3, #24]
 935 00d4 181C     		mov	r0, r3
 936 00d6 FFF7FEFF 		bl	SS1_OnBlockSent
 937 00da 07E0     		b	.L41
 938              	.L44:
 474:../Generated_Code/SS1.c ****       }
 475:../Generated_Code/SS1.c ****     } else {
 476:../Generated_Code/SS1.c ****       SPI_PDD_DisableInterruptMask(SPI1_BASE_PTR, SPI_PDD_TX_BUFFER_EMPTY); /* Disable TX interrupt
 939              		.loc 1 476 0
 940 00dc 064B     		ldr	r3, .L45+4
 941 00de 064A     		ldr	r2, .L45+4
 942 00e0 1278     		ldrb	r2, [r2]
 943 00e2 D2B2     		uxtb	r2, r2
 944 00e4 2021     		mov	r1, #32
 945 00e6 8A43     		bic	r2, r1
 946 00e8 D2B2     		uxtb	r2, r2
 947 00ea 1A70     		strb	r2, [r3]
 948              	.L41:
 477:../Generated_Code/SS1.c ****     }
 478:../Generated_Code/SS1.c ****   }
 479:../Generated_Code/SS1.c **** }
 949              		.loc 1 479 0
 950 00ec BD46     		mov	sp, r7
 951 00ee 02B0     		add	sp, sp, #8
 952              		@ sp needed for prologue
 953 00f0 80BD     		pop	{r7, pc}
 954              	.L46:
 955 00f2 C046     		.align	2
 956              	.L45:
 957 00f4 00000000 		.word	INT_SPI1__DEFAULT_RTOS_ISRPARAM
 958 00f8 00700740 		.word	1074229248
 959              		.cfi_endproc
 960              	.LFE8:
 962              		.text
 963              	.Letext0:
 964              		.file 2 "E:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 965              		.file 3 "E:/Freescale/CW MCU v10.5/MCU/CodeWarrior_Examples/Processor_Expert/Kinetis/TWR-KL25Z48M/
 966              		.file 4 "E:/Freescale/CW MCU v10.5/MCU/CodeWarrior_Examples/Processor_Expert/Kinetis/TWR-KL25Z48M/
 967              		.file 5 "E:/Freescale/CW MCU v10.5/MCU/CodeWarrior_Examples/Processor_Expert/Kinetis/TWR-KL25Z48M/
 968              		.file 6 "E:/Freescale/CW MCU v10.5/MCU/CodeWarrior_Examples/Processor_Expert/Kinetis/TWR-KL25Z48M/
DEFINED SYMBOLS
                            *ABS*:00000000 SS1.c
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:24     .bss.INT_SPI1__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:27     .bss.INT_SPI1__DEFAULT_RTOS_ISRPARAM:00000000 INT_SPI1__DEFAULT_RTOS_ISRPARAM
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:30     .text.SS1_Init:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:35     .text.SS1_Init:00000000 SS1_Init
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:207    .text.SS1_Init:00000104 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:220    .text.SS1_Deinit:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:225    .text.SS1_Deinit:00000000 SS1_Deinit
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:266    .text.SS1_Deinit:0000002c $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:275    .text.SS1_ReceiveBlock:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:280    .text.SS1_ReceiveBlock:00000000 SS1_ReceiveBlock
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:395    .text.SS1_ReceiveBlock:00000098 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:402    .text.SS1_SendBlock:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:407    .text.SS1_SendBlock:00000000 SS1_SendBlock
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:517    .text.SS1_SendBlock:00000090 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:524    .text.SS1_GetReceivedDataNum:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:529    .text.SS1_GetReceivedDataNum:00000000 SS1_GetReceivedDataNum
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:558    .text.SS1_GetSentDataNum:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:563    .text.SS1_GetSentDataNum:00000000 SS1_GetSentDataNum
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:592    .text.SS1_GetBlockSentStatus:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:597    .text.SS1_GetBlockSentStatus:00000000 SS1_GetBlockSentStatus
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:683    .text.SS1_GetBlockSentStatus:00000070 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:689    .text.SS1_GetBlockReceivedStatus:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:694    .text.SS1_GetBlockReceivedStatus:00000000 SS1_GetBlockReceivedStatus
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:787    .text.SS1_GetBlockReceivedStatus:00000074 $d
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:793    .text.SS1_Interrupt:00000000 $t
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:798    .text.SS1_Interrupt:00000000 SS1_Interrupt
C:\Users\lab\AppData\Local\Temp\cczm8JEi.s:957    .text.SS1_Interrupt:000000f4 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
SR_lock
SR_reg
SS1_OnBlockReceived
SS1_OnBlockSent

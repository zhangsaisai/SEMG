   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"SM1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	28
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_SPI0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_SPI0__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.SM1_Init,"ax",%progbits
  30              		.align	2
  31              		.global	SM1_Init
  32              		.code	16
  33              		.thumb_func
  35              	SM1_Init:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/SM1.c"
   1:../Generated_Code/SM1.c **** /* ###################################################################
   2:../Generated_Code/SM1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/SM1.c **** **     Filename    : SM1.c
   4:../Generated_Code/SM1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/SM1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/SM1.c **** **     Component   : SPIMaster_LDD
   7:../Generated_Code/SM1.c **** **     Version     : Component 01.109, Driver 01.02, CPU db: 3.00.000
   8:../Generated_Code/SM1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/SM1.c **** **     Date/Time   : 2015-10-16, 11:12, # CodeGen: 7
  10:../Generated_Code/SM1.c **** **     Abstract    :
  11:../Generated_Code/SM1.c **** **         This component "SPIMaster_LDD" implements MASTER part of synchronous
  12:../Generated_Code/SM1.c **** **         serial master-slave communication.
  13:../Generated_Code/SM1.c **** **     Settings    :
  14:../Generated_Code/SM1.c **** **          Component name                                 : SM1
  15:../Generated_Code/SM1.c **** **          Device                                         : SPI0
  16:../Generated_Code/SM1.c **** **          Interrupt service/event                        : Enabled
  17:../Generated_Code/SM1.c **** **            Input interrupt                              : INT_SPI0
  18:../Generated_Code/SM1.c **** **            Input interrupt priority                     : minimal priority
  19:../Generated_Code/SM1.c **** **            Output interrupt                             : INT_SPI0
  20:../Generated_Code/SM1.c **** **            Output interrupt priority                    : minimal priority
  21:../Generated_Code/SM1.c **** **          Settings                                       : 
  22:../Generated_Code/SM1.c **** **            Input pin                                    : Enabled
  23:../Generated_Code/SM1.c **** **              Pin                                        : PTA16/SPI0_MOSI/SPI0_MISO
  24:../Generated_Code/SM1.c **** **              Pin signal                                 : 
  25:../Generated_Code/SM1.c **** **            Output pin                                   : Enabled
  26:../Generated_Code/SM1.c **** **              Pin                                        : PTA17/SPI0_MISO/SPI0_MOSI
  27:../Generated_Code/SM1.c **** **              Pin signal                                 : 
  28:../Generated_Code/SM1.c **** **            Clock pin                                    : 
  29:../Generated_Code/SM1.c **** **              Pin                                        : PTC5/LLWU_P9/SPI0_SCK/LPTMR0_ALT2/CMP0
  30:../Generated_Code/SM1.c **** **              Pin signal                                 : 
  31:../Generated_Code/SM1.c **** **            Chip select list                             : 1
  32:../Generated_Code/SM1.c **** **              Chip select 0                              : 
  33:../Generated_Code/SM1.c **** **                Pin                                      : PTC4/LLWU_P8/SPI0_PCS0/UART1_TX/TPM0_C
  34:../Generated_Code/SM1.c **** **                Pin signal                               : 
  35:../Generated_Code/SM1.c **** **                Active level                             : Low
  36:../Generated_Code/SM1.c **** **            Attribute set list                           : 1
  37:../Generated_Code/SM1.c **** **              Attribute set 0                            : 
  38:../Generated_Code/SM1.c **** **                Width                                    : 8 bits
  39:../Generated_Code/SM1.c **** **                MSB first                                : yes
  40:../Generated_Code/SM1.c **** **                Clock polarity                           : High
  41:../Generated_Code/SM1.c **** **                Clock phase                              : Change on leading edge
  42:../Generated_Code/SM1.c **** **                Parity                                   : None
  43:../Generated_Code/SM1.c **** **                Chip select toggling                     : no
  44:../Generated_Code/SM1.c **** **                Clock rate index                         : 0
  45:../Generated_Code/SM1.c **** **            Clock rate                                   : 8 ?s
  46:../Generated_Code/SM1.c **** **            HW input buffer size                         : 1
  47:../Generated_Code/SM1.c **** **            HW input watermark                           : 1
  48:../Generated_Code/SM1.c **** **            Receiver DMA                                 : Disabled
  49:../Generated_Code/SM1.c **** **            HW output buffer size                        : 1
  50:../Generated_Code/SM1.c **** **            HW output watermark                          : 1
  51:../Generated_Code/SM1.c **** **            Transmitter DMA                              : Disabled
  52:../Generated_Code/SM1.c **** **          Initialization                                 : 
  53:../Generated_Code/SM1.c **** **            Initial chip select                          : 0
  54:../Generated_Code/SM1.c **** **            Initial attribute set                        : 0
  55:../Generated_Code/SM1.c **** **            Enabled in init. code                        : yes
  56:../Generated_Code/SM1.c **** **            Auto initialization                          : yes
  57:../Generated_Code/SM1.c **** **            Event mask                                   : 
  58:../Generated_Code/SM1.c **** **              OnBlockSent                                : Enabled
  59:../Generated_Code/SM1.c **** **              OnBlockReceived                            : Enabled
  60:../Generated_Code/SM1.c **** **              OnError                                    : Disabled
  61:../Generated_Code/SM1.c **** **          CPU clock/configuration selection              : 
  62:../Generated_Code/SM1.c **** **            Clock configuration 0                        : This component enabled
  63:../Generated_Code/SM1.c **** **            Clock configuration 1                        : This component disabled
  64:../Generated_Code/SM1.c **** **            Clock configuration 2                        : This component disabled
  65:../Generated_Code/SM1.c **** **            Clock configuration 3                        : This component disabled
  66:../Generated_Code/SM1.c **** **            Clock configuration 4                        : This component disabled
  67:../Generated_Code/SM1.c **** **            Clock configuration 5                        : This component disabled
  68:../Generated_Code/SM1.c **** **            Clock configuration 6                        : This component disabled
  69:../Generated_Code/SM1.c **** **            Clock configuration 7                        : This component disabled
  70:../Generated_Code/SM1.c **** **     Contents    :
  71:../Generated_Code/SM1.c **** **         Init               - LDD_TDeviceData* SM1_Init(LDD_TUserData *UserDataPtr);
  72:../Generated_Code/SM1.c **** **         Deinit             - void SM1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  73:../Generated_Code/SM1.c **** **         SendBlock          - LDD_TError SM1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData.
  74:../Generated_Code/SM1.c **** **         ReceiveBlock       - LDD_TError SM1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TDa
  75:../Generated_Code/SM1.c **** **         GetSentDataNum     - uint16_t SM1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);
  76:../Generated_Code/SM1.c **** **         GetReceivedDataNum - uint16_t SM1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr);
  77:../Generated_Code/SM1.c **** **
  78:../Generated_Code/SM1.c **** **     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  79:../Generated_Code/SM1.c **** **     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
  80:../Generated_Code/SM1.c **** **     
  81:../Generated_Code/SM1.c **** **     http      : www.freescale.com
  82:../Generated_Code/SM1.c **** **     mail      : support@freescale.com
  83:../Generated_Code/SM1.c **** ** ###################################################################*/
  84:../Generated_Code/SM1.c **** /*!
  85:../Generated_Code/SM1.c **** ** @file SM1.c
  86:../Generated_Code/SM1.c **** ** @version 01.02
  87:../Generated_Code/SM1.c **** ** @brief
  88:../Generated_Code/SM1.c **** **         This component "SPIMaster_LDD" implements MASTER part of synchronous
  89:../Generated_Code/SM1.c **** **         serial master-slave communication.
  90:../Generated_Code/SM1.c **** */         
  91:../Generated_Code/SM1.c **** /*!
  92:../Generated_Code/SM1.c **** **  @addtogroup SM1_module SM1 module documentation
  93:../Generated_Code/SM1.c **** **  @{
  94:../Generated_Code/SM1.c **** */         
  95:../Generated_Code/SM1.c **** 
  96:../Generated_Code/SM1.c **** /* MODULE SM1. */
  97:../Generated_Code/SM1.c **** /*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */
  98:../Generated_Code/SM1.c **** 
  99:../Generated_Code/SM1.c **** #include "Events.h"
 100:../Generated_Code/SM1.c **** #include "SM1.h"
 101:../Generated_Code/SM1.c **** /* {Default RTOS Adapter} No RTOS includes */
 102:../Generated_Code/SM1.c **** 
 103:../Generated_Code/SM1.c **** #ifdef __cplusplus
 104:../Generated_Code/SM1.c **** extern "C" {
 105:../Generated_Code/SM1.c **** #endif 
 106:../Generated_Code/SM1.c **** 
 107:../Generated_Code/SM1.c **** #define AVAILABLE_EVENTS_MASK (LDD_SPIMASTER_ON_BLOCK_RECEIVED | LDD_SPIMASTER_ON_BLOCK_SENT)
 108:../Generated_Code/SM1.c **** 
 109:../Generated_Code/SM1.c **** /* These constants contain pins masks */
 110:../Generated_Code/SM1.c **** #define SM1_AVAILABLE_PIN_MASK (LDD_SPIMASTER_INPUT_PIN | LDD_SPIMASTER_OUTPUT_PIN | LDD_SPIMASTER_
 111:../Generated_Code/SM1.c **** 
 112:../Generated_Code/SM1.c **** typedef struct {
 113:../Generated_Code/SM1.c ****   LDD_SPIMASTER_TError ErrFlag;        /* Error flags */
 114:../Generated_Code/SM1.c ****   uint16_t InpRecvDataNum;             /* The counter of received characters */
 115:../Generated_Code/SM1.c ****   uint8_t *InpDataPtr;                 /* The buffer pointer for received characters */
 116:../Generated_Code/SM1.c ****   uint16_t InpDataNumReq;              /* The counter of characters to receive by ReceiveBlock() */
 117:../Generated_Code/SM1.c ****   uint16_t OutSentDataNum;             /* The counter of sent characters */
 118:../Generated_Code/SM1.c ****   uint8_t *OutDataPtr;                 /* The buffer pointer for data to be transmitted */
 119:../Generated_Code/SM1.c ****   uint16_t OutDataNumReq;              /* The counter of characters to be send by SendBlock() */
 120:../Generated_Code/SM1.c ****   LDD_TUserData *UserData;             /* User device data structure */
 121:../Generated_Code/SM1.c **** } SM1_TDeviceData;                     /* Device data structure type */
 122:../Generated_Code/SM1.c **** 
 123:../Generated_Code/SM1.c **** typedef SM1_TDeviceData* SM1_TDeviceDataPtr; /* Pointer to the device data structure */
 124:../Generated_Code/SM1.c **** 
 125:../Generated_Code/SM1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 126:../Generated_Code/SM1.c **** static SM1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 127:../Generated_Code/SM1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 128:../Generated_Code/SM1.c **** static SM1_TDeviceDataPtr INT_SPI0__DEFAULT_RTOS_ISRPARAM;
 129:../Generated_Code/SM1.c **** /* Internal method prototypes */
 130:../Generated_Code/SM1.c **** 
 131:../Generated_Code/SM1.c **** /*
 132:../Generated_Code/SM1.c **** ** ===================================================================
 133:../Generated_Code/SM1.c **** **     Method      :  SM1_Init (component SPIMaster_LDD)
 134:../Generated_Code/SM1.c **** */
 135:../Generated_Code/SM1.c **** /*!
 136:../Generated_Code/SM1.c **** **     @brief
 137:../Generated_Code/SM1.c **** **         Initializes the device. Allocates memory for the device data
 138:../Generated_Code/SM1.c **** **         structure, allocates interrupt vectors and sets interrupt
 139:../Generated_Code/SM1.c **** **         priority, sets pin routing, sets timing, etc.
 140:../Generated_Code/SM1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 141:../Generated_Code/SM1.c **** **         device is also enabled(see the description of the Enable()
 142:../Generated_Code/SM1.c **** **         method). In this case the Enable() method is not necessary
 143:../Generated_Code/SM1.c **** **         and needn't to be generated. 
 144:../Generated_Code/SM1.c **** **         This method can be called only once. Before the second call
 145:../Generated_Code/SM1.c **** **         of Init() the Deinit() must be called first.
 146:../Generated_Code/SM1.c **** **     @param
 147:../Generated_Code/SM1.c **** **         UserDataPtr     - Pointer to the user or
 148:../Generated_Code/SM1.c **** **                           RTOS specific data. This pointer will be
 149:../Generated_Code/SM1.c **** **                           passed as an event or callback parameter.
 150:../Generated_Code/SM1.c **** **     @return
 151:../Generated_Code/SM1.c **** **                         - Device data structure pointer.
 152:../Generated_Code/SM1.c **** */
 153:../Generated_Code/SM1.c **** /* ===================================================================*/
 154:../Generated_Code/SM1.c **** LDD_TDeviceData* SM1_Init(LDD_TUserData *UserDataPtr)
 155:../Generated_Code/SM1.c **** {
  38              		.loc 1 155 0
  39              		.cfi_startproc
  40 0000 80B5     		push	{r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 7, -8
  44              		.cfi_offset 14, -4
  45 0002 84B0     		sub	sp, sp, #16
  46              	.LCFI1:
  47              		.cfi_def_cfa_offset 24
  48 0004 00AF     		add	r7, sp, #0
  49              	.LCFI2:
  50              		.cfi_def_cfa_register 7
  51 0006 7860     		str	r0, [r7, #4]
 156:../Generated_Code/SM1.c ****   /* Allocate LDD device structure */
 157:../Generated_Code/SM1.c ****   SM1_TDeviceDataPtr DeviceDataPrv;
 158:../Generated_Code/SM1.c **** 
 159:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 160:../Generated_Code/SM1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  52              		.loc 1 160 0
  53 0008 3B4B     		ldr	r3, .L3
  54 000a FB60     		str	r3, [r7, #12]
 161:../Generated_Code/SM1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  55              		.loc 1 161 0
  56 000c FB68     		ldr	r3, [r7, #12]
  57 000e 7A68     		ldr	r2, [r7, #4]
  58 0010 9A61     		str	r2, [r3, #24]
 162:../Generated_Code/SM1.c ****   /* Interrupt vector(s) allocation */
 163:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 164:../Generated_Code/SM1.c ****   INT_SPI0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  59              		.loc 1 164 0
  60 0012 3A4B     		ldr	r3, .L3+4
  61 0014 FA68     		ldr	r2, [r7, #12]
  62 0016 1A60     		str	r2, [r3]
 165:../Generated_Code/SM1.c ****   DeviceDataPrv->ErrFlag = 0x00U;      /* Clear error flags */
  63              		.loc 1 165 0
  64 0018 FB68     		ldr	r3, [r7, #12]
  65 001a 0022     		mov	r2, #0
  66 001c 1A60     		str	r2, [r3]
 166:../Generated_Code/SM1.c ****   /* Clear the receive counters and pointer */
 167:../Generated_Code/SM1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  67              		.loc 1 167 0
  68 001e FB68     		ldr	r3, [r7, #12]
  69 0020 0022     		mov	r2, #0
  70 0022 9A80     		strh	r2, [r3, #4]
 168:../Generated_Code/SM1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  71              		.loc 1 168 0
  72 0024 FB68     		ldr	r3, [r7, #12]
  73 0026 0022     		mov	r2, #0
  74 0028 9A81     		strh	r2, [r3, #12]
 169:../Generated_Code/SM1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  75              		.loc 1 169 0
  76 002a FB68     		ldr	r3, [r7, #12]
  77 002c 0022     		mov	r2, #0
  78 002e 9A60     		str	r2, [r3, #8]
 170:../Generated_Code/SM1.c ****   /* Clear the transmit counters and pointer */
 171:../Generated_Code/SM1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  79              		.loc 1 171 0
  80 0030 FB68     		ldr	r3, [r7, #12]
  81 0032 0022     		mov	r2, #0
  82 0034 DA81     		strh	r2, [r3, #14]
 172:../Generated_Code/SM1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  83              		.loc 1 172 0
  84 0036 FB68     		ldr	r3, [r7, #12]
  85 0038 0022     		mov	r2, #0
  86 003a 9A82     		strh	r2, [r3, #20]
 173:../Generated_Code/SM1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  87              		.loc 1 173 0
  88 003c FB68     		ldr	r3, [r7, #12]
  89 003e 0022     		mov	r2, #0
  90 0040 1A61     		str	r2, [r3, #16]
 174:../Generated_Code/SM1.c ****   /* SIM_SCGC4: SPI0=1 */
 175:../Generated_Code/SM1.c ****   SIM_SCGC4 |= SIM_SCGC4_SPI0_MASK;                                   
  91              		.loc 1 175 0
  92 0042 2F4A     		ldr	r2, .L3+8
  93 0044 2E49     		ldr	r1, .L3+8
  94 0046 2F4B     		ldr	r3, .L3+12
  95 0048 CB58     		ldr	r3, [r1, r3]
  96 004a 8021     		mov	r1, #128
  97 004c C903     		lsl	r1, r1, #15
  98 004e 1943     		orr	r1, r3
  99 0050 2C4B     		ldr	r3, .L3+12
 100 0052 D150     		str	r1, [r2, r3]
 176:../Generated_Code/SM1.c ****   /* Interrupt vector(s) priority setting */
 177:../Generated_Code/SM1.c ****   /* NVIC_IPR2: PRI_10=0xC0 */
 178:../Generated_Code/SM1.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 101              		.loc 1 178 0
 102 0054 2C4A     		ldr	r2, .L3+16
 103 0056 2C49     		ldr	r1, .L3+16
 104 0058 C223     		mov	r3, #194
 105 005a 9B00     		lsl	r3, r3, #2
 106 005c C958     		ldr	r1, [r1, r3]
 107 005e 2B4B     		ldr	r3, .L3+20
 108 0060 0B40     		and	r3, r1
 109 0062 C021     		mov	r1, #192
 110 0064 0904     		lsl	r1, r1, #16
 111 0066 1943     		orr	r1, r3
 112 0068 C223     		mov	r3, #194
 113 006a 9B00     		lsl	r3, r3, #2
 114 006c D150     		str	r1, [r2, r3]
 179:../Generated_Code/SM1.c ****                NVIC_IP_PRI_10(0x3F)
 180:../Generated_Code/SM1.c ****               )) | (uint32_t)(
 181:../Generated_Code/SM1.c ****                NVIC_IP_PRI_10(0xC0)
 182:../Generated_Code/SM1.c ****               ));                                  
 183:../Generated_Code/SM1.c ****   /* NVIC_ISER: SETENA|=0x0400 */
 184:../Generated_Code/SM1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0400);                                   
 115              		.loc 1 184 0
 116 006e 264B     		ldr	r3, .L3+16
 117 0070 254A     		ldr	r2, .L3+16
 118 0072 1268     		ldr	r2, [r2]
 119 0074 8021     		mov	r1, #128
 120 0076 C900     		lsl	r1, r1, #3
 121 0078 0A43     		orr	r2, r1
 122 007a 1A60     		str	r2, [r3]
 185:../Generated_Code/SM1.c ****   /* PORTA_PCR16: ISF=0,MUX=5 */
 186:../Generated_Code/SM1.c ****   PORTA_PCR16 = (uint32_t)((PORTA_PCR16 & (uint32_t)~(uint32_t)(
 123              		.loc 1 186 0
 124 007c 244B     		ldr	r3, .L3+24
 125 007e 244A     		ldr	r2, .L3+24
 126 0080 116C     		ldr	r1, [r2, #64]
 127 0082 244A     		ldr	r2, .L3+28
 128 0084 0A40     		and	r2, r1
 129 0086 A021     		mov	r1, #160
 130 0088 C900     		lsl	r1, r1, #3
 131 008a 0A43     		orr	r2, r1
 132 008c 1A64     		str	r2, [r3, #64]
 187:../Generated_Code/SM1.c ****                  PORT_PCR_ISF_MASK |
 188:../Generated_Code/SM1.c ****                  PORT_PCR_MUX(0x02)
 189:../Generated_Code/SM1.c ****                 )) | (uint32_t)(
 190:../Generated_Code/SM1.c ****                  PORT_PCR_MUX(0x05)
 191:../Generated_Code/SM1.c ****                 ));                                  
 192:../Generated_Code/SM1.c ****   /* PORTA_PCR17: ISF=0,MUX=5 */
 193:../Generated_Code/SM1.c ****   PORTA_PCR17 = (uint32_t)((PORTA_PCR17 & (uint32_t)~(uint32_t)(
 133              		.loc 1 193 0
 134 008e 204B     		ldr	r3, .L3+24
 135 0090 1F4A     		ldr	r2, .L3+24
 136 0092 516C     		ldr	r1, [r2, #68]
 137 0094 1F4A     		ldr	r2, .L3+28
 138 0096 0A40     		and	r2, r1
 139 0098 A021     		mov	r1, #160
 140 009a C900     		lsl	r1, r1, #3
 141 009c 0A43     		orr	r2, r1
 142 009e 5A64     		str	r2, [r3, #68]
 194:../Generated_Code/SM1.c ****                  PORT_PCR_ISF_MASK |
 195:../Generated_Code/SM1.c ****                  PORT_PCR_MUX(0x02)
 196:../Generated_Code/SM1.c ****                 )) | (uint32_t)(
 197:../Generated_Code/SM1.c ****                  PORT_PCR_MUX(0x05)
 198:../Generated_Code/SM1.c ****                 ));                                  
 199:../Generated_Code/SM1.c ****   /* PORTC_PCR5: ISF=0,MUX=2 */
 200:../Generated_Code/SM1.c ****   PORTC_PCR5 = (uint32_t)((PORTC_PCR5 & (uint32_t)~(uint32_t)(
 143              		.loc 1 200 0
 144 00a0 1D4B     		ldr	r3, .L3+32
 145 00a2 1D4A     		ldr	r2, .L3+32
 146 00a4 5169     		ldr	r1, [r2, #20]
 147 00a6 1B4A     		ldr	r2, .L3+28
 148 00a8 0A40     		and	r2, r1
 149 00aa 8021     		mov	r1, #128
 150 00ac 8900     		lsl	r1, r1, #2
 151 00ae 0A43     		orr	r2, r1
 152 00b0 5A61     		str	r2, [r3, #20]
 201:../Generated_Code/SM1.c ****                 PORT_PCR_ISF_MASK |
 202:../Generated_Code/SM1.c ****                 PORT_PCR_MUX(0x05)
 203:../Generated_Code/SM1.c ****                )) | (uint32_t)(
 204:../Generated_Code/SM1.c ****                 PORT_PCR_MUX(0x02)
 205:../Generated_Code/SM1.c ****                ));                                  
 206:../Generated_Code/SM1.c ****   /* PORTC_PCR4: ISF=0,MUX=2 */
 207:../Generated_Code/SM1.c ****   PORTC_PCR4 = (uint32_t)((PORTC_PCR4 & (uint32_t)~(uint32_t)(
 153              		.loc 1 207 0
 154 00b2 194B     		ldr	r3, .L3+32
 155 00b4 184A     		ldr	r2, .L3+32
 156 00b6 1169     		ldr	r1, [r2, #16]
 157 00b8 164A     		ldr	r2, .L3+28
 158 00ba 0A40     		and	r2, r1
 159 00bc 8021     		mov	r1, #128
 160 00be 8900     		lsl	r1, r1, #2
 161 00c0 0A43     		orr	r2, r1
 162 00c2 1A61     		str	r2, [r3, #16]
 208:../Generated_Code/SM1.c ****                 PORT_PCR_ISF_MASK |
 209:../Generated_Code/SM1.c ****                 PORT_PCR_MUX(0x05)
 210:../Generated_Code/SM1.c ****                )) | (uint32_t)(
 211:../Generated_Code/SM1.c ****                 PORT_PCR_MUX(0x02)
 212:../Generated_Code/SM1.c ****                ));                                  
 213:../Generated_Code/SM1.c ****   /* SPI0_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=1,CPOL=1,CPHA=1,SSOE=1,LSBFE=0 */
 214:../Generated_Code/SM1.c ****   SPI0_C1 = SPI_C1_MSTR_MASK |
 163              		.loc 1 214 0
 164 00c4 154B     		ldr	r3, .L3+36
 165 00c6 1E22     		mov	r2, #30
 166 00c8 1A70     		strb	r2, [r3]
 215:../Generated_Code/SM1.c ****             SPI_C1_CPOL_MASK |
 216:../Generated_Code/SM1.c ****             SPI_C1_CPHA_MASK |
 217:../Generated_Code/SM1.c ****             SPI_C1_SSOE_MASK;          /* Set configuration register */
 218:../Generated_Code/SM1.c ****   /* SPI0_C2: SPMIE=0,??=0,TXDMAE=0,MODFEN=1,BIDIROE=0,RXDMAE=0,SPISWAI=0,SPC0=0 */
 219:../Generated_Code/SM1.c ****   SPI0_C2 = SPI_C2_MODFEN_MASK;        /* Set configuration register */
 167              		.loc 1 219 0
 168 00ca 144B     		ldr	r3, .L3+36
 169 00cc 1022     		mov	r2, #16
 170 00ce 5A70     		strb	r2, [r3, #1]
 220:../Generated_Code/SM1.c ****   /* SPI0_BR: ??=0,SPPR=2,SPR=5 */
 221:../Generated_Code/SM1.c ****   SPI0_BR = (SPI_BR_SPPR(0x02) | SPI_BR_SPR(0x05)); /* Set baud rate register */
 171              		.loc 1 221 0
 172 00d0 124B     		ldr	r3, .L3+36
 173 00d2 2522     		mov	r2, #37
 174 00d4 9A70     		strb	r2, [r3, #2]
 222:../Generated_Code/SM1.c ****   /* SPI0_C1: SPE=1 */
 223:../Generated_Code/SM1.c ****   SPI0_C1 |= SPI_C1_SPE_MASK;          /* Enable SPI module */
 175              		.loc 1 223 0
 176 00d6 114B     		ldr	r3, .L3+36
 177 00d8 104A     		ldr	r2, .L3+36
 178 00da 1278     		ldrb	r2, [r2]
 179 00dc D2B2     		uxtb	r2, r2
 180 00de 4021     		mov	r1, #64
 181 00e0 0A43     		orr	r2, r1
 182 00e2 D2B2     		uxtb	r2, r2
 183 00e4 1A70     		strb	r2, [r3]
 224:../Generated_Code/SM1.c ****   /* Registration of the device structure */
 225:../Generated_Code/SM1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SM1_ID,DeviceDataPrv);
 184              		.loc 1 225 0
 185 00e6 0E4B     		ldr	r3, .L3+40
 186 00e8 FA68     		ldr	r2, [r7, #12]
 187 00ea 1A61     		str	r2, [r3, #16]
 226:../Generated_Code/SM1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 188              		.loc 1 226 0
 189 00ec FB68     		ldr	r3, [r7, #12]
 227:../Generated_Code/SM1.c **** }
 190              		.loc 1 227 0
 191 00ee 181C     		mov	r0, r3
 192 00f0 BD46     		mov	sp, r7
 193 00f2 04B0     		add	sp, sp, #16
 194              		@ sp needed for prologue
 195 00f4 80BD     		pop	{r7, pc}
 196              	.L4:
 197 00f6 C046     		.align	2
 198              	.L3:
 199 00f8 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 200 00fc 00000000 		.word	INT_SPI0__DEFAULT_RTOS_ISRPARAM
 201 0100 00700440 		.word	1074032640
 202 0104 34100000 		.word	4148
 203 0108 00E100E0 		.word	-536813312
 204 010c FFFF00FF 		.word	-16711681
 205 0110 00900440 		.word	1074040832
 206 0114 FFF8FFFE 		.word	-16779009
 207 0118 00B00440 		.word	1074049024
 208 011c 00600740 		.word	1074225152
 209 0120 00000000 		.word	PE_LDD_DeviceDataList
 210              		.cfi_endproc
 211              	.LFE0:
 213              		.section	.text.SM1_Deinit,"ax",%progbits
 214              		.align	2
 215              		.global	SM1_Deinit
 216              		.code	16
 217              		.thumb_func
 219              	SM1_Deinit:
 220              	.LFB1:
 228:../Generated_Code/SM1.c **** 
 229:../Generated_Code/SM1.c **** /*
 230:../Generated_Code/SM1.c **** ** ===================================================================
 231:../Generated_Code/SM1.c **** **     Method      :  SM1_Deinit (component SPIMaster_LDD)
 232:../Generated_Code/SM1.c **** */
 233:../Generated_Code/SM1.c **** /*!
 234:../Generated_Code/SM1.c **** **     @brief
 235:../Generated_Code/SM1.c **** **         This method deinitializes the device. It switches off the
 236:../Generated_Code/SM1.c **** **         device, frees the device data structure memory, interrupts
 237:../Generated_Code/SM1.c **** **         vectors, etc.
 238:../Generated_Code/SM1.c **** **     @param
 239:../Generated_Code/SM1.c **** **         DeviceDataPtr   - Device data structure
 240:../Generated_Code/SM1.c **** **                           pointer returned by <Init> method.
 241:../Generated_Code/SM1.c **** */
 242:../Generated_Code/SM1.c **** /* ===================================================================*/
 243:../Generated_Code/SM1.c **** void SM1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 244:../Generated_Code/SM1.c **** {
 221              		.loc 1 244 0
 222              		.cfi_startproc
 223 0000 80B5     		push	{r7, lr}
 224              	.LCFI3:
 225              		.cfi_def_cfa_offset 8
 226              		.cfi_offset 7, -8
 227              		.cfi_offset 14, -4
 228 0002 82B0     		sub	sp, sp, #8
 229              	.LCFI4:
 230              		.cfi_def_cfa_offset 16
 231 0004 00AF     		add	r7, sp, #0
 232              	.LCFI5:
 233              		.cfi_def_cfa_register 7
 234 0006 7860     		str	r0, [r7, #4]
 245:../Generated_Code/SM1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 246:../Generated_Code/SM1.c ****   /* SPI0_C1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=1,SSOE=0,LSBFE=0 */
 247:../Generated_Code/SM1.c ****   SPI0_C1 = SPI_C1_CPHA_MASK;          /* Disable device */
 235              		.loc 1 247 0
 236 0008 084B     		ldr	r3, .L6
 237 000a 0422     		mov	r2, #4
 238 000c 1A70     		strb	r2, [r3]
 248:../Generated_Code/SM1.c ****   /* Restoring the interrupt vector */
 249:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 250:../Generated_Code/SM1.c ****   /* Unregistration of the device structure */
 251:../Generated_Code/SM1.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_SM1_ID);
 239              		.loc 1 251 0
 240 000e 084B     		ldr	r3, .L6+4
 241 0010 0022     		mov	r2, #0
 242 0012 1A61     		str	r2, [r3, #16]
 252:../Generated_Code/SM1.c ****   /* Deallocation of the device structure */
 253:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 254:../Generated_Code/SM1.c ****   /* SIM_SCGC4: SPI0=0 */
 255:../Generated_Code/SM1.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_SPI0_MASK);                                   
 243              		.loc 1 255 0
 244 0014 074A     		ldr	r2, .L6+8
 245 0016 0749     		ldr	r1, .L6+8
 246 0018 074B     		ldr	r3, .L6+12
 247 001a C958     		ldr	r1, [r1, r3]
 248 001c 074B     		ldr	r3, .L6+16
 249 001e 1940     		and	r1, r3
 250 0020 054B     		ldr	r3, .L6+12
 251 0022 D150     		str	r1, [r2, r3]
 256:../Generated_Code/SM1.c **** }
 252              		.loc 1 256 0
 253 0024 BD46     		mov	sp, r7
 254 0026 02B0     		add	sp, sp, #8
 255              		@ sp needed for prologue
 256 0028 80BD     		pop	{r7, pc}
 257              	.L7:
 258 002a C046     		.align	2
 259              	.L6:
 260 002c 00600740 		.word	1074225152
 261 0030 00000000 		.word	PE_LDD_DeviceDataList
 262 0034 00700440 		.word	1074032640
 263 0038 34100000 		.word	4148
 264 003c FFFFBFFF 		.word	-4194305
 265              		.cfi_endproc
 266              	.LFE1:
 268              		.section	.text.SM1_ReceiveBlock,"ax",%progbits
 269              		.align	2
 270              		.global	SM1_ReceiveBlock
 271              		.code	16
 272              		.thumb_func
 274              	SM1_ReceiveBlock:
 275              	.LFB2:
 257:../Generated_Code/SM1.c **** 
 258:../Generated_Code/SM1.c **** /*
 259:../Generated_Code/SM1.c **** ** ===================================================================
 260:../Generated_Code/SM1.c **** **     Method      :  SM1_ReceiveBlock (component SPIMaster_LDD)
 261:../Generated_Code/SM1.c **** */
 262:../Generated_Code/SM1.c **** /*!
 263:../Generated_Code/SM1.c **** **     @brief
 264:../Generated_Code/SM1.c **** **         This method specifies the number of data to receive. The
 265:../Generated_Code/SM1.c **** **         method returns ERR_BUSY until the specified number of
 266:../Generated_Code/SM1.c **** **         characters is received. The method <CancelBlockReception>
 267:../Generated_Code/SM1.c **** **         can be used to cancel a running receive operation.
 268:../Generated_Code/SM1.c **** **     @param
 269:../Generated_Code/SM1.c **** **         DeviceDataPtr   - Device data structure
 270:../Generated_Code/SM1.c **** **                           pointer returned by <Init> method.
 271:../Generated_Code/SM1.c **** **     @param
 272:../Generated_Code/SM1.c **** **         BufferPtr       - Pointer to A buffer where
 273:../Generated_Code/SM1.c **** **                           received characters will be stored.
 274:../Generated_Code/SM1.c **** **     @param
 275:../Generated_Code/SM1.c **** **         Size            - Size of the block
 276:../Generated_Code/SM1.c **** **     @return
 277:../Generated_Code/SM1.c **** **                         - Error code, possible codes:
 278:../Generated_Code/SM1.c **** **                           ERR_OK - OK
 279:../Generated_Code/SM1.c **** **                           ERR_SPEED - This device does not work in
 280:../Generated_Code/SM1.c **** **                           the active clock configuration
 281:../Generated_Code/SM1.c **** **                           ERR_DISABLED - Component is disabled
 282:../Generated_Code/SM1.c **** **                           ERR_BUSY - The previous receive request is
 283:../Generated_Code/SM1.c **** **                           pending
 284:../Generated_Code/SM1.c **** */
 285:../Generated_Code/SM1.c **** /* ===================================================================*/
 286:../Generated_Code/SM1.c **** LDD_TError SM1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 287:../Generated_Code/SM1.c **** {
 276              		.loc 1 287 0
 277              		.cfi_startproc
 278 0000 80B5     		push	{r7, lr}
 279              	.LCFI6:
 280              		.cfi_def_cfa_offset 8
 281              		.cfi_offset 7, -8
 282              		.cfi_offset 14, -4
 283 0002 84B0     		sub	sp, sp, #16
 284              	.LCFI7:
 285              		.cfi_def_cfa_offset 24
 286 0004 00AF     		add	r7, sp, #0
 287              	.LCFI8:
 288              		.cfi_def_cfa_register 7
 289 0006 F860     		str	r0, [r7, #12]
 290 0008 B960     		str	r1, [r7, #8]
 291 000a BB1D     		add	r3, r7, #6
 292 000c 1A80     		strh	r2, [r3]
 288:../Generated_Code/SM1.c ****   if (((SM1_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq != 0x00U) { /* Is the previous receive ope
 293              		.loc 1 288 0
 294 000e FB68     		ldr	r3, [r7, #12]
 295 0010 9B89     		ldrh	r3, [r3, #12]
 296 0012 002B     		cmp	r3, #0
 297 0014 01D0     		beq	.L9
 289:../Generated_Code/SM1.c ****     return ERR_BUSY;                   /* If yes then error */
 298              		.loc 1 289 0
 299 0016 0823     		mov	r3, #8
 300 0018 39E0     		b	.L10
 301              	.L9:
 290:../Generated_Code/SM1.c ****   }
 291:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 292:../Generated_Code/SM1.c ****   EnterCritical();
 302              		.loc 1 292 0
 303 001a 1F4B     		ldr	r3, .L14
 304 001c 1B78     		ldrb	r3, [r3]
 305 001e DBB2     		uxtb	r3, r3
 306 0020 0133     		add	r3, r3, #1
 307 0022 DBB2     		uxtb	r3, r3
 308 0024 1C4A     		ldr	r2, .L14
 309 0026 191C     		add	r1, r3, #0
 310 0028 1170     		strb	r1, [r2]
 311 002a 012B     		cmp	r3, #1
 312 002c 04D1     		bne	.L11
 313              		.loc 1 292 0 is_stmt 0
 314 002e 1B4B     		ldr	r3, .L14+4
 315              	@ 292 "../Generated_Code/SM1.c" 1
 316 0030 EFF31080 		MRS R0, PRIMASK
 317 0034 72B6     		CPSID i
 318 0036 1870     		STRB R0, [r3]
 319              	@ 0 "" 2
 320              		.code	16
 321              	.L11:
 293:../Generated_Code/SM1.c ****   ((SM1_TDeviceDataPtr)DeviceDataPtr)->InpDataPtr = (uint8_t*)BufferPtr; /* Store a pointer to the 
 322              		.loc 1 293 0 is_stmt 1
 323 0038 FB68     		ldr	r3, [r7, #12]
 324 003a BA68     		ldr	r2, [r7, #8]
 325 003c 9A60     		str	r2, [r3, #8]
 294:../Generated_Code/SM1.c ****   ((SM1_TDeviceDataPtr)DeviceDataPtr)->InpDataNumReq = Size; /* Store a number of characters to be 
 326              		.loc 1 294 0
 327 003e FB68     		ldr	r3, [r7, #12]
 328 0040 BA1D     		add	r2, r7, #6
 329 0042 1288     		ldrh	r2, [r2]
 330 0044 9A81     		strh	r2, [r3, #12]
 295:../Generated_Code/SM1.c ****   ((SM1_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum = 0x00U; /* Set number of received characters
 331              		.loc 1 295 0
 332 0046 FB68     		ldr	r3, [r7, #12]
 333 0048 0022     		mov	r2, #0
 334 004a 9A80     		strh	r2, [r3, #4]
 296:../Generated_Code/SM1.c ****   if ((SPI_PDD_ReadStatusReg(SPI0_BASE_PTR) & SPI_PDD_RX_BUFFER_FULL) != 0U) {
 335              		.loc 1 296 0
 336 004c 144B     		ldr	r3, .L14+8
 337 004e DB78     		ldrb	r3, [r3, #3]
 338 0050 DBB2     		uxtb	r3, r3
 339 0052 DBB2     		uxtb	r3, r3
 340 0054 5BB2     		sxtb	r3, r3
 341 0056 002B     		cmp	r3, #0
 342 0058 01DA     		bge	.L12
 297:../Generated_Code/SM1.c ****     (void)SPI_PDD_ReadData8bit(SPI0_BASE_PTR); /* Dummy read of the data register */
 343              		.loc 1 297 0
 344 005a 114B     		ldr	r3, .L14+8
 345 005c 5B79     		ldrb	r3, [r3, #5]
 346              	.L12:
 298:../Generated_Code/SM1.c ****   }
 299:../Generated_Code/SM1.c ****   SPI_PDD_EnableInterruptMask(SPI0_BASE_PTR, SPI_PDD_RX_BUFFER_FULL_OR_FAULT); /* Enable Rx buffer 
 347              		.loc 1 299 0
 348 005e 104B     		ldr	r3, .L14+8
 349 0060 0F4A     		ldr	r2, .L14+8
 350 0062 1278     		ldrb	r2, [r2]
 351 0064 D2B2     		uxtb	r2, r2
 352 0066 8021     		mov	r1, #128
 353 0068 4942     		neg	r1, r1
 354 006a 0A43     		orr	r2, r1
 355 006c D2B2     		uxtb	r2, r2
 356 006e 1A70     		strb	r2, [r3]
 300:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 301:../Generated_Code/SM1.c ****   ExitCritical();
 357              		.loc 1 301 0
 358 0070 094B     		ldr	r3, .L14
 359 0072 1B78     		ldrb	r3, [r3]
 360 0074 DBB2     		uxtb	r3, r3
 361 0076 013B     		sub	r3, r3, #1
 362 0078 DBB2     		uxtb	r3, r3
 363 007a 074A     		ldr	r2, .L14
 364 007c 191C     		add	r1, r3, #0
 365 007e 1170     		strb	r1, [r2]
 366 0080 002B     		cmp	r3, #0
 367 0082 03D1     		bne	.L13
 368              		.loc 1 301 0 is_stmt 0
 369 0084 054B     		ldr	r3, .L14+4
 370              	@ 301 "../Generated_Code/SM1.c" 1
 371 0086 1878     		ldrb r0, [r3]
 372 0088 80F31088 		msr PRIMASK,r0;
 373              		
 374              	@ 0 "" 2
 375              		.code	16
 376              	.L13:
 302:../Generated_Code/SM1.c ****   return ERR_OK;                       /* OK */
 377              		.loc 1 302 0 is_stmt 1
 378 008c 0023     		mov	r3, #0
 379              	.L10:
 303:../Generated_Code/SM1.c **** }
 380              		.loc 1 303 0
 381 008e 181C     		mov	r0, r3
 382 0090 BD46     		mov	sp, r7
 383 0092 04B0     		add	sp, sp, #16
 384              		@ sp needed for prologue
 385 0094 80BD     		pop	{r7, pc}
 386              	.L15:
 387 0096 C046     		.align	2
 388              	.L14:
 389 0098 00000000 		.word	SR_lock
 390 009c 00000000 		.word	SR_reg
 391 00a0 00600740 		.word	1074225152
 392              		.cfi_endproc
 393              	.LFE2:
 395              		.section	.text.SM1_SendBlock,"ax",%progbits
 396              		.align	2
 397              		.global	SM1_SendBlock
 398              		.code	16
 399              		.thumb_func
 401              	SM1_SendBlock:
 402              	.LFB3:
 304:../Generated_Code/SM1.c **** 
 305:../Generated_Code/SM1.c **** /*
 306:../Generated_Code/SM1.c **** ** ===================================================================
 307:../Generated_Code/SM1.c **** **     Method      :  SM1_SendBlock (component SPIMaster_LDD)
 308:../Generated_Code/SM1.c **** */
 309:../Generated_Code/SM1.c **** /*!
 310:../Generated_Code/SM1.c **** **     @brief
 311:../Generated_Code/SM1.c **** **         This method sends a block of characters. The method returns
 312:../Generated_Code/SM1.c **** **         ERR_BUSY when the previous block transmission is not
 313:../Generated_Code/SM1.c **** **         completed. The method <CancelBlockTransmission> can be used
 314:../Generated_Code/SM1.c **** **         to cancel a transmit operation.
 315:../Generated_Code/SM1.c **** **     @param
 316:../Generated_Code/SM1.c **** **         DeviceDataPtr   - Device data structure
 317:../Generated_Code/SM1.c **** **                           pointer returned by <Init> method.
 318:../Generated_Code/SM1.c **** **     @param
 319:../Generated_Code/SM1.c **** **         BufferPtr       - Pointer to the block of data
 320:../Generated_Code/SM1.c **** **                           to send.
 321:../Generated_Code/SM1.c **** **     @param
 322:../Generated_Code/SM1.c **** **         Size            - Number of characters in the buffer.
 323:../Generated_Code/SM1.c **** **     @return
 324:../Generated_Code/SM1.c **** **                         - Error code, possible codes:
 325:../Generated_Code/SM1.c **** **                           ERR_OK - OK
 326:../Generated_Code/SM1.c **** **                           ERR_SPEED - This device does not work in
 327:../Generated_Code/SM1.c **** **                           the active clock configuration
 328:../Generated_Code/SM1.c **** **                           ERR_DISABLED - Component is disabled
 329:../Generated_Code/SM1.c **** **                           ERR_BUSY - The previous transmit request is
 330:../Generated_Code/SM1.c **** **                           pending
 331:../Generated_Code/SM1.c **** */
 332:../Generated_Code/SM1.c **** /* ===================================================================*/
 333:../Generated_Code/SM1.c **** LDD_TError SM1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 334:../Generated_Code/SM1.c **** {
 403              		.loc 1 334 0
 404              		.cfi_startproc
 405 0000 80B5     		push	{r7, lr}
 406              	.LCFI9:
 407              		.cfi_def_cfa_offset 8
 408              		.cfi_offset 7, -8
 409              		.cfi_offset 14, -4
 410 0002 84B0     		sub	sp, sp, #16
 411              	.LCFI10:
 412              		.cfi_def_cfa_offset 24
 413 0004 00AF     		add	r7, sp, #0
 414              	.LCFI11:
 415              		.cfi_def_cfa_register 7
 416 0006 F860     		str	r0, [r7, #12]
 417 0008 B960     		str	r1, [r7, #8]
 418 000a BB1D     		add	r3, r7, #6
 419 000c 1A80     		strh	r2, [r3]
 335:../Generated_Code/SM1.c ****   if (((SM1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq != 0x00U) { /* Is the previous transmit op
 420              		.loc 1 335 0
 421 000e FB68     		ldr	r3, [r7, #12]
 422 0010 9B8A     		ldrh	r3, [r3, #20]
 423 0012 002B     		cmp	r3, #0
 424 0014 01D0     		beq	.L17
 336:../Generated_Code/SM1.c ****     return ERR_BUSY;                   /* If yes then error */
 425              		.loc 1 336 0
 426 0016 0823     		mov	r3, #8
 427 0018 2FE0     		b	.L18
 428              	.L17:
 337:../Generated_Code/SM1.c ****   }
 338:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 339:../Generated_Code/SM1.c ****   EnterCritical();
 429              		.loc 1 339 0
 430 001a 1A4B     		ldr	r3, .L21
 431 001c 1B78     		ldrb	r3, [r3]
 432 001e DBB2     		uxtb	r3, r3
 433 0020 0133     		add	r3, r3, #1
 434 0022 DBB2     		uxtb	r3, r3
 435 0024 174A     		ldr	r2, .L21
 436 0026 191C     		add	r1, r3, #0
 437 0028 1170     		strb	r1, [r2]
 438 002a 012B     		cmp	r3, #1
 439 002c 04D1     		bne	.L19
 440              		.loc 1 339 0 is_stmt 0
 441 002e 164B     		ldr	r3, .L21+4
 442              	@ 339 "../Generated_Code/SM1.c" 1
 443 0030 EFF31080 		MRS R0, PRIMASK
 444 0034 72B6     		CPSID i
 445 0036 1870     		STRB R0, [r3]
 446              	@ 0 "" 2
 447              		.code	16
 448              	.L19:
 340:../Generated_Code/SM1.c ****   ((SM1_TDeviceDataPtr)DeviceDataPtr)->OutDataPtr = (uint8_t*)BufferPtr; /* Set a pointer to the ou
 449              		.loc 1 340 0 is_stmt 1
 450 0038 FB68     		ldr	r3, [r7, #12]
 451 003a BA68     		ldr	r2, [r7, #8]
 452 003c 1A61     		str	r2, [r3, #16]
 341:../Generated_Code/SM1.c ****   ((SM1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq = Size; /* Set the counter of characters to be
 453              		.loc 1 341 0
 454 003e FB68     		ldr	r3, [r7, #12]
 455 0040 BA1D     		add	r2, r7, #6
 456 0042 1288     		ldrh	r2, [r2]
 457 0044 9A82     		strh	r2, [r3, #20]
 342:../Generated_Code/SM1.c ****   ((SM1_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum = 0x00U; /* Clear the counter of sent charact
 458              		.loc 1 342 0
 459 0046 FB68     		ldr	r3, [r7, #12]
 460 0048 0022     		mov	r2, #0
 461 004a DA81     		strh	r2, [r3, #14]
 343:../Generated_Code/SM1.c ****   SPI_PDD_EnableInterruptMask(SPI0_BASE_PTR, SPI_PDD_TX_BUFFER_EMPTY); /* Enable Tx buffer empty in
 462              		.loc 1 343 0
 463 004c 0F4B     		ldr	r3, .L21+8
 464 004e 0F4A     		ldr	r2, .L21+8
 465 0050 1278     		ldrb	r2, [r2]
 466 0052 D2B2     		uxtb	r2, r2
 467 0054 2021     		mov	r1, #32
 468 0056 0A43     		orr	r2, r1
 469 0058 D2B2     		uxtb	r2, r2
 470 005a 1A70     		strb	r2, [r3]
 344:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 345:../Generated_Code/SM1.c ****   ExitCritical();
 471              		.loc 1 345 0
 472 005c 094B     		ldr	r3, .L21
 473 005e 1B78     		ldrb	r3, [r3]
 474 0060 DBB2     		uxtb	r3, r3
 475 0062 013B     		sub	r3, r3, #1
 476 0064 DBB2     		uxtb	r3, r3
 477 0066 074A     		ldr	r2, .L21
 478 0068 191C     		add	r1, r3, #0
 479 006a 1170     		strb	r1, [r2]
 480 006c 002B     		cmp	r3, #0
 481 006e 03D1     		bne	.L20
 482              		.loc 1 345 0 is_stmt 0
 483 0070 054B     		ldr	r3, .L21+4
 484              	@ 345 "../Generated_Code/SM1.c" 1
 485 0072 1878     		ldrb r0, [r3]
 486 0074 80F31088 		msr PRIMASK,r0;
 487              		
 488              	@ 0 "" 2
 489              		.code	16
 490              	.L20:
 346:../Generated_Code/SM1.c ****   return ERR_OK;                       /* OK */
 491              		.loc 1 346 0 is_stmt 1
 492 0078 0023     		mov	r3, #0
 493              	.L18:
 347:../Generated_Code/SM1.c **** }
 494              		.loc 1 347 0
 495 007a 181C     		mov	r0, r3
 496 007c BD46     		mov	sp, r7
 497 007e 04B0     		add	sp, sp, #16
 498              		@ sp needed for prologue
 499 0080 80BD     		pop	{r7, pc}
 500              	.L22:
 501 0082 C046     		.align	2
 502              	.L21:
 503 0084 00000000 		.word	SR_lock
 504 0088 00000000 		.word	SR_reg
 505 008c 00600740 		.word	1074225152
 506              		.cfi_endproc
 507              	.LFE3:
 509              		.section	.text.SM1_GetReceivedDataNum,"ax",%progbits
 510              		.align	2
 511              		.global	SM1_GetReceivedDataNum
 512              		.code	16
 513              		.thumb_func
 515              	SM1_GetReceivedDataNum:
 516              	.LFB4:
 348:../Generated_Code/SM1.c **** 
 349:../Generated_Code/SM1.c **** /*
 350:../Generated_Code/SM1.c **** ** ===================================================================
 351:../Generated_Code/SM1.c **** **     Method      :  SM1_GetReceivedDataNum (component SPIMaster_LDD)
 352:../Generated_Code/SM1.c **** */
 353:../Generated_Code/SM1.c **** /*!
 354:../Generated_Code/SM1.c **** **     @brief
 355:../Generated_Code/SM1.c **** **         Returns the number of received characters in the receive
 356:../Generated_Code/SM1.c **** **         buffer. This method is available only if the ReceiveBlock
 357:../Generated_Code/SM1.c **** **         method is enabled.
 358:../Generated_Code/SM1.c **** **     @param
 359:../Generated_Code/SM1.c **** **         DeviceDataPtr   - Device data structure
 360:../Generated_Code/SM1.c **** **                           pointer returned by <Init> method.
 361:../Generated_Code/SM1.c **** **     @return
 362:../Generated_Code/SM1.c **** **                         - The number of characters in the input
 363:../Generated_Code/SM1.c **** **                           buffer.
 364:../Generated_Code/SM1.c **** */
 365:../Generated_Code/SM1.c **** /* ===================================================================*/
 366:../Generated_Code/SM1.c **** uint16_t SM1_GetReceivedDataNum(LDD_TDeviceData *DeviceDataPtr)
 367:../Generated_Code/SM1.c **** {
 517              		.loc 1 367 0
 518              		.cfi_startproc
 519 0000 80B5     		push	{r7, lr}
 520              	.LCFI12:
 521              		.cfi_def_cfa_offset 8
 522              		.cfi_offset 7, -8
 523              		.cfi_offset 14, -4
 524 0002 82B0     		sub	sp, sp, #8
 525              	.LCFI13:
 526              		.cfi_def_cfa_offset 16
 527 0004 00AF     		add	r7, sp, #0
 528              	.LCFI14:
 529              		.cfi_def_cfa_register 7
 530 0006 7860     		str	r0, [r7, #4]
 368:../Generated_Code/SM1.c ****   return (((SM1_TDeviceDataPtr)DeviceDataPtr)->InpRecvDataNum); /* Return the number of received ch
 531              		.loc 1 368 0
 532 0008 7B68     		ldr	r3, [r7, #4]
 533 000a 9B88     		ldrh	r3, [r3, #4]
 369:../Generated_Code/SM1.c **** }
 534              		.loc 1 369 0
 535 000c 181C     		mov	r0, r3
 536 000e BD46     		mov	sp, r7
 537 0010 02B0     		add	sp, sp, #8
 538              		@ sp needed for prologue
 539 0012 80BD     		pop	{r7, pc}
 540              		.cfi_endproc
 541              	.LFE4:
 543              		.section	.text.SM1_GetSentDataNum,"ax",%progbits
 544              		.align	2
 545              		.global	SM1_GetSentDataNum
 546              		.code	16
 547              		.thumb_func
 549              	SM1_GetSentDataNum:
 550              	.LFB5:
 370:../Generated_Code/SM1.c **** 
 371:../Generated_Code/SM1.c **** /*
 372:../Generated_Code/SM1.c **** ** ===================================================================
 373:../Generated_Code/SM1.c **** **     Method      :  SM1_GetSentDataNum (component SPIMaster_LDD)
 374:../Generated_Code/SM1.c **** */
 375:../Generated_Code/SM1.c **** /*!
 376:../Generated_Code/SM1.c **** **     @brief
 377:../Generated_Code/SM1.c **** **         Returns the number of sent characters. This method is
 378:../Generated_Code/SM1.c **** **         available only if method SendBlock is enabled.
 379:../Generated_Code/SM1.c **** **     @param
 380:../Generated_Code/SM1.c **** **         DeviceDataPtr   - Device data structure
 381:../Generated_Code/SM1.c **** **                           pointer returned by <Init> method.
 382:../Generated_Code/SM1.c **** **     @return
 383:../Generated_Code/SM1.c **** **                         - The number of characters in the output
 384:../Generated_Code/SM1.c **** **                           buffer.
 385:../Generated_Code/SM1.c **** */
 386:../Generated_Code/SM1.c **** /* ===================================================================*/
 387:../Generated_Code/SM1.c **** uint16_t SM1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr)
 388:../Generated_Code/SM1.c **** {
 551              		.loc 1 388 0
 552              		.cfi_startproc
 553 0000 80B5     		push	{r7, lr}
 554              	.LCFI15:
 555              		.cfi_def_cfa_offset 8
 556              		.cfi_offset 7, -8
 557              		.cfi_offset 14, -4
 558 0002 82B0     		sub	sp, sp, #8
 559              	.LCFI16:
 560              		.cfi_def_cfa_offset 16
 561 0004 00AF     		add	r7, sp, #0
 562              	.LCFI17:
 563              		.cfi_def_cfa_register 7
 564 0006 7860     		str	r0, [r7, #4]
 389:../Generated_Code/SM1.c ****   return (((SM1_TDeviceDataPtr)DeviceDataPtr)->OutSentDataNum); /* Return the number of sent charac
 565              		.loc 1 389 0
 566 0008 7B68     		ldr	r3, [r7, #4]
 567 000a DB89     		ldrh	r3, [r3, #14]
 390:../Generated_Code/SM1.c **** }
 568              		.loc 1 390 0
 569 000c 181C     		mov	r0, r3
 570 000e BD46     		mov	sp, r7
 571 0010 02B0     		add	sp, sp, #8
 572              		@ sp needed for prologue
 573 0012 80BD     		pop	{r7, pc}
 574              		.cfi_endproc
 575              	.LFE5:
 577              		.section	.text.SM1_Interrupt,"ax",%progbits
 578              		.align	2
 579              		.global	SM1_Interrupt
 580              		.code	16
 581              		.thumb_func
 583              	SM1_Interrupt:
 584              	.LFB6:
 391:../Generated_Code/SM1.c **** 
 392:../Generated_Code/SM1.c **** /*
 393:../Generated_Code/SM1.c **** ** ===================================================================
 394:../Generated_Code/SM1.c **** **     Method      :  SM1_Interrupt (component SPIMaster_LDD)
 395:../Generated_Code/SM1.c **** **
 396:../Generated_Code/SM1.c **** **     Description :
 397:../Generated_Code/SM1.c **** **         The ISR function handling the device receive/transmit 
 398:../Generated_Code/SM1.c **** **         interrupt.
 399:../Generated_Code/SM1.c **** **         This method is internal. It is used by Processor Expert only.
 400:../Generated_Code/SM1.c **** ** ===================================================================
 401:../Generated_Code/SM1.c **** */
 402:../Generated_Code/SM1.c **** PE_ISR(SM1_Interrupt)
 403:../Generated_Code/SM1.c **** {
 585              		.loc 1 403 0
 586              		.cfi_startproc
 587 0000 80B5     		push	{r7, lr}
 588              	.LCFI18:
 589              		.cfi_def_cfa_offset 8
 590              		.cfi_offset 7, -8
 591              		.cfi_offset 14, -4
 592 0002 82B0     		sub	sp, sp, #8
 593              	.LCFI19:
 594              		.cfi_def_cfa_offset 16
 595 0004 00AF     		add	r7, sp, #0
 596              	.LCFI20:
 597              		.cfi_def_cfa_register 7
 404:../Generated_Code/SM1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 405:../Generated_Code/SM1.c ****   SM1_TDeviceDataPtr DeviceDataPrv = INT_SPI0__DEFAULT_RTOS_ISRPARAM;
 598              		.loc 1 405 0
 599 0006 344B     		ldr	r3, .L31
 600 0008 1B68     		ldr	r3, [r3]
 601 000a 7B60     		str	r3, [r7, #4]
 406:../Generated_Code/SM1.c ****   uint8_t StatReg = SPI_PDD_ReadStatusReg(SPI0_BASE_PTR); /* Read status register */
 602              		.loc 1 406 0
 603 000c 334A     		ldr	r2, .L31+4
 604 000e FB1C     		add	r3, r7, #3
 605 0010 D278     		ldrb	r2, [r2, #3]
 606 0012 1A70     		strb	r2, [r3]
 407:../Generated_Code/SM1.c **** 
 408:../Generated_Code/SM1.c ****   (void)DeviceDataPrv;                 /* Supress unused variable warning if needed */
 409:../Generated_Code/SM1.c ****   if ((StatReg & SPI_PDD_RX_BUFFER_FULL) != 0U) { /* Is any char in HW Rx buffer? */
 607              		.loc 1 409 0
 608 0014 FB1C     		add	r3, r7, #3
 609 0016 1B78     		ldrb	r3, [r3]
 610 0018 5BB2     		sxtb	r3, r3
 611 001a 002B     		cmp	r3, #0
 612 001c 28DA     		bge	.L28
 410:../Generated_Code/SM1.c ****     if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 613              		.loc 1 410 0
 614 001e 7B68     		ldr	r3, [r7, #4]
 615 0020 9B89     		ldrh	r3, [r3, #12]
 616 0022 002B     		cmp	r3, #0
 617 0024 24D0     		beq	.L28
 411:../Generated_Code/SM1.c ****       *(DeviceDataPrv->InpDataPtr++) = SPI_PDD_ReadData8bit(SPI0_BASE_PTR); /* Put a character to t
 618              		.loc 1 411 0
 619 0026 7B68     		ldr	r3, [r7, #4]
 620 0028 9B68     		ldr	r3, [r3, #8]
 621 002a 2C4A     		ldr	r2, .L31+4
 622 002c 5279     		ldrb	r2, [r2, #5]
 623 002e D2B2     		uxtb	r2, r2
 624 0030 1A70     		strb	r2, [r3]
 625 0032 5A1C     		add	r2, r3, #1
 626 0034 7B68     		ldr	r3, [r7, #4]
 627 0036 9A60     		str	r2, [r3, #8]
 412:../Generated_Code/SM1.c ****       DeviceDataPrv->InpRecvDataNum++; /* Increment received char. counter */
 628              		.loc 1 412 0
 629 0038 7B68     		ldr	r3, [r7, #4]
 630 003a 9B88     		ldrh	r3, [r3, #4]
 631 003c 0133     		add	r3, r3, #1
 632 003e 9AB2     		uxth	r2, r3
 633 0040 7B68     		ldr	r3, [r7, #4]
 634 0042 9A80     		strh	r2, [r3, #4]
 413:../Generated_Code/SM1.c ****       if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested numb
 635              		.loc 1 413 0
 636 0044 7B68     		ldr	r3, [r7, #4]
 637 0046 9A88     		ldrh	r2, [r3, #4]
 638 0048 7B68     		ldr	r3, [r7, #4]
 639 004a 9B89     		ldrh	r3, [r3, #12]
 640 004c 9A42     		cmp	r2, r3
 641 004e 0FD1     		bne	.L28
 414:../Generated_Code/SM1.c ****         SPI_PDD_DisableInterruptMask(SPI0_BASE_PTR, SPI_PDD_RX_BUFFER_FULL_OR_FAULT); /* Disable Rx
 642              		.loc 1 414 0
 643 0050 224B     		ldr	r3, .L31+4
 644 0052 224A     		ldr	r2, .L31+4
 645 0054 1278     		ldrb	r2, [r2]
 646 0056 D1B2     		uxtb	r1, r2
 647 0058 7F22     		mov	r2, #127
 648 005a 0A40     		and	r2, r1
 649 005c D2B2     		uxtb	r2, r2
 650 005e 1A70     		strb	r2, [r3]
 415:../Generated_Code/SM1.c ****         DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters t
 651              		.loc 1 415 0
 652 0060 7B68     		ldr	r3, [r7, #4]
 653 0062 0022     		mov	r2, #0
 654 0064 9A81     		strh	r2, [r3, #12]
 416:../Generated_Code/SM1.c ****         SM1_OnBlockReceived(DeviceDataPrv->UserData);
 655              		.loc 1 416 0
 656 0066 7B68     		ldr	r3, [r7, #4]
 657 0068 9B69     		ldr	r3, [r3, #24]
 658 006a 181C     		mov	r0, r3
 659 006c FFF7FEFF 		bl	SM1_OnBlockReceived
 660              	.L28:
 417:../Generated_Code/SM1.c ****       }
 418:../Generated_Code/SM1.c ****     }
 419:../Generated_Code/SM1.c ****   }
 420:../Generated_Code/SM1.c ****   if ((StatReg & SPI_PDD_TX_BUFFER_EMPTYG) != 0U) { /* Is HW Tx buffer empty? */
 661              		.loc 1 420 0
 662 0070 FB1C     		add	r3, r7, #3
 663 0072 1A78     		ldrb	r2, [r3]
 664 0074 2023     		mov	r3, #32
 665 0076 1340     		and	r3, r2
 666 0078 2AD0     		beq	.L27
 421:../Generated_Code/SM1.c ****     if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent charac
 667              		.loc 1 421 0
 668 007a 7B68     		ldr	r3, [r7, #4]
 669 007c DA89     		ldrh	r2, [r3, #14]
 670 007e 7B68     		ldr	r3, [r7, #4]
 671 0080 9B8A     		ldrh	r3, [r3, #20]
 672 0082 9A42     		cmp	r2, r3
 673 0084 1CD2     		bcs	.L30
 422:../Generated_Code/SM1.c ****       SPI_PDD_WriteData8Bit(SPI0_BASE_PTR, (*((uint8_t *)DeviceDataPrv->OutDataPtr++))); /* Put a c
 674              		.loc 1 422 0
 675 0086 154A     		ldr	r2, .L31+4
 676 0088 7B68     		ldr	r3, [r7, #4]
 677 008a 1B69     		ldr	r3, [r3, #16]
 678 008c 1978     		ldrb	r1, [r3]
 679 008e 5171     		strb	r1, [r2, #5]
 680 0090 5A1C     		add	r2, r3, #1
 681 0092 7B68     		ldr	r3, [r7, #4]
 682 0094 1A61     		str	r2, [r3, #16]
 423:../Generated_Code/SM1.c ****       DeviceDataPrv->OutSentDataNum++; /* Increment the counter of sent characters. */
 683              		.loc 1 423 0
 684 0096 7B68     		ldr	r3, [r7, #4]
 685 0098 DB89     		ldrh	r3, [r3, #14]
 686 009a 0133     		add	r3, r3, #1
 687 009c 9AB2     		uxth	r2, r3
 688 009e 7B68     		ldr	r3, [r7, #4]
 689 00a0 DA81     		strh	r2, [r3, #14]
 424:../Generated_Code/SM1.c ****       if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 690              		.loc 1 424 0
 691 00a2 7B68     		ldr	r3, [r7, #4]
 692 00a4 DA89     		ldrh	r2, [r3, #14]
 693 00a6 7B68     		ldr	r3, [r7, #4]
 694 00a8 9B8A     		ldrh	r3, [r3, #20]
 695 00aa 9A42     		cmp	r2, r3
 696 00ac 10D1     		bne	.L27
 425:../Generated_Code/SM1.c ****         DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by Send
 697              		.loc 1 425 0
 698 00ae 7B68     		ldr	r3, [r7, #4]
 699 00b0 0022     		mov	r2, #0
 700 00b2 9A82     		strh	r2, [r3, #20]
 426:../Generated_Code/SM1.c ****         SM1_OnBlockSent(DeviceDataPrv->UserData);
 701              		.loc 1 426 0
 702 00b4 7B68     		ldr	r3, [r7, #4]
 703 00b6 9B69     		ldr	r3, [r3, #24]
 704 00b8 181C     		mov	r0, r3
 705 00ba FFF7FEFF 		bl	SM1_OnBlockSent
 706 00be 07E0     		b	.L27
 707              	.L30:
 427:../Generated_Code/SM1.c ****       }
 428:../Generated_Code/SM1.c ****     } else {
 429:../Generated_Code/SM1.c ****       SPI_PDD_DisableInterruptMask(SPI0_BASE_PTR, SPI_PDD_TX_BUFFER_EMPTY); /* Disable TX interrupt
 708              		.loc 1 429 0
 709 00c0 064B     		ldr	r3, .L31+4
 710 00c2 064A     		ldr	r2, .L31+4
 711 00c4 1278     		ldrb	r2, [r2]
 712 00c6 D2B2     		uxtb	r2, r2
 713 00c8 2021     		mov	r1, #32
 714 00ca 8A43     		bic	r2, r1
 715 00cc D2B2     		uxtb	r2, r2
 716 00ce 1A70     		strb	r2, [r3]
 717              	.L27:
 430:../Generated_Code/SM1.c ****     }
 431:../Generated_Code/SM1.c ****   }
 432:../Generated_Code/SM1.c **** }
 718              		.loc 1 432 0
 719 00d0 BD46     		mov	sp, r7
 720 00d2 02B0     		add	sp, sp, #8
 721              		@ sp needed for prologue
 722 00d4 80BD     		pop	{r7, pc}
 723              	.L32:
 724 00d6 C046     		.align	2
 725              	.L31:
 726 00d8 00000000 		.word	INT_SPI0__DEFAULT_RTOS_ISRPARAM
 727 00dc 00600740 		.word	1074225152
 728              		.cfi_endproc
 729              	.LFE6:
 731              		.text
 732              	.Letext0:
 733              		.file 2 "E:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 734              		.file 3 "D:/kuaipan/SEMG/FRDM_KL25Z_SPI/spi_demo/Generated_Code/PE_Types.h"
 735              		.file 4 "D:/kuaipan/SEMG/FRDM_KL25Z_SPI/spi_demo/Generated_Code/IO_Map.h"
 736              		.file 5 "D:/kuaipan/SEMG/FRDM_KL25Z_SPI/spi_demo/Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 SM1.c
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:24     .bss.INT_SPI0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:27     .bss.INT_SPI0__DEFAULT_RTOS_ISRPARAM:00000000 INT_SPI0__DEFAULT_RTOS_ISRPARAM
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:30     .text.SM1_Init:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:35     .text.SM1_Init:00000000 SM1_Init
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:199    .text.SM1_Init:000000f8 $d
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:214    .text.SM1_Deinit:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:219    .text.SM1_Deinit:00000000 SM1_Deinit
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:260    .text.SM1_Deinit:0000002c $d
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:269    .text.SM1_ReceiveBlock:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:274    .text.SM1_ReceiveBlock:00000000 SM1_ReceiveBlock
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:389    .text.SM1_ReceiveBlock:00000098 $d
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:396    .text.SM1_SendBlock:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:401    .text.SM1_SendBlock:00000000 SM1_SendBlock
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:503    .text.SM1_SendBlock:00000084 $d
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:510    .text.SM1_GetReceivedDataNum:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:515    .text.SM1_GetReceivedDataNum:00000000 SM1_GetReceivedDataNum
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:544    .text.SM1_GetSentDataNum:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:549    .text.SM1_GetSentDataNum:00000000 SM1_GetSentDataNum
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:578    .text.SM1_Interrupt:00000000 $t
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:583    .text.SM1_Interrupt:00000000 SM1_Interrupt
C:\Users\lab\AppData\Local\Temp\cc86LzG0.s:726    .text.SM1_Interrupt:000000d8 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
SR_lock
SR_reg
SM1_OnBlockReceived
SM1_OnBlockSent

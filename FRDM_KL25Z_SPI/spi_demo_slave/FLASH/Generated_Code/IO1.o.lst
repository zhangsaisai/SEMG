   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"IO1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	32
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.text.IO1_Init,"ax",%progbits
  24              		.align	2
  25              		.global	IO1_Init
  26              		.code	16
  27              		.thumb_func
  29              	IO1_Init:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/IO1.c"
   1:../Generated_Code/IO1.c **** /* ###################################################################
   2:../Generated_Code/IO1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/IO1.c **** **     Filename    : IO1.c
   4:../Generated_Code/IO1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/IO1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/IO1.c **** **     Component   : Serial_LDD
   7:../Generated_Code/IO1.c **** **     Version     : Component 01.168, Driver 01.11, CPU db: 3.00.000
   8:../Generated_Code/IO1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/IO1.c **** **     Date/Time   : 2015-10-12, 14:26, # CodeGen: 7
  10:../Generated_Code/IO1.c **** **     Abstract    :
  11:../Generated_Code/IO1.c **** **         This component "Serial_LDD" implements an asynchronous serial
  12:../Generated_Code/IO1.c **** **         communication. The component supports different settings of
  13:../Generated_Code/IO1.c **** **         parity, word width, stop-bit and communication speed,
  14:../Generated_Code/IO1.c **** **         user can select interrupt or polling handler.
  15:../Generated_Code/IO1.c **** **         Communication speed can be changed also in runtime.
  16:../Generated_Code/IO1.c **** **         The component requires one on-chip asynchronous serial communication channel.
  17:../Generated_Code/IO1.c **** **     Settings    :
  18:../Generated_Code/IO1.c **** **          Component name                                 : IO1
  19:../Generated_Code/IO1.c **** **          Device                                         : UART0
  20:../Generated_Code/IO1.c **** **          Interrupt service/event                        : Disabled
  21:../Generated_Code/IO1.c **** **          Settings                                       : 
  22:../Generated_Code/IO1.c **** **            Data width                                   : 8 bits
  23:../Generated_Code/IO1.c **** **            Parity                                       : None
  24:../Generated_Code/IO1.c **** **            Stop bits                                    : 1
  25:../Generated_Code/IO1.c **** **            Loop mode                                    : Normal
  26:../Generated_Code/IO1.c **** **            Baud rate                                    : 115200 baud
  27:../Generated_Code/IO1.c **** **            Wakeup condition                             : Idle line wakeup
  28:../Generated_Code/IO1.c **** **            Stop in wait mode                            : no
  29:../Generated_Code/IO1.c **** **            Idle line mode                               : Starts after start bit
  30:../Generated_Code/IO1.c **** **            Transmitter output                           : Not inverted
  31:../Generated_Code/IO1.c **** **            Receiver input                               : Not inverted
  32:../Generated_Code/IO1.c **** **            Break generation length                      : 10/11 bits
  33:../Generated_Code/IO1.c **** **            Receiver                                     : Enabled
  34:../Generated_Code/IO1.c **** **              RxD                                        : TSI0_CH2/PTA1/UART0_RX/TPM2_CH0
  35:../Generated_Code/IO1.c **** **              RxD pin signal                             : 
  36:../Generated_Code/IO1.c **** **            Transmitter                                  : Enabled
  37:../Generated_Code/IO1.c **** **              TxD                                        : TSI0_CH3/PTA2/UART0_TX/TPM2_CH1
  38:../Generated_Code/IO1.c **** **              TxD pin signal                             : 
  39:../Generated_Code/IO1.c **** **            Flow control                                 : None
  40:../Generated_Code/IO1.c **** **          Initialization                                 : 
  41:../Generated_Code/IO1.c **** **            Enabled in init. code                        : yes
  42:../Generated_Code/IO1.c **** **            Auto initialization                          : yes
  43:../Generated_Code/IO1.c **** **            Event mask                                   : 
  44:../Generated_Code/IO1.c **** **              OnBlockSent                                : Disabled
  45:../Generated_Code/IO1.c **** **              OnBlockReceived                            : Disabled
  46:../Generated_Code/IO1.c **** **              OnTxComplete                               : Disabled
  47:../Generated_Code/IO1.c **** **              OnError                                    : Disabled
  48:../Generated_Code/IO1.c **** **              OnBreak                                    : Disabled
  49:../Generated_Code/IO1.c **** **          CPU clock/configuration selection              : 
  50:../Generated_Code/IO1.c **** **            Clock configuration 0                        : This component enabled
  51:../Generated_Code/IO1.c **** **            Clock configuration 1                        : This component enabled
  52:../Generated_Code/IO1.c **** **            Clock configuration 2                        : This component enabled
  53:../Generated_Code/IO1.c **** **            Clock configuration 3                        : This component enabled
  54:../Generated_Code/IO1.c **** **            Clock configuration 4                        : This component enabled
  55:../Generated_Code/IO1.c **** **            Clock configuration 5                        : This component enabled
  56:../Generated_Code/IO1.c **** **            Clock configuration 6                        : This component enabled
  57:../Generated_Code/IO1.c **** **            Clock configuration 7                        : This component enabled
  58:../Generated_Code/IO1.c **** **     Contents    :
  59:../Generated_Code/IO1.c **** **         Init         - LDD_TDeviceData* IO1_Init(LDD_TUserData *UserDataPtr);
  60:../Generated_Code/IO1.c **** **         Enable       - LDD_TError IO1_Enable(LDD_TDeviceData *DeviceDataPtr);
  61:../Generated_Code/IO1.c **** **         Disable      - LDD_TError IO1_Disable(LDD_TDeviceData *DeviceDataPtr);
  62:../Generated_Code/IO1.c **** **         SendBlock    - LDD_TError IO1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
  63:../Generated_Code/IO1.c **** **         ReceiveBlock - LDD_TError IO1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
  64:../Generated_Code/IO1.c **** **         SetEventMask - LDD_TError IO1_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMas
  65:../Generated_Code/IO1.c **** **         GetEventMask - LDD_TEventMask IO1_GetEventMask(LDD_TDeviceData *DeviceDataPtr);
  66:../Generated_Code/IO1.c **** **         Main         - void IO1_Main(LDD_TDeviceData *DeviceDataPtr);
  67:../Generated_Code/IO1.c **** **
  68:../Generated_Code/IO1.c **** **     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  69:../Generated_Code/IO1.c **** **     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
  70:../Generated_Code/IO1.c **** **     
  71:../Generated_Code/IO1.c **** **     http      : www.freescale.com
  72:../Generated_Code/IO1.c **** **     mail      : support@freescale.com
  73:../Generated_Code/IO1.c **** ** ###################################################################*/
  74:../Generated_Code/IO1.c **** /*!
  75:../Generated_Code/IO1.c **** ** @file IO1.c
  76:../Generated_Code/IO1.c **** ** @version 01.11
  77:../Generated_Code/IO1.c **** ** @brief
  78:../Generated_Code/IO1.c **** **         This component "Serial_LDD" implements an asynchronous serial
  79:../Generated_Code/IO1.c **** **         communication. The component supports different settings of
  80:../Generated_Code/IO1.c **** **         parity, word width, stop-bit and communication speed,
  81:../Generated_Code/IO1.c **** **         user can select interrupt or polling handler.
  82:../Generated_Code/IO1.c **** **         Communication speed can be changed also in runtime.
  83:../Generated_Code/IO1.c **** **         The component requires one on-chip asynchronous serial communication channel.
  84:../Generated_Code/IO1.c **** */         
  85:../Generated_Code/IO1.c **** /*!
  86:../Generated_Code/IO1.c **** **  @addtogroup IO1_module IO1 module documentation
  87:../Generated_Code/IO1.c **** **  @{
  88:../Generated_Code/IO1.c **** */         
  89:../Generated_Code/IO1.c **** 
  90:../Generated_Code/IO1.c **** /* MODULE IO1. */
  91:../Generated_Code/IO1.c **** /*lint -save  -e926 -e927 -e928 -e929 -e572 Disable MISRA rule (11.4,12.8) checking. */
  92:../Generated_Code/IO1.c **** 
  93:../Generated_Code/IO1.c **** /* {Default RTOS Adapter} No RTOS includes */
  94:../Generated_Code/IO1.c **** #include "IO1.h"
  95:../Generated_Code/IO1.c **** #include "UART0_PDD.h"
  96:../Generated_Code/IO1.c **** 
  97:../Generated_Code/IO1.c **** #ifdef __cplusplus
  98:../Generated_Code/IO1.c **** extern "C" {
  99:../Generated_Code/IO1.c **** #endif
 100:../Generated_Code/IO1.c **** 
 101:../Generated_Code/IO1.c **** /*! The mask of available events used to enable/disable events during runtime. */
 102:../Generated_Code/IO1.c **** #define AVAILABLE_EVENTS_MASK 0x00U
 103:../Generated_Code/IO1.c **** 
 104:../Generated_Code/IO1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 105:../Generated_Code/IO1.c **** static IO1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 106:../Generated_Code/IO1.c **** 
 107:../Generated_Code/IO1.c **** /*
 108:../Generated_Code/IO1.c **** ** ===================================================================
 109:../Generated_Code/IO1.c **** **     Method      :  IO1_Init (component Serial_LDD)
 110:../Generated_Code/IO1.c **** */
 111:../Generated_Code/IO1.c **** /*!
 112:../Generated_Code/IO1.c **** **     @brief
 113:../Generated_Code/IO1.c **** **         Initializes the device. Allocates memory for the device data
 114:../Generated_Code/IO1.c **** **         structure, allocates interrupt vectors and sets interrupt
 115:../Generated_Code/IO1.c **** **         priority, sets pin routing, sets timing, etc. If the "Enable
 116:../Generated_Code/IO1.c **** **         in init. code" is set to "yes" value then the device is also
 117:../Generated_Code/IO1.c **** **         enabled(see the description of the Enable() method). In this
 118:../Generated_Code/IO1.c **** **         case the Enable() method is not necessary and needn't to be
 119:../Generated_Code/IO1.c **** **         generated. 
 120:../Generated_Code/IO1.c **** **     @param
 121:../Generated_Code/IO1.c **** **         UserDataPtr     - Pointer to the user or
 122:../Generated_Code/IO1.c **** **                           RTOS specific data. This pointer will be
 123:../Generated_Code/IO1.c **** **                           passed as an event or callback parameter.
 124:../Generated_Code/IO1.c **** **     @return
 125:../Generated_Code/IO1.c **** **                         - Device data structure pointer.
 126:../Generated_Code/IO1.c **** */
 127:../Generated_Code/IO1.c **** /* ===================================================================*/
 128:../Generated_Code/IO1.c **** LDD_TDeviceData* IO1_Init(LDD_TUserData *UserDataPtr)
 129:../Generated_Code/IO1.c **** {
  32              		.loc 1 129 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42 0004 00AF     		add	r7, sp, #0
  43              	.LCFI2:
  44              		.cfi_def_cfa_register 7
  45 0006 7860     		str	r0, [r7, #4]
 130:../Generated_Code/IO1.c ****   /* Allocate device structure */
 131:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv;
 132:../Generated_Code/IO1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 133:../Generated_Code/IO1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  46              		.loc 1 133 0
  47 0008 4F4B     		ldr	r3, .L3
  48 000a FB60     		str	r3, [r7, #12]
 134:../Generated_Code/IO1.c **** 
 135:../Generated_Code/IO1.c ****   /* Clear the receive counters and pointer */
 136:../Generated_Code/IO1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  49              		.loc 1 136 0
  50 000c FB68     		ldr	r3, [r7, #12]
  51 000e 0022     		mov	r2, #0
  52 0010 1A81     		strh	r2, [r3, #8]
 137:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  53              		.loc 1 137 0
  54 0012 FB68     		ldr	r3, [r7, #12]
  55 0014 0022     		mov	r2, #0
  56 0016 1A82     		strh	r2, [r3, #16]
 138:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  57              		.loc 1 138 0
  58 0018 FB68     		ldr	r3, [r7, #12]
  59 001a 0022     		mov	r2, #0
  60 001c DA60     		str	r2, [r3, #12]
 139:../Generated_Code/IO1.c ****   /* Clear the transmit counters and pointer */
 140:../Generated_Code/IO1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  61              		.loc 1 140 0
  62 001e FB68     		ldr	r3, [r7, #12]
  63 0020 0022     		mov	r2, #0
  64 0022 5A82     		strh	r2, [r3, #18]
 141:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  65              		.loc 1 141 0
  66 0024 FB68     		ldr	r3, [r7, #12]
  67 0026 0022     		mov	r2, #0
  68 0028 1A83     		strh	r2, [r3, #24]
 142:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  69              		.loc 1 142 0
  70 002a FB68     		ldr	r3, [r7, #12]
  71 002c 0022     		mov	r2, #0
  72 002e 5A61     		str	r2, [r3, #20]
 143:../Generated_Code/IO1.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  73              		.loc 1 143 0
  74 0030 FB68     		ldr	r3, [r7, #12]
  75 0032 7A68     		ldr	r2, [r7, #4]
  76 0034 DA61     		str	r2, [r3, #28]
 144:../Generated_Code/IO1.c ****   /* SIM_SCGC4: UART0=1 */
 145:../Generated_Code/IO1.c ****   SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;                                   
  77              		.loc 1 145 0
  78 0036 454A     		ldr	r2, .L3+4
  79 0038 4449     		ldr	r1, .L3+4
  80 003a 454B     		ldr	r3, .L3+8
  81 003c CB58     		ldr	r3, [r1, r3]
  82 003e 8021     		mov	r1, #128
  83 0040 C900     		lsl	r1, r1, #3
  84 0042 1943     		orr	r1, r3
  85 0044 424B     		ldr	r3, .L3+8
  86 0046 D150     		str	r1, [r2, r3]
 146:../Generated_Code/IO1.c ****   /* PORTA_PCR1: ISF=0,MUX=2 */
 147:../Generated_Code/IO1.c ****   PORTA_PCR1 = (uint32_t)((PORTA_PCR1 & (uint32_t)~(uint32_t)(
  87              		.loc 1 147 0
  88 0048 424B     		ldr	r3, .L3+12
  89 004a 424A     		ldr	r2, .L3+12
  90 004c 5168     		ldr	r1, [r2, #4]
  91 004e 424A     		ldr	r2, .L3+16
  92 0050 0A40     		and	r2, r1
  93 0052 8021     		mov	r1, #128
  94 0054 8900     		lsl	r1, r1, #2
  95 0056 0A43     		orr	r2, r1
  96 0058 5A60     		str	r2, [r3, #4]
 148:../Generated_Code/IO1.c ****                 PORT_PCR_ISF_MASK |
 149:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x05)
 150:../Generated_Code/IO1.c ****                )) | (uint32_t)(
 151:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x02)
 152:../Generated_Code/IO1.c ****                ));                                  
 153:../Generated_Code/IO1.c ****   /* PORTA_PCR2: ISF=0,MUX=2 */
 154:../Generated_Code/IO1.c ****   PORTA_PCR2 = (uint32_t)((PORTA_PCR2 & (uint32_t)~(uint32_t)(
  97              		.loc 1 154 0
  98 005a 3E4B     		ldr	r3, .L3+12
  99 005c 3D4A     		ldr	r2, .L3+12
 100 005e 9168     		ldr	r1, [r2, #8]
 101 0060 3D4A     		ldr	r2, .L3+16
 102 0062 0A40     		and	r2, r1
 103 0064 8021     		mov	r1, #128
 104 0066 8900     		lsl	r1, r1, #2
 105 0068 0A43     		orr	r2, r1
 106 006a 9A60     		str	r2, [r3, #8]
 155:../Generated_Code/IO1.c ****                 PORT_PCR_ISF_MASK |
 156:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x05)
 157:../Generated_Code/IO1.c ****                )) | (uint32_t)(
 158:../Generated_Code/IO1.c ****                 PORT_PCR_MUX(0x02)
 159:../Generated_Code/IO1.c ****                ));                                  
 160:../Generated_Code/IO1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_DISABLE); /* Disable transmitter. */
 107              		.loc 1 160 0
 108 006c 3B4B     		ldr	r3, .L3+20
 109 006e 3B4A     		ldr	r2, .L3+20
 110 0070 D278     		ldrb	r2, [r2, #3]
 111 0072 D2B2     		uxtb	r2, r2
 112 0074 0821     		mov	r1, #8
 113 0076 8A43     		bic	r2, r1
 114 0078 D2B2     		uxtb	r2, r2
 115 007a DA70     		strb	r2, [r3, #3]
 161:../Generated_Code/IO1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_DISABLE); /* Disable receiver. */
 116              		.loc 1 161 0
 117 007c 374B     		ldr	r3, .L3+20
 118 007e 374A     		ldr	r2, .L3+20
 119 0080 D278     		ldrb	r2, [r2, #3]
 120 0082 D2B2     		uxtb	r2, r2
 121 0084 0421     		mov	r1, #4
 122 0086 8A43     		bic	r2, r1
 123 0088 D2B2     		uxtb	r2, r2
 124 008a DA70     		strb	r2, [r3, #3]
 162:../Generated_Code/IO1.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset flags */
 125              		.loc 1 162 0
 126 008c FB68     		ldr	r3, [r7, #12]
 127 008e 0022     		mov	r2, #0
 128 0090 1A80     		strh	r2, [r3]
 163:../Generated_Code/IO1.c ****   DeviceDataPrv->EventMask = 0x00u;    /* Initialization of the event mask variable */
 129              		.loc 1 163 0
 130 0092 FB68     		ldr	r3, [r7, #12]
 131 0094 0022     		mov	r2, #0
 132 0096 5A60     		str	r2, [r3, #4]
 164:../Generated_Code/IO1.c ****   DeviceDataPrv->EnUser = TRUE;        /* Enable device */
 133              		.loc 1 164 0
 134 0098 FB68     		ldr	r3, [r7, #12]
 135 009a 0122     		mov	r2, #1
 136 009c 9A70     		strb	r2, [r3, #2]
 165:../Generated_Code/IO1.c ****   /* UART0_C1: LOOPS=0,DOZEEN=0,RSRC=0,M=0,WAKE=0,ILT=0,PE=0,PT=0 */
 166:../Generated_Code/IO1.c ****   UART0_C1 = 0x00U;                    /*  Set the C1 register */
 137              		.loc 1 166 0
 138 009e 2F4B     		ldr	r3, .L3+20
 139 00a0 0022     		mov	r2, #0
 140 00a2 9A70     		strb	r2, [r3, #2]
 167:../Generated_Code/IO1.c ****   /* UART0_C3: R8T9=0,R9T8=0,TXDIR=0,TXINV=0,ORIE=0,NEIE=0,FEIE=0,PEIE=0 */
 168:../Generated_Code/IO1.c ****   UART0_C3 = 0x00U;                    /*  Set the C3 register */
 141              		.loc 1 168 0
 142 00a4 2D4B     		ldr	r3, .L3+20
 143 00a6 0022     		mov	r2, #0
 144 00a8 9A71     		strb	r2, [r3, #6]
 169:../Generated_Code/IO1.c ****   /* UART0_C4: MAEN1=0,MAEN2=0,M10=0,OSR=0 */
 170:../Generated_Code/IO1.c ****   UART0_C4 = UART0_C4_OSR(0x00);       /*  Set the C4 register */
 145              		.loc 1 170 0
 146 00aa 2C4B     		ldr	r3, .L3+20
 147 00ac 0022     		mov	r2, #0
 148 00ae 9A72     		strb	r2, [r3, #10]
 171:../Generated_Code/IO1.c ****   /* UART0_S2: LBKDIF=0,RXEDGIF=0,MSBF=0,RXINV=0,RWUID=0,BRK13=0,LBKDE=0,RAF=0 */
 172:../Generated_Code/IO1.c ****   UART0_S2 = 0x00U;                    /*  Set the S2 register */
 149              		.loc 1 172 0
 150 00b0 2A4B     		ldr	r3, .L3+20
 151 00b2 0022     		mov	r2, #0
 152 00b4 5A71     		strb	r2, [r3, #5]
 173:../Generated_Code/IO1.c ****   UART0_PDD_SetClockSource(UART0_BASE_PTR, UART0_PDD_PLL_FLL_CLOCK);
 153              		.loc 1 173 0
 154 00b6 254A     		ldr	r2, .L3+4
 155 00b8 2449     		ldr	r1, .L3+4
 156 00ba 294B     		ldr	r3, .L3+24
 157 00bc C958     		ldr	r1, [r1, r3]
 158 00be 294B     		ldr	r3, .L3+28
 159 00c0 0B40     		and	r3, r1
 160 00c2 8021     		mov	r1, #128
 161 00c4 C904     		lsl	r1, r1, #19
 162 00c6 1943     		orr	r1, r3
 163 00c8 254B     		ldr	r3, .L3+24
 164 00ca D150     		str	r1, [r2, r3]
 174:../Generated_Code/IO1.c ****   UART0_PDD_SetBaudRate(UART0_BASE_PTR, 52U); /* Set the baud rate register. */
 165              		.loc 1 174 0
 166 00cc 234B     		ldr	r3, .L3+20
 167 00ce 234A     		ldr	r2, .L3+20
 168 00d0 1278     		ldrb	r2, [r2]
 169 00d2 D2B2     		uxtb	r2, r2
 170 00d4 1F21     		mov	r1, #31
 171 00d6 8A43     		bic	r2, r1
 172 00d8 D2B2     		uxtb	r2, r2
 173 00da 1A70     		strb	r2, [r3]
 174 00dc 1F4B     		ldr	r3, .L3+20
 175 00de 3422     		mov	r2, #52
 176 00e0 5A70     		strb	r2, [r3, #1]
 175:../Generated_Code/IO1.c ****   UART0_PDD_SetOversamplingRatio(UART0_BASE_PTR, 3U);
 177              		.loc 1 175 0
 178 00e2 1E4B     		ldr	r3, .L3+20
 179 00e4 1D4A     		ldr	r2, .L3+20
 180 00e6 927A     		ldrb	r2, [r2, #10]
 181 00e8 D2B2     		uxtb	r2, r2
 182 00ea D2B2     		uxtb	r2, r2
 183 00ec 1F21     		mov	r1, #31
 184 00ee 8A43     		bic	r2, r1
 185 00f0 D2B2     		uxtb	r2, r2
 186 00f2 0321     		mov	r1, #3
 187 00f4 0A43     		orr	r2, r1
 188 00f6 D2B2     		uxtb	r2, r2
 189 00f8 D2B2     		uxtb	r2, r2
 190 00fa 9A72     		strb	r2, [r3, #10]
 176:../Generated_Code/IO1.c ****   UART0_PDD_EnableSamplingOnBothEdges(UART0_BASE_PTR, PDD_ENABLE);
 191              		.loc 1 176 0
 192 00fc 174B     		ldr	r3, .L3+20
 193 00fe 174A     		ldr	r2, .L3+20
 194 0100 D27A     		ldrb	r2, [r2, #11]
 195 0102 D2B2     		uxtb	r2, r2
 196 0104 D2B2     		uxtb	r2, r2
 197 0106 0221     		mov	r1, #2
 198 0108 0A43     		orr	r2, r1
 199 010a D2B2     		uxtb	r2, r2
 200 010c D2B2     		uxtb	r2, r2
 201 010e DA72     		strb	r2, [r3, #11]
 177:../Generated_Code/IO1.c ****   UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_ENABLE); /* Enable transmitter */
 202              		.loc 1 177 0
 203 0110 124B     		ldr	r3, .L3+20
 204 0112 124A     		ldr	r2, .L3+20
 205 0114 D278     		ldrb	r2, [r2, #3]
 206 0116 D2B2     		uxtb	r2, r2
 207 0118 D2B2     		uxtb	r2, r2
 208 011a 0821     		mov	r1, #8
 209 011c 0A43     		orr	r2, r1
 210 011e D2B2     		uxtb	r2, r2
 211 0120 D2B2     		uxtb	r2, r2
 212 0122 DA70     		strb	r2, [r3, #3]
 178:../Generated_Code/IO1.c ****   UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_ENABLE); /* Enable receiver */
 213              		.loc 1 178 0
 214 0124 0D4B     		ldr	r3, .L3+20
 215 0126 0D4A     		ldr	r2, .L3+20
 216 0128 D278     		ldrb	r2, [r2, #3]
 217 012a D2B2     		uxtb	r2, r2
 218 012c D2B2     		uxtb	r2, r2
 219 012e 0421     		mov	r1, #4
 220 0130 0A43     		orr	r2, r1
 221 0132 D2B2     		uxtb	r2, r2
 222 0134 D2B2     		uxtb	r2, r2
 223 0136 DA70     		strb	r2, [r3, #3]
 179:../Generated_Code/IO1.c ****   /* Registration of the device structure */
 180:../Generated_Code/IO1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_IO1_ID,DeviceDataPrv);
 224              		.loc 1 180 0
 225 0138 0B4B     		ldr	r3, .L3+32
 226 013a FA68     		ldr	r2, [r7, #12]
 227 013c 1A60     		str	r2, [r3]
 181:../Generated_Code/IO1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv);
 228              		.loc 1 181 0
 229 013e FB68     		ldr	r3, [r7, #12]
 182:../Generated_Code/IO1.c **** }
 230              		.loc 1 182 0
 231 0140 181C     		mov	r0, r3
 232 0142 BD46     		mov	sp, r7
 233 0144 04B0     		add	sp, sp, #16
 234              		@ sp needed for prologue
 235 0146 80BD     		pop	{r7, pc}
 236              	.L4:
 237              		.align	2
 238              	.L3:
 239 0148 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 240 014c 00700440 		.word	1074032640
 241 0150 34100000 		.word	4148
 242 0154 00900440 		.word	1074040832
 243 0158 FFF8FFFE 		.word	-16779009
 244 015c 00A00640 		.word	1074176000
 245 0160 04100000 		.word	4100
 246 0164 FFFFFFF3 		.word	-201326593
 247 0168 00000000 		.word	PE_LDD_DeviceDataList
 248              		.cfi_endproc
 249              	.LFE0:
 251              		.section	.text.IO1_Enable,"ax",%progbits
 252              		.align	2
 253              		.global	IO1_Enable
 254              		.code	16
 255              		.thumb_func
 257              	IO1_Enable:
 258              	.LFB1:
 183:../Generated_Code/IO1.c **** 
 184:../Generated_Code/IO1.c **** /*
 185:../Generated_Code/IO1.c **** ** ===================================================================
 186:../Generated_Code/IO1.c **** **     Method      :  IO1_Enable (component Serial_LDD)
 187:../Generated_Code/IO1.c **** */
 188:../Generated_Code/IO1.c **** /*!
 189:../Generated_Code/IO1.c **** **     @brief
 190:../Generated_Code/IO1.c **** **         Enables the device, starts the transmitting and receiving.
 191:../Generated_Code/IO1.c **** **     @param
 192:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 193:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 194:../Generated_Code/IO1.c **** **     @return
 195:../Generated_Code/IO1.c **** **                         - Error code, possible codes:
 196:../Generated_Code/IO1.c **** **                           ERR_OK - OK
 197:../Generated_Code/IO1.c **** **                           ERR_SPEED - The component does not work in
 198:../Generated_Code/IO1.c **** **                           the active clock configuration.
 199:../Generated_Code/IO1.c **** */
 200:../Generated_Code/IO1.c **** /* ===================================================================*/
 201:../Generated_Code/IO1.c **** LDD_TError IO1_Enable(LDD_TDeviceData *DeviceDataPtr)
 202:../Generated_Code/IO1.c **** {
 259              		.loc 1 202 0
 260              		.cfi_startproc
 261 0000 80B5     		push	{r7, lr}
 262              	.LCFI3:
 263              		.cfi_def_cfa_offset 8
 264              		.cfi_offset 7, -8
 265              		.cfi_offset 14, -4
 266 0002 84B0     		sub	sp, sp, #16
 267              	.LCFI4:
 268              		.cfi_def_cfa_offset 24
 269 0004 00AF     		add	r7, sp, #0
 270              	.LCFI5:
 271              		.cfi_def_cfa_register 7
 272 0006 7860     		str	r0, [r7, #4]
 203:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 273              		.loc 1 203 0
 274 0008 7B68     		ldr	r3, [r7, #4]
 275 000a FB60     		str	r3, [r7, #12]
 204:../Generated_Code/IO1.c **** 
 205:../Generated_Code/IO1.c ****   if (!DeviceDataPrv->EnUser) {        /* Is the device disabled by user? */
 276              		.loc 1 205 0
 277 000c FB68     		ldr	r3, [r7, #12]
 278 000e 9B78     		ldrb	r3, [r3, #2]
 279 0010 002B     		cmp	r3, #0
 280 0012 16D1     		bne	.L6
 206:../Generated_Code/IO1.c ****     DeviceDataPrv->EnUser = TRUE;      /* If yes then set the flag "device enabled" */
 281              		.loc 1 206 0
 282 0014 FB68     		ldr	r3, [r7, #12]
 283 0016 0122     		mov	r2, #1
 284 0018 9A70     		strb	r2, [r3, #2]
 207:../Generated_Code/IO1.c ****     UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_ENABLE); /* Enable transmitter */
 285              		.loc 1 207 0
 286 001a 0C4B     		ldr	r3, .L8
 287 001c 0B4A     		ldr	r2, .L8
 288 001e D278     		ldrb	r2, [r2, #3]
 289 0020 D2B2     		uxtb	r2, r2
 290 0022 D2B2     		uxtb	r2, r2
 291 0024 0821     		mov	r1, #8
 292 0026 0A43     		orr	r2, r1
 293 0028 D2B2     		uxtb	r2, r2
 294 002a D2B2     		uxtb	r2, r2
 295 002c DA70     		strb	r2, [r3, #3]
 208:../Generated_Code/IO1.c ****     UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_ENABLE); /* Enable receiver */
 296              		.loc 1 208 0
 297 002e 074B     		ldr	r3, .L8
 298 0030 064A     		ldr	r2, .L8
 299 0032 D278     		ldrb	r2, [r2, #3]
 300 0034 D2B2     		uxtb	r2, r2
 301 0036 D2B2     		uxtb	r2, r2
 302 0038 0421     		mov	r1, #4
 303 003a 0A43     		orr	r2, r1
 304 003c D2B2     		uxtb	r2, r2
 305 003e D2B2     		uxtb	r2, r2
 306 0040 DA70     		strb	r2, [r3, #3]
 307              	.L6:
 209:../Generated_Code/IO1.c ****   }
 210:../Generated_Code/IO1.c ****   return ERR_OK;                       /* OK */
 308              		.loc 1 210 0
 309 0042 0023     		mov	r3, #0
 211:../Generated_Code/IO1.c **** }
 310              		.loc 1 211 0
 311 0044 181C     		mov	r0, r3
 312 0046 BD46     		mov	sp, r7
 313 0048 04B0     		add	sp, sp, #16
 314              		@ sp needed for prologue
 315 004a 80BD     		pop	{r7, pc}
 316              	.L9:
 317              		.align	2
 318              	.L8:
 319 004c 00A00640 		.word	1074176000
 320              		.cfi_endproc
 321              	.LFE1:
 323              		.section	.text.IO1_Disable,"ax",%progbits
 324              		.align	2
 325              		.global	IO1_Disable
 326              		.code	16
 327              		.thumb_func
 329              	IO1_Disable:
 330              	.LFB2:
 212:../Generated_Code/IO1.c **** 
 213:../Generated_Code/IO1.c **** /*
 214:../Generated_Code/IO1.c **** ** ===================================================================
 215:../Generated_Code/IO1.c **** **     Method      :  IO1_Disable (component Serial_LDD)
 216:../Generated_Code/IO1.c **** */
 217:../Generated_Code/IO1.c **** /*!
 218:../Generated_Code/IO1.c **** **     @brief
 219:../Generated_Code/IO1.c **** **         Disables the device, stops the transmitting and receiving.
 220:../Generated_Code/IO1.c **** **     @param
 221:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 222:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 223:../Generated_Code/IO1.c **** **     @return
 224:../Generated_Code/IO1.c **** **                         - Error code, possible codes:
 225:../Generated_Code/IO1.c **** **                           ERR_OK - OK
 226:../Generated_Code/IO1.c **** **                           ERR_SPEED - The component does not work in
 227:../Generated_Code/IO1.c **** **                           the active clock configuration.
 228:../Generated_Code/IO1.c **** */
 229:../Generated_Code/IO1.c **** /* ===================================================================*/
 230:../Generated_Code/IO1.c **** LDD_TError IO1_Disable(LDD_TDeviceData *DeviceDataPtr)
 231:../Generated_Code/IO1.c **** {
 331              		.loc 1 231 0
 332              		.cfi_startproc
 333 0000 80B5     		push	{r7, lr}
 334              	.LCFI6:
 335              		.cfi_def_cfa_offset 8
 336              		.cfi_offset 7, -8
 337              		.cfi_offset 14, -4
 338 0002 84B0     		sub	sp, sp, #16
 339              	.LCFI7:
 340              		.cfi_def_cfa_offset 24
 341 0004 00AF     		add	r7, sp, #0
 342              	.LCFI8:
 343              		.cfi_def_cfa_register 7
 344 0006 7860     		str	r0, [r7, #4]
 232:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 345              		.loc 1 232 0
 346 0008 7B68     		ldr	r3, [r7, #4]
 347 000a FB60     		str	r3, [r7, #12]
 233:../Generated_Code/IO1.c **** 
 234:../Generated_Code/IO1.c ****   if (DeviceDataPrv->EnUser) {         /* Is the device enabled by user? */
 348              		.loc 1 234 0
 349 000c FB68     		ldr	r3, [r7, #12]
 350 000e 9B78     		ldrb	r3, [r3, #2]
 351 0010 002B     		cmp	r3, #0
 352 0012 12D0     		beq	.L11
 235:../Generated_Code/IO1.c ****     DeviceDataPrv->EnUser = FALSE;     /* If yes then set the flag "device disabled" */
 353              		.loc 1 235 0
 354 0014 FB68     		ldr	r3, [r7, #12]
 355 0016 0022     		mov	r2, #0
 356 0018 9A70     		strb	r2, [r3, #2]
 236:../Generated_Code/IO1.c ****     UART0_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_DISABLE); /* Disable transmitter. */
 357              		.loc 1 236 0
 358 001a 0A4B     		ldr	r3, .L13
 359 001c 094A     		ldr	r2, .L13
 360 001e D278     		ldrb	r2, [r2, #3]
 361 0020 D2B2     		uxtb	r2, r2
 362 0022 0821     		mov	r1, #8
 363 0024 8A43     		bic	r2, r1
 364 0026 D2B2     		uxtb	r2, r2
 365 0028 DA70     		strb	r2, [r3, #3]
 237:../Generated_Code/IO1.c ****     UART0_PDD_EnableReceiver(UART0_BASE_PTR, PDD_DISABLE); /* Disable receiver. */
 366              		.loc 1 237 0
 367 002a 064B     		ldr	r3, .L13
 368 002c 054A     		ldr	r2, .L13
 369 002e D278     		ldrb	r2, [r2, #3]
 370 0030 D2B2     		uxtb	r2, r2
 371 0032 0421     		mov	r1, #4
 372 0034 8A43     		bic	r2, r1
 373 0036 D2B2     		uxtb	r2, r2
 374 0038 DA70     		strb	r2, [r3, #3]
 375              	.L11:
 238:../Generated_Code/IO1.c ****   }
 239:../Generated_Code/IO1.c ****   return ERR_OK;                       /* OK */
 376              		.loc 1 239 0
 377 003a 0023     		mov	r3, #0
 240:../Generated_Code/IO1.c **** }
 378              		.loc 1 240 0
 379 003c 181C     		mov	r0, r3
 380 003e BD46     		mov	sp, r7
 381 0040 04B0     		add	sp, sp, #16
 382              		@ sp needed for prologue
 383 0042 80BD     		pop	{r7, pc}
 384              	.L14:
 385              		.align	2
 386              	.L13:
 387 0044 00A00640 		.word	1074176000
 388              		.cfi_endproc
 389              	.LFE2:
 391              		.section	.text.IO1_GetEventMask,"ax",%progbits
 392              		.align	2
 393              		.global	IO1_GetEventMask
 394              		.code	16
 395              		.thumb_func
 397              	IO1_GetEventMask:
 398              	.LFB3:
 241:../Generated_Code/IO1.c **** 
 242:../Generated_Code/IO1.c **** /*
 243:../Generated_Code/IO1.c **** ** ===================================================================
 244:../Generated_Code/IO1.c **** **     Method      :  IO1_GetEventMask (component Serial_LDD)
 245:../Generated_Code/IO1.c **** */
 246:../Generated_Code/IO1.c **** /*!
 247:../Generated_Code/IO1.c **** **     @brief
 248:../Generated_Code/IO1.c **** **         Returns current event mask. This method is available if the
 249:../Generated_Code/IO1.c **** **         interrupt service/event property is enabled and at least one
 250:../Generated_Code/IO1.c **** **         event is enabled.
 251:../Generated_Code/IO1.c **** **     @param
 252:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 253:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 254:../Generated_Code/IO1.c **** **     @return
 255:../Generated_Code/IO1.c **** **                         - The current event mask. The component event
 256:../Generated_Code/IO1.c **** **                           masks are defined in the PE_Types.h file.
 257:../Generated_Code/IO1.c **** */
 258:../Generated_Code/IO1.c **** /* ===================================================================*/
 259:../Generated_Code/IO1.c **** LDD_TEventMask IO1_GetEventMask(LDD_TDeviceData *DeviceDataPtr)
 260:../Generated_Code/IO1.c **** {
 399              		.loc 1 260 0
 400              		.cfi_startproc
 401 0000 80B5     		push	{r7, lr}
 402              	.LCFI9:
 403              		.cfi_def_cfa_offset 8
 404              		.cfi_offset 7, -8
 405              		.cfi_offset 14, -4
 406 0002 84B0     		sub	sp, sp, #16
 407              	.LCFI10:
 408              		.cfi_def_cfa_offset 24
 409 0004 00AF     		add	r7, sp, #0
 410              	.LCFI11:
 411              		.cfi_def_cfa_register 7
 412 0006 7860     		str	r0, [r7, #4]
 261:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 413              		.loc 1 261 0
 414 0008 7B68     		ldr	r3, [r7, #4]
 415 000a FB60     		str	r3, [r7, #12]
 262:../Generated_Code/IO1.c ****   LDD_TEventMask EventMask;
 263:../Generated_Code/IO1.c **** 
 264:../Generated_Code/IO1.c ****   EventMask = DeviceDataPrv->EventMask; /* Read the current event mask. */
 416              		.loc 1 264 0
 417 000c FB68     		ldr	r3, [r7, #12]
 418 000e 5B68     		ldr	r3, [r3, #4]
 419 0010 BB60     		str	r3, [r7, #8]
 265:../Generated_Code/IO1.c ****   return (EventMask);                  /* Return the current event mask. */
 420              		.loc 1 265 0
 421 0012 BB68     		ldr	r3, [r7, #8]
 266:../Generated_Code/IO1.c **** }
 422              		.loc 1 266 0
 423 0014 181C     		mov	r0, r3
 424 0016 BD46     		mov	sp, r7
 425 0018 04B0     		add	sp, sp, #16
 426              		@ sp needed for prologue
 427 001a 80BD     		pop	{r7, pc}
 428              		.cfi_endproc
 429              	.LFE3:
 431              		.section	.text.IO1_SetEventMask,"ax",%progbits
 432              		.align	2
 433              		.global	IO1_SetEventMask
 434              		.code	16
 435              		.thumb_func
 437              	IO1_SetEventMask:
 438              	.LFB4:
 267:../Generated_Code/IO1.c **** 
 268:../Generated_Code/IO1.c **** /*
 269:../Generated_Code/IO1.c **** ** ===================================================================
 270:../Generated_Code/IO1.c **** **     Method      :  IO1_SetEventMask (component Serial_LDD)
 271:../Generated_Code/IO1.c **** */
 272:../Generated_Code/IO1.c **** /*!
 273:../Generated_Code/IO1.c **** **     @brief
 274:../Generated_Code/IO1.c **** **         Enables/Disables events. This method is available if the
 275:../Generated_Code/IO1.c **** **         interrupt service/event property is enabled and at least one
 276:../Generated_Code/IO1.c **** **         event is enabled.
 277:../Generated_Code/IO1.c **** **     @param
 278:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 279:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 280:../Generated_Code/IO1.c **** **     @param
 281:../Generated_Code/IO1.c **** **         EventMask       - Mask of events to enable.
 282:../Generated_Code/IO1.c **** **     @return
 283:../Generated_Code/IO1.c **** **                         - Error code, possible codes:
 284:../Generated_Code/IO1.c **** **                           ERR_OK - OK
 285:../Generated_Code/IO1.c **** **                           ERR_SPEED - The component does not work in
 286:../Generated_Code/IO1.c **** **                           the active clock configuration.
 287:../Generated_Code/IO1.c **** **                           ERR_DISABLED - The component or device is
 288:../Generated_Code/IO1.c **** **                           disabled.
 289:../Generated_Code/IO1.c **** **                           ERR_PARAM_MASK - Invalid event mask.
 290:../Generated_Code/IO1.c **** */
 291:../Generated_Code/IO1.c **** /* ===================================================================*/
 292:../Generated_Code/IO1.c **** LDD_TError IO1_SetEventMask(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask)
 293:../Generated_Code/IO1.c **** {
 439              		.loc 1 293 0
 440              		.cfi_startproc
 441 0000 80B5     		push	{r7, lr}
 442              	.LCFI12:
 443              		.cfi_def_cfa_offset 8
 444              		.cfi_offset 7, -8
 445              		.cfi_offset 14, -4
 446 0002 84B0     		sub	sp, sp, #16
 447              	.LCFI13:
 448              		.cfi_def_cfa_offset 24
 449 0004 00AF     		add	r7, sp, #0
 450              	.LCFI14:
 451              		.cfi_def_cfa_register 7
 452 0006 7860     		str	r0, [r7, #4]
 453 0008 3960     		str	r1, [r7]
 294:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 454              		.loc 1 294 0
 455 000a 7B68     		ldr	r3, [r7, #4]
 456 000c FB60     		str	r3, [r7, #12]
 295:../Generated_Code/IO1.c **** 
 296:../Generated_Code/IO1.c ****   if (!DeviceDataPrv->EnUser) {        /* Is the device disabled by user? */
 457              		.loc 1 296 0
 458 000e FB68     		ldr	r3, [r7, #12]
 459 0010 9B78     		ldrb	r3, [r3, #2]
 460 0012 002B     		cmp	r3, #0
 461 0014 01D1     		bne	.L18
 297:../Generated_Code/IO1.c ****     return ERR_DISABLED;               /* If yes then error */
 462              		.loc 1 297 0
 463 0016 0723     		mov	r3, #7
 464 0018 08E0     		b	.L19
 465              	.L18:
 298:../Generated_Code/IO1.c ****   }
 299:../Generated_Code/IO1.c ****   if ((EventMask & (LDD_TEventMask)(~(LDD_TEventMask)AVAILABLE_EVENTS_MASK)) != 0x00U) { /* Is the 
 466              		.loc 1 299 0
 467 001a 3B68     		ldr	r3, [r7]
 468 001c 002B     		cmp	r3, #0
 469 001e 01D0     		beq	.L20
 300:../Generated_Code/IO1.c ****     return ERR_PARAM_MASK;             /* If no then error */
 470              		.loc 1 300 0
 471 0020 8023     		mov	r3, #128
 472 0022 03E0     		b	.L19
 473              	.L20:
 301:../Generated_Code/IO1.c ****   }
 302:../Generated_Code/IO1.c ****   DeviceDataPrv->EventMask = EventMask; /* Set the new event mask. */
 474              		.loc 1 302 0
 475 0024 FB68     		ldr	r3, [r7, #12]
 476 0026 3A68     		ldr	r2, [r7]
 477 0028 5A60     		str	r2, [r3, #4]
 303:../Generated_Code/IO1.c ****   return ERR_OK;                       /* OK */
 478              		.loc 1 303 0
 479 002a 0023     		mov	r3, #0
 480              	.L19:
 304:../Generated_Code/IO1.c **** }
 481              		.loc 1 304 0
 482 002c 181C     		mov	r0, r3
 483 002e BD46     		mov	sp, r7
 484 0030 04B0     		add	sp, sp, #16
 485              		@ sp needed for prologue
 486 0032 80BD     		pop	{r7, pc}
 487              		.cfi_endproc
 488              	.LFE4:
 490              		.section	.text.IO1_ReceiveBlock,"ax",%progbits
 491              		.align	2
 492              		.global	IO1_ReceiveBlock
 493              		.code	16
 494              		.thumb_func
 496              	IO1_ReceiveBlock:
 497              	.LFB5:
 305:../Generated_Code/IO1.c **** 
 306:../Generated_Code/IO1.c **** /*
 307:../Generated_Code/IO1.c **** ** ===================================================================
 308:../Generated_Code/IO1.c **** **     Method      :  IO1_ReceiveBlock (component Serial_LDD)
 309:../Generated_Code/IO1.c **** */
 310:../Generated_Code/IO1.c **** /*!
 311:../Generated_Code/IO1.c **** **     @brief
 312:../Generated_Code/IO1.c **** **         Specifies the number of data to receive. The method returns
 313:../Generated_Code/IO1.c **** **         ERR_BUSY until the specified number of characters is
 314:../Generated_Code/IO1.c **** **         received. Method <CancelBlockReception> can be used to
 315:../Generated_Code/IO1.c **** **         cancel a running receive operation.
 316:../Generated_Code/IO1.c **** **     @param
 317:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 318:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 319:../Generated_Code/IO1.c **** **     @param
 320:../Generated_Code/IO1.c **** **         BufferPtr       - Pointer to a buffer where
 321:../Generated_Code/IO1.c **** **                           received characters will be stored.
 322:../Generated_Code/IO1.c **** **     @param
 323:../Generated_Code/IO1.c **** **         Size            - Number of characters to receive
 324:../Generated_Code/IO1.c **** **     @return
 325:../Generated_Code/IO1.c **** **                         - Error code, possible codes:
 326:../Generated_Code/IO1.c **** **                           ERR_OK - OK
 327:../Generated_Code/IO1.c **** **                           ERR_SPEED - The component does not work in
 328:../Generated_Code/IO1.c **** **                           the active clock configuration.
 329:../Generated_Code/IO1.c **** **                           ERR_PARAM_SIZE - Parameter Size is out of
 330:../Generated_Code/IO1.c **** **                           expected range.
 331:../Generated_Code/IO1.c **** **                           ERR_DISABLED - The component or device is
 332:../Generated_Code/IO1.c **** **                           disabled.
 333:../Generated_Code/IO1.c **** **                           ERR_BUSY - The previous receive request is
 334:../Generated_Code/IO1.c **** **                           pending.
 335:../Generated_Code/IO1.c **** */
 336:../Generated_Code/IO1.c **** /* ===================================================================*/
 337:../Generated_Code/IO1.c **** LDD_TError IO1_ReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 338:../Generated_Code/IO1.c **** {
 498              		.loc 1 338 0
 499              		.cfi_startproc
 500 0000 80B5     		push	{r7, lr}
 501              	.LCFI15:
 502              		.cfi_def_cfa_offset 8
 503              		.cfi_offset 7, -8
 504              		.cfi_offset 14, -4
 505 0002 86B0     		sub	sp, sp, #24
 506              	.LCFI16:
 507              		.cfi_def_cfa_offset 32
 508 0004 00AF     		add	r7, sp, #0
 509              	.LCFI17:
 510              		.cfi_def_cfa_register 7
 511 0006 F860     		str	r0, [r7, #12]
 512 0008 B960     		str	r1, [r7, #8]
 513 000a BB1D     		add	r3, r7, #6
 514 000c 1A80     		strh	r2, [r3]
 339:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 515              		.loc 1 339 0
 516 000e FB68     		ldr	r3, [r7, #12]
 517 0010 7B61     		str	r3, [r7, #20]
 340:../Generated_Code/IO1.c **** 
 341:../Generated_Code/IO1.c ****   if (!DeviceDataPrv->EnUser) {        /* Is the device disabled by user? */
 518              		.loc 1 341 0
 519 0012 7B69     		ldr	r3, [r7, #20]
 520 0014 9B78     		ldrb	r3, [r3, #2]
 521 0016 002B     		cmp	r3, #0
 522 0018 01D1     		bne	.L22
 342:../Generated_Code/IO1.c ****     return ERR_DISABLED;               /* If yes then error */
 523              		.loc 1 342 0
 524 001a 0723     		mov	r3, #7
 525 001c 16E0     		b	.L23
 526              	.L22:
 343:../Generated_Code/IO1.c ****   }
 344:../Generated_Code/IO1.c ****   if (Size == 0U) {                    /* Is the parameter Size within an expected range? */
 527              		.loc 1 344 0
 528 001e BB1D     		add	r3, r7, #6
 529 0020 1B88     		ldrh	r3, [r3]
 530 0022 002B     		cmp	r3, #0
 531 0024 01D1     		bne	.L24
 345:../Generated_Code/IO1.c ****     return ERR_PARAM_SIZE;             /* If no then error */
 532              		.loc 1 345 0
 533 0026 8423     		mov	r3, #132
 534 0028 10E0     		b	.L23
 535              	.L24:
 346:../Generated_Code/IO1.c ****   }
 347:../Generated_Code/IO1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the previous receive operation pending? */
 536              		.loc 1 347 0
 537 002a 7B69     		ldr	r3, [r7, #20]
 538 002c 1B8A     		ldrh	r3, [r3, #16]
 539 002e 002B     		cmp	r3, #0
 540 0030 01D0     		beq	.L25
 348:../Generated_Code/IO1.c ****     return ERR_BUSY;                   /* If yes then error */
 541              		.loc 1 348 0
 542 0032 0823     		mov	r3, #8
 543 0034 0AE0     		b	.L23
 544              	.L25:
 349:../Generated_Code/IO1.c ****   }
 350:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataPtr = (uint8_t*)BufferPtr; /* Store a pointer to the input data. */
 545              		.loc 1 350 0
 546 0036 7B69     		ldr	r3, [r7, #20]
 547 0038 BA68     		ldr	r2, [r7, #8]
 548 003a DA60     		str	r2, [r3, #12]
 351:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataNumReq = Size; /* Store a number of characters to be received. */
 549              		.loc 1 351 0
 550 003c 7B69     		ldr	r3, [r7, #20]
 551 003e BA1D     		add	r2, r7, #6
 552 0040 1288     		ldrh	r2, [r2]
 553 0042 1A82     		strh	r2, [r3, #16]
 352:../Generated_Code/IO1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Set number of received characters to zero. */
 554              		.loc 1 352 0
 555 0044 7B69     		ldr	r3, [r7, #20]
 556 0046 0022     		mov	r2, #0
 557 0048 1A81     		strh	r2, [r3, #8]
 353:../Generated_Code/IO1.c ****   return ERR_OK;                       /* OK */
 558              		.loc 1 353 0
 559 004a 0023     		mov	r3, #0
 560              	.L23:
 354:../Generated_Code/IO1.c **** }
 561              		.loc 1 354 0
 562 004c 181C     		mov	r0, r3
 563 004e BD46     		mov	sp, r7
 564 0050 06B0     		add	sp, sp, #24
 565              		@ sp needed for prologue
 566 0052 80BD     		pop	{r7, pc}
 567              		.cfi_endproc
 568              	.LFE5:
 570              		.section	.text.IO1_SendBlock,"ax",%progbits
 571              		.align	2
 572              		.global	IO1_SendBlock
 573              		.code	16
 574              		.thumb_func
 576              	IO1_SendBlock:
 577              	.LFB6:
 355:../Generated_Code/IO1.c **** 
 356:../Generated_Code/IO1.c **** /*
 357:../Generated_Code/IO1.c **** ** ===================================================================
 358:../Generated_Code/IO1.c **** **     Method      :  IO1_SendBlock (component Serial_LDD)
 359:../Generated_Code/IO1.c **** */
 360:../Generated_Code/IO1.c **** /*!
 361:../Generated_Code/IO1.c **** **     @brief
 362:../Generated_Code/IO1.c **** **         Sends a block of characters. The method returns ERR_BUSY
 363:../Generated_Code/IO1.c **** **         when the previous block transmission is not completed.
 364:../Generated_Code/IO1.c **** **         Method <CancelBlockTransmission> can be used to cancel a
 365:../Generated_Code/IO1.c **** **         transmit operation. This method is available only if the
 366:../Generated_Code/IO1.c **** **         transmitter property is enabled.
 367:../Generated_Code/IO1.c **** **     @param
 368:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 369:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 370:../Generated_Code/IO1.c **** **     @param
 371:../Generated_Code/IO1.c **** **         BufferPtr       - Pointer to a buffer from where
 372:../Generated_Code/IO1.c **** **                           data will be sent.
 373:../Generated_Code/IO1.c **** **     @param
 374:../Generated_Code/IO1.c **** **         Size            - Number of characters in the buffer.
 375:../Generated_Code/IO1.c **** **     @return
 376:../Generated_Code/IO1.c **** **                         - Error code, possible codes:
 377:../Generated_Code/IO1.c **** **                           ERR_OK - OK
 378:../Generated_Code/IO1.c **** **                           ERR_SPEED - The component does not work in
 379:../Generated_Code/IO1.c **** **                           the active clock configuration.
 380:../Generated_Code/IO1.c **** **                           ERR_PARAM_SIZE - Parameter Size is out of
 381:../Generated_Code/IO1.c **** **                           expected range.
 382:../Generated_Code/IO1.c **** **                           ERR_DISABLED - The component or device is
 383:../Generated_Code/IO1.c **** **                           disabled.
 384:../Generated_Code/IO1.c **** **                           ERR_BUSY - The previous transmit request is
 385:../Generated_Code/IO1.c **** **                           pending.
 386:../Generated_Code/IO1.c **** */
 387:../Generated_Code/IO1.c **** /* ===================================================================*/
 388:../Generated_Code/IO1.c **** LDD_TError IO1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
 389:../Generated_Code/IO1.c **** {
 578              		.loc 1 389 0
 579              		.cfi_startproc
 580 0000 80B5     		push	{r7, lr}
 581              	.LCFI18:
 582              		.cfi_def_cfa_offset 8
 583              		.cfi_offset 7, -8
 584              		.cfi_offset 14, -4
 585 0002 86B0     		sub	sp, sp, #24
 586              	.LCFI19:
 587              		.cfi_def_cfa_offset 32
 588 0004 00AF     		add	r7, sp, #0
 589              	.LCFI20:
 590              		.cfi_def_cfa_register 7
 591 0006 F860     		str	r0, [r7, #12]
 592 0008 B960     		str	r1, [r7, #8]
 593 000a BB1D     		add	r3, r7, #6
 594 000c 1A80     		strh	r2, [r3]
 390:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 595              		.loc 1 390 0
 596 000e FB68     		ldr	r3, [r7, #12]
 597 0010 7B61     		str	r3, [r7, #20]
 391:../Generated_Code/IO1.c **** 
 392:../Generated_Code/IO1.c ****   if (!DeviceDataPrv->EnUser) {        /* Is the device disabled by user? */
 598              		.loc 1 392 0
 599 0012 7B69     		ldr	r3, [r7, #20]
 600 0014 9B78     		ldrb	r3, [r3, #2]
 601 0016 002B     		cmp	r3, #0
 602 0018 01D1     		bne	.L27
 393:../Generated_Code/IO1.c ****     return ERR_DISABLED;               /* If yes then error */
 603              		.loc 1 393 0
 604 001a 0723     		mov	r3, #7
 605 001c 1DE0     		b	.L28
 606              	.L27:
 394:../Generated_Code/IO1.c ****   }
 395:../Generated_Code/IO1.c ****   if (Size == 0U) {                    /* Is the parameter Size within an expected range? */
 607              		.loc 1 395 0
 608 001e BB1D     		add	r3, r7, #6
 609 0020 1B88     		ldrh	r3, [r3]
 610 0022 002B     		cmp	r3, #0
 611 0024 01D1     		bne	.L29
 396:../Generated_Code/IO1.c ****     return ERR_PARAM_SIZE;             /* If no then error */
 612              		.loc 1 396 0
 613 0026 8423     		mov	r3, #132
 614 0028 17E0     		b	.L28
 615              	.L29:
 397:../Generated_Code/IO1.c ****   }
 398:../Generated_Code/IO1.c ****   if (DeviceDataPrv->OutDataNumReq != 0x00U) { /* Is the previous transmit operation pending? */
 616              		.loc 1 398 0
 617 002a 7B69     		ldr	r3, [r7, #20]
 618 002c 1B8B     		ldrh	r3, [r3, #24]
 619 002e 002B     		cmp	r3, #0
 620 0030 01D0     		beq	.L30
 399:../Generated_Code/IO1.c ****     return ERR_BUSY;                   /* If yes then error */
 621              		.loc 1 399 0
 622 0032 0823     		mov	r3, #8
 623 0034 11E0     		b	.L28
 624              	.L30:
 400:../Generated_Code/IO1.c ****   }
 401:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataPtr = (uint8_t*)BufferPtr; /* Set a pointer to the output data. */
 625              		.loc 1 401 0
 626 0036 7B69     		ldr	r3, [r7, #20]
 627 0038 BA68     		ldr	r2, [r7, #8]
 628 003a 5A61     		str	r2, [r3, #20]
 402:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataNumReq = Size; /* Set the counter of characters to be sent. */
 629              		.loc 1 402 0
 630 003c 7B69     		ldr	r3, [r7, #20]
 631 003e BA1D     		add	r2, r7, #6
 632 0040 1288     		ldrh	r2, [r2]
 633 0042 1A83     		strh	r2, [r3, #24]
 403:../Generated_Code/IO1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters. */
 634              		.loc 1 403 0
 635 0044 7B69     		ldr	r3, [r7, #20]
 636 0046 0022     		mov	r2, #0
 637 0048 5A82     		strh	r2, [r3, #18]
 404:../Generated_Code/IO1.c ****   DeviceDataPrv->SerFlag |= ENABLED_TX_INT; /* Set the flag ENABLED_TX_INT */
 638              		.loc 1 404 0
 639 004a 7B69     		ldr	r3, [r7, #20]
 640 004c 1B88     		ldrh	r3, [r3]
 641 004e 0122     		mov	r2, #1
 642 0050 1343     		orr	r3, r2
 643 0052 9AB2     		uxth	r2, r3
 644 0054 7B69     		ldr	r3, [r7, #20]
 645 0056 1A80     		strh	r2, [r3]
 405:../Generated_Code/IO1.c ****   return ERR_OK;                       /* OK */
 646              		.loc 1 405 0
 647 0058 0023     		mov	r3, #0
 648              	.L28:
 406:../Generated_Code/IO1.c **** }
 649              		.loc 1 406 0
 650 005a 181C     		mov	r0, r3
 651 005c BD46     		mov	sp, r7
 652 005e 06B0     		add	sp, sp, #24
 653              		@ sp needed for prologue
 654 0060 80BD     		pop	{r7, pc}
 655              		.cfi_endproc
 656              	.LFE6:
 658 0062 C046     		.section	.text.InterruptRx,"ax",%progbits
 659              		.align	2
 660              		.code	16
 661              		.thumb_func
 663              	InterruptRx:
 664              	.LFB7:
 407:../Generated_Code/IO1.c **** 
 408:../Generated_Code/IO1.c **** /*
 409:../Generated_Code/IO1.c **** ** ===================================================================
 410:../Generated_Code/IO1.c **** **     Method      :  InterruptRx (component Serial_LDD)
 411:../Generated_Code/IO1.c **** **
 412:../Generated_Code/IO1.c **** **     Description :
 413:../Generated_Code/IO1.c **** **         The method services the receive interrupt of the selected 
 414:../Generated_Code/IO1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 415:../Generated_Code/IO1.c **** **         This method is internal. It is used by Processor Expert only.
 416:../Generated_Code/IO1.c **** ** ===================================================================
 417:../Generated_Code/IO1.c **** */
 418:../Generated_Code/IO1.c **** static void InterruptRx(IO1_TDeviceDataPtr DeviceDataPrv)
 419:../Generated_Code/IO1.c **** {
 665              		.loc 1 419 0
 666              		.cfi_startproc
 667 0000 90B5     		push	{r4, r7, lr}
 668              	.LCFI21:
 669              		.cfi_def_cfa_offset 12
 670              		.cfi_offset 4, -12
 671              		.cfi_offset 7, -8
 672              		.cfi_offset 14, -4
 673 0002 83B0     		sub	sp, sp, #12
 674              	.LCFI22:
 675              		.cfi_def_cfa_offset 24
 676 0004 00AF     		add	r7, sp, #0
 677              	.LCFI23:
 678              		.cfi_def_cfa_register 7
 679 0006 7860     		str	r0, [r7, #4]
 420:../Generated_Code/IO1.c ****   register uint16_t Data;              /* Temporary variable for data */
 421:../Generated_Code/IO1.c **** 
 422:../Generated_Code/IO1.c ****   Data = (uint16_t)UART0_PDD_GetChar8(UART0_BASE_PTR); /* Read an 8-bit character from the receiver
 680              		.loc 1 422 0
 681 0008 104B     		ldr	r3, .L33
 682 000a DB79     		ldrb	r3, [r3, #7]
 683 000c DBB2     		uxtb	r3, r3
 684 000e 1C1C     		mov	r4, r3
 423:../Generated_Code/IO1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 685              		.loc 1 423 0
 686 0010 7B68     		ldr	r3, [r7, #4]
 687 0012 1B8A     		ldrh	r3, [r3, #16]
 688 0014 002B     		cmp	r3, #0
 689 0016 15D0     		beq	.L31
 424:../Generated_Code/IO1.c ****     *(DeviceDataPrv->InpDataPtr++) = (uint8_t)Data; /* Put an 8-bit character to the receive buffer
 690              		.loc 1 424 0
 691 0018 7B68     		ldr	r3, [r7, #4]
 692 001a DB68     		ldr	r3, [r3, #12]
 693 001c E2B2     		uxtb	r2, r4
 694 001e 1A70     		strb	r2, [r3]
 695 0020 5A1C     		add	r2, r3, #1
 696 0022 7B68     		ldr	r3, [r7, #4]
 697 0024 DA60     		str	r2, [r3, #12]
 425:../Generated_Code/IO1.c ****     DeviceDataPrv->InpRecvDataNum++;   /* Increment received char. counter */
 698              		.loc 1 425 0
 699 0026 7B68     		ldr	r3, [r7, #4]
 700 0028 1B89     		ldrh	r3, [r3, #8]
 701 002a 0133     		add	r3, r3, #1
 702 002c 9AB2     		uxth	r2, r3
 703 002e 7B68     		ldr	r3, [r7, #4]
 704 0030 1A81     		strh	r2, [r3, #8]
 426:../Generated_Code/IO1.c ****     if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested number
 705              		.loc 1 426 0
 706 0032 7B68     		ldr	r3, [r7, #4]
 707 0034 1A89     		ldrh	r2, [r3, #8]
 708 0036 7B68     		ldr	r3, [r7, #4]
 709 0038 1B8A     		ldrh	r3, [r3, #16]
 710 003a 9A42     		cmp	r2, r3
 711 003c 02D1     		bne	.L31
 427:../Generated_Code/IO1.c ****       DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters to 
 712              		.loc 1 427 0
 713 003e 7B68     		ldr	r3, [r7, #4]
 714 0040 0022     		mov	r2, #0
 715 0042 1A82     		strh	r2, [r3, #16]
 716              	.L31:
 428:../Generated_Code/IO1.c ****     }
 429:../Generated_Code/IO1.c ****   }
 430:../Generated_Code/IO1.c **** }
 717              		.loc 1 430 0
 718 0044 BD46     		mov	sp, r7
 719 0046 03B0     		add	sp, sp, #12
 720              		@ sp needed for prologue
 721 0048 90BD     		pop	{r4, r7, pc}
 722              	.L34:
 723 004a C046     		.align	2
 724              	.L33:
 725 004c 00A00640 		.word	1074176000
 726              		.cfi_endproc
 727              	.LFE7:
 729              		.section	.text.InterruptTx,"ax",%progbits
 730              		.align	2
 731              		.code	16
 732              		.thumb_func
 734              	InterruptTx:
 735              	.LFB8:
 431:../Generated_Code/IO1.c **** 
 432:../Generated_Code/IO1.c **** /*
 433:../Generated_Code/IO1.c **** ** ===================================================================
 434:../Generated_Code/IO1.c **** **     Method      :  InterruptTx (component Serial_LDD)
 435:../Generated_Code/IO1.c **** **
 436:../Generated_Code/IO1.c **** **     Description :
 437:../Generated_Code/IO1.c **** **         The method services the receive interrupt of the selected 
 438:../Generated_Code/IO1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 439:../Generated_Code/IO1.c **** **         This method is internal. It is used by Processor Expert only.
 440:../Generated_Code/IO1.c **** ** ===================================================================
 441:../Generated_Code/IO1.c **** */
 442:../Generated_Code/IO1.c **** static void InterruptTx(IO1_TDeviceDataPtr DeviceDataPrv)
 443:../Generated_Code/IO1.c **** {
 736              		.loc 1 443 0
 737              		.cfi_startproc
 738 0000 80B5     		push	{r7, lr}
 739              	.LCFI24:
 740              		.cfi_def_cfa_offset 8
 741              		.cfi_offset 7, -8
 742              		.cfi_offset 14, -4
 743 0002 82B0     		sub	sp, sp, #8
 744              	.LCFI25:
 745              		.cfi_def_cfa_offset 16
 746 0004 00AF     		add	r7, sp, #0
 747              	.LCFI26:
 748              		.cfi_def_cfa_register 7
 749 0006 7860     		str	r0, [r7, #4]
 444:../Generated_Code/IO1.c **** 
 445:../Generated_Code/IO1.c ****   if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent characte
 750              		.loc 1 445 0
 751 0008 7B68     		ldr	r3, [r7, #4]
 752 000a 5A8A     		ldrh	r2, [r3, #18]
 753 000c 7B68     		ldr	r3, [r7, #4]
 754 000e 1B8B     		ldrh	r3, [r3, #24]
 755 0010 9A42     		cmp	r2, r3
 756 0012 17D2     		bcs	.L36
 446:../Generated_Code/IO1.c ****     UART0_PDD_PutChar8(UART0_BASE_PTR, *(DeviceDataPrv->OutDataPtr++)); /* Put a 8-bit character to
 757              		.loc 1 446 0
 758 0014 104A     		ldr	r2, .L38
 759 0016 7B68     		ldr	r3, [r7, #4]
 760 0018 5B69     		ldr	r3, [r3, #20]
 761 001a 1978     		ldrb	r1, [r3]
 762 001c D171     		strb	r1, [r2, #7]
 763 001e 5A1C     		add	r2, r3, #1
 764 0020 7B68     		ldr	r3, [r7, #4]
 765 0022 5A61     		str	r2, [r3, #20]
 447:../Generated_Code/IO1.c ****     DeviceDataPrv->OutSentDataNum++;   /* Increment the counter of sent characters. */
 766              		.loc 1 447 0
 767 0024 7B68     		ldr	r3, [r7, #4]
 768 0026 5B8A     		ldrh	r3, [r3, #18]
 769 0028 0133     		add	r3, r3, #1
 770 002a 9AB2     		uxth	r2, r3
 771 002c 7B68     		ldr	r3, [r7, #4]
 772 002e 5A82     		strh	r2, [r3, #18]
 448:../Generated_Code/IO1.c ****     if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 773              		.loc 1 448 0
 774 0030 7B68     		ldr	r3, [r7, #4]
 775 0032 5A8A     		ldrh	r2, [r3, #18]
 776 0034 7B68     		ldr	r3, [r7, #4]
 777 0036 1B8B     		ldrh	r3, [r3, #24]
 778 0038 9A42     		cmp	r2, r3
 779 003a 0AD1     		bne	.L35
 449:../Generated_Code/IO1.c ****       DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBl
 780              		.loc 1 449 0
 781 003c 7B68     		ldr	r3, [r7, #4]
 782 003e 0022     		mov	r2, #0
 783 0040 1A83     		strh	r2, [r3, #24]
 784 0042 06E0     		b	.L35
 785              	.L36:
 450:../Generated_Code/IO1.c ****     }
 451:../Generated_Code/IO1.c ****   } else {
 452:../Generated_Code/IO1.c ****     DeviceDataPrv->SerFlag &= (uint16_t)(~(uint16_t)ENABLED_TX_INT); /* Clear the flag ENABLED_TX_I
 786              		.loc 1 452 0
 787 0044 7B68     		ldr	r3, [r7, #4]
 788 0046 1B88     		ldrh	r3, [r3]
 789 0048 0122     		mov	r2, #1
 790 004a 9343     		bic	r3, r2
 791 004c 9AB2     		uxth	r2, r3
 792 004e 7B68     		ldr	r3, [r7, #4]
 793 0050 1A80     		strh	r2, [r3]
 794              	.L35:
 453:../Generated_Code/IO1.c ****   }
 454:../Generated_Code/IO1.c **** }
 795              		.loc 1 454 0
 796 0052 BD46     		mov	sp, r7
 797 0054 02B0     		add	sp, sp, #8
 798              		@ sp needed for prologue
 799 0056 80BD     		pop	{r7, pc}
 800              	.L39:
 801              		.align	2
 802              	.L38:
 803 0058 00A00640 		.word	1074176000
 804              		.cfi_endproc
 805              	.LFE8:
 807              		.section	.text.IO1_Main,"ax",%progbits
 808              		.align	2
 809              		.global	IO1_Main
 810              		.code	16
 811              		.thumb_func
 813              	IO1_Main:
 814              	.LFB9:
 455:../Generated_Code/IO1.c **** 
 456:../Generated_Code/IO1.c **** /*
 457:../Generated_Code/IO1.c **** ** ===================================================================
 458:../Generated_Code/IO1.c **** **     Method      :  IO1_Main (component Serial_LDD)
 459:../Generated_Code/IO1.c **** */
 460:../Generated_Code/IO1.c **** /*!
 461:../Generated_Code/IO1.c **** **     @brief
 462:../Generated_Code/IO1.c **** **         This method is available only in the polling mode (Interrupt
 463:../Generated_Code/IO1.c **** **         service/event = 'no'). If interrupt service is disabled this
 464:../Generated_Code/IO1.c **** **         method replaces the interrupt handler. This method should be
 465:../Generated_Code/IO1.c **** **         called if Receive/SendBlock was invoked before in order to
 466:../Generated_Code/IO1.c **** **         run the reception/transmission. The end of the
 467:../Generated_Code/IO1.c **** **         receiving/transmitting is indicated by OnBlockSent or
 468:../Generated_Code/IO1.c **** **         OnBlockReceived event. 
 469:../Generated_Code/IO1.c **** **     @param
 470:../Generated_Code/IO1.c **** **         DeviceDataPtr   - Device data structure
 471:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 472:../Generated_Code/IO1.c **** */
 473:../Generated_Code/IO1.c **** /* ===================================================================*/
 474:../Generated_Code/IO1.c **** void IO1_Main(LDD_TDeviceData *DeviceDataPtr)
 475:../Generated_Code/IO1.c **** {
 815              		.loc 1 475 0
 816              		.cfi_startproc
 817 0000 90B5     		push	{r4, r7, lr}
 818              	.LCFI27:
 819              		.cfi_def_cfa_offset 12
 820              		.cfi_offset 4, -12
 821              		.cfi_offset 7, -8
 822              		.cfi_offset 14, -4
 823 0002 85B0     		sub	sp, sp, #20
 824              	.LCFI28:
 825              		.cfi_def_cfa_offset 32
 826 0004 00AF     		add	r7, sp, #0
 827              	.LCFI29:
 828              		.cfi_def_cfa_register 7
 829 0006 7860     		str	r0, [r7, #4]
 476:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 830              		.loc 1 476 0
 831 0008 7B68     		ldr	r3, [r7, #4]
 832 000a FB60     		str	r3, [r7, #12]
 477:../Generated_Code/IO1.c ****   register uint16_t StatReg = UART0_PDD_ReadInterruptStatusReg(UART0_BASE_PTR); /* Read status regi
 833              		.loc 1 477 0
 834 000c 154B     		ldr	r3, .L44
 835 000e 1B79     		ldrb	r3, [r3, #4]
 836 0010 DBB2     		uxtb	r3, r3
 837 0012 1C1C     		mov	r4, r3
 478:../Generated_Code/IO1.c **** 
 479:../Generated_Code/IO1.c ****   if (StatReg & (UART0_S1_NF_MASK | UART0_S1_OR_MASK | UART0_S1_FE_MASK | UART0_S1_PF_MASK)) { /* I
 838              		.loc 1 479 0
 839 0014 221C     		mov	r2, r4
 840 0016 0F23     		mov	r3, #15
 841 0018 1340     		and	r3, r2
 842 001a 09D0     		beq	.L41
 480:../Generated_Code/IO1.c ****     UART0_PDD_ClearInterruptFlags(UART0_BASE_PTR, (UART0_S1_NF_MASK | UART0_S1_OR_MASK | UART0_S1_F
 843              		.loc 1 480 0
 844 001c 114B     		ldr	r3, .L44
 845 001e 0F22     		mov	r2, #15
 846 0020 1A71     		strb	r2, [r3, #4]
 481:../Generated_Code/IO1.c ****     (void)UART0_PDD_GetChar8(UART0_BASE_PTR); /* Dummy read 8-bit character from receiver */
 847              		.loc 1 481 0
 848 0022 104B     		ldr	r3, .L44
 849 0024 DB79     		ldrb	r3, [r3, #7]
 482:../Generated_Code/IO1.c ****     StatReg &= (uint16_t)(~(uint16_t)UART0_S1_RDRF_MASK); /* Clear the receive data flag to discard
 850              		.loc 1 482 0
 851 0026 2023     		mov	r3, #32
 852 0028 221C     		mov	r2, r4
 853 002a 9A43     		bic	r2, r3
 854 002c 131C     		mov	r3, r2
 855 002e 9CB2     		uxth	r4, r3
 856              	.L41:
 483:../Generated_Code/IO1.c ****   }
 484:../Generated_Code/IO1.c ****   if (StatReg & UART0_S1_RDRF_MASK) {  /* Is the receiver's interrupt flag set? */
 857              		.loc 1 484 0
 858 0030 221C     		mov	r2, r4
 859 0032 2023     		mov	r3, #32
 860 0034 1340     		and	r3, r2
 861 0036 03D0     		beq	.L42
 485:../Generated_Code/IO1.c ****     InterruptRx(DeviceDataPrv);        /* If yes, then invoke the internal service routine. This ro
 862              		.loc 1 485 0
 863 0038 FB68     		ldr	r3, [r7, #12]
 864 003a 181C     		mov	r0, r3
 865 003c FFF7FEFF 		bl	InterruptRx
 866              	.L42:
 486:../Generated_Code/IO1.c ****   }
 487:../Generated_Code/IO1.c ****   if (DeviceDataPrv->SerFlag & ENABLED_TX_INT) { /* Is the transmitter interrupt enabled? */
 867              		.loc 1 487 0
 868 0040 FB68     		ldr	r3, [r7, #12]
 869 0042 1B88     		ldrh	r3, [r3]
 870 0044 1A1C     		mov	r2, r3
 871 0046 0123     		mov	r3, #1
 872 0048 1340     		and	r3, r2
 873 004a 07D0     		beq	.L40
 488:../Generated_Code/IO1.c ****     if (StatReg & UART0_S1_TDRE_MASK) { /* Is the transmitter empty? */
 874              		.loc 1 488 0
 875 004c 221C     		mov	r2, r4
 876 004e 8023     		mov	r3, #128
 877 0050 1340     		and	r3, r2
 878 0052 03D0     		beq	.L40
 489:../Generated_Code/IO1.c ****       InterruptTx(DeviceDataPrv);      /* If yes, then invoke the internal service routine. This ro
 879              		.loc 1 489 0
 880 0054 FB68     		ldr	r3, [r7, #12]
 881 0056 181C     		mov	r0, r3
 882 0058 FFF7FEFF 		bl	InterruptTx
 883              	.L40:
 490:../Generated_Code/IO1.c ****     }
 491:../Generated_Code/IO1.c ****   }
 492:../Generated_Code/IO1.c **** }
 884              		.loc 1 492 0
 885 005c BD46     		mov	sp, r7
 886 005e 05B0     		add	sp, sp, #20
 887              		@ sp needed for prologue
 888 0060 90BD     		pop	{r4, r7, pc}
 889              	.L45:
 890 0062 C046     		.align	2
 891              	.L44:
 892 0064 00A00640 		.word	1074176000
 893              		.cfi_endproc
 894              	.LFE9:
 896              		.text
 897              	.Letext0:
 898              		.file 2 "E:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 899              		.file 3 "../Generated_Code/PE_Types.h"
 900              		.file 4 "../Generated_Code/IO_Map.h"
 901              		.file 5 "../Generated_Code/IO1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IO1.c
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:24     .text.IO1_Init:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:29     .text.IO1_Init:00000000 IO1_Init
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:239    .text.IO1_Init:00000148 $d
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:252    .text.IO1_Enable:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:257    .text.IO1_Enable:00000000 IO1_Enable
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:319    .text.IO1_Enable:0000004c $d
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:324    .text.IO1_Disable:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:329    .text.IO1_Disable:00000000 IO1_Disable
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:387    .text.IO1_Disable:00000044 $d
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:392    .text.IO1_GetEventMask:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:397    .text.IO1_GetEventMask:00000000 IO1_GetEventMask
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:432    .text.IO1_SetEventMask:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:437    .text.IO1_SetEventMask:00000000 IO1_SetEventMask
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:491    .text.IO1_ReceiveBlock:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:496    .text.IO1_ReceiveBlock:00000000 IO1_ReceiveBlock
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:571    .text.IO1_SendBlock:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:576    .text.IO1_SendBlock:00000000 IO1_SendBlock
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:659    .text.InterruptRx:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:663    .text.InterruptRx:00000000 InterruptRx
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:725    .text.InterruptRx:0000004c $d
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:730    .text.InterruptTx:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:734    .text.InterruptTx:00000000 InterruptTx
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:803    .text.InterruptTx:00000058 $d
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:808    .text.IO1_Main:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:813    .text.IO1_Main:00000000 IO1_Main
C:\Users\lab\AppData\Local\Temp\ccVtXe92.s:892    .text.IO1_Main:00000064 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList

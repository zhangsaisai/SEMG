   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"mcg.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_idiv
  18              		.section	.text.pll_init,"ax",%progbits
  19              		.align	2
  20              		.global	pll_init
  21              		.code	16
  22              		.thumb_func
  24              	pll_init:
  25              	.LFB0:
  26              		.file 1 "D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-s
   1:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /*
   2:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * File:    mcg.c
   3:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
   4:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * MCG drivers for Freescale Kinetis L - series devices
   5:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Notes:
   6:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Assumes the MCG mode is in the default FEI mode out of reset
   7:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
   8:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
   9:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** #include "common.h"
  10:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** #include "mcg.h"
  11:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  12:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  13:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // global variables
  14:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** extern int core_clk_khz;
  15:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  16:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  17:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** char drs_val, dmx32_val;
  18:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  19:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  20:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  21:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  22:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  23:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /*********************************************************************************************/
  24:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : pll_init
  25:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
  26:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
  27:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
  28:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function initializess PLL0. Either OSC0 is selected for the
  29:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * reference clock source. The oscillators can be configured to use a crystal or take in an
  30:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * external square wave clock.
  31:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
  32:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
  33:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
  34:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * All parameters must be provided, for example crystal_val must be provided even if the
  35:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * oscillator associated with that parameter is already initialized.
  36:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
  37:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
  38:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
  39:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
  40:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
  41:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
  42:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           wave clock source
  43:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
  44:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           for the crystal oscillator. This has no meaning if an
  45:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           external clock is used.
  46:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
  47:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
  48:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           PLL reference clock frequency
  49:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
  50:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
  51:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                              to provide the MCGOUT clock for the system.
  52:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
  53:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : PLL frequency (Hz) or error code
  54:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
  55:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  56:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val
  57:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
  27              		.loc 1 57 0
  28              		.cfi_startproc
  29              	.LVL0:
  30 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 24
  33              		.cfi_offset 3, -24
  34              		.cfi_offset 4, -20
  35              		.cfi_offset 5, -16
  36              		.cfi_offset 6, -12
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 5746     		mov	r7, sl
  40 0004 4E46     		mov	r6, r9
  41 0006 C0B4     		push	{r6, r7}
  42              	.LCFI1:
  43              		.cfi_def_cfa_offset 32
  44              		.cfi_offset 9, -32
  45              		.cfi_offset 10, -28
  58:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char frdiv_val;
  59:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
  60:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char prdiv, vdiv;
  61:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
  62:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int ref_freq;
  63:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int pll_freq;
  64:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  65:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check if in FEI mode
  66:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  46              		.loc 1 66 0
  47 0008 924C     		ldr	r4, .L90
  57:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
  48              		.loc 1 57 0
  49 000a 151C     		mov	r5, r2
  50 000c 08AA     		add	r2, sp, #32
  51              	.LVL1:
  52 000e 071C     		mov	r7, r0
  53              		.loc 1 66 0
  54 0010 A679     		ldrb	r6, [r4, #6]
  57:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
  55              		.loc 1 57 0
  56 0012 1078     		ldrb	r0, [r2]
  57              	.LVL2:
  58 0014 8A46     		mov	sl, r1
  59              		.loc 1 66 0
  60 0016 3207     		lsl	r2, r6, #28
  57:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
  61              		.loc 1 57 0
  62 0018 41B2     		sxtb	r1, r0
  63              	.LVL3:
  64 001a 8946     		mov	r9, r1
  67:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
  68:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
  69:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
  70:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                     // return error code
  65              		.loc 1 70 0
  66 001c 0120     		mov	r0, #1
  66:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  67              		.loc 1 66 0
  68 001e 910F     		lsr	r1, r2, #30
  69 0020 09D1     		bne	.L2
  67:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
  70              		.loc 1 67 0
  71 0022 A679     		ldrb	r6, [r4, #6]
  66:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  72              		.loc 1 66 0
  73 0024 F106     		lsl	r1, r6, #27
  74 0026 06D5     		bpl	.L2
  68:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
  75              		.loc 1 68 0
  76 0028 A479     		ldrb	r4, [r4, #6]
  66:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
  77              		.loc 1 66 0
  78 002a A106     		lsl	r1, r4, #26
  79 002c 03D4     		bmi	.L2
  71:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
  72:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  73:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check external frequency is less than the maximum frequency
  74:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
  80              		.loc 1 74 0
  81 002e 8A4A     		ldr	r2, .L90+4
  82 0030 2120     		mov	r0, #33
  83 0032 9742     		cmp	r7, r2
  84 0034 03DD     		ble	.L82
  85              	.LVL4:
  86              	.L2:
  75:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  76:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check crystal frequency is within spec. if crystal osc is being used as PLL ref
  77:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
  78:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
  79:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of t
  80:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
  81:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  82:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // make sure HGO will never be greater than 1. Could return an error instead if desired.
  83:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (hgo_val > 0)
  84:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
  85:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
  86:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
  87:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  88:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check PLL divider settings are within spec.
  89:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
  90:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
  91:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  92:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check PLL reference clock frequency is within spec.
  93:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   ref_freq = crystal_val / prdiv_val;
  94:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
  95:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
  96:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check PLL output frequency is within spec.
  97:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
  98:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
  99:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 100:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // configure the MCG_C2 register
 101:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the
 102:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // it still needs to be set correctly even if the oscillator is not being used
 103:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       
 104:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 105:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 106:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     
 107:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 8000000)
 108:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 109:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 110:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 111:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 112:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 113:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 114:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 115:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 116:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 117:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // determine FRDIV based on reference clock frequency
 118:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // since the external frequency has already been checked only the maximum frequency for each FRDI
 119:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 120:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 121:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 122:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 123:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 124:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
 125:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 126:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Select external oscillator and Reference Divider and clear IREFS to start ext osc
 127:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // If IRCLK is required it must be enabled outside of this driver, existing state will be maintai
 128:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 129:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 130:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 131:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 132:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 133:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 134:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // if the external oscillator is used need to wait for OSCINIT to set
 135:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 136:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 137:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 20000 ; i++)
 138:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
 139:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 140:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
 141:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error
 142:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 143:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 144:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // wait for Reference clock Status bit to clear
 145:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 146:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 147:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 148:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 149:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 150:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 151:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for clock status bits to show clock source is ext ref clk
 152:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 153:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 154:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 155:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 156:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 157:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 158:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now in FBE
 159:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // It is recommended that the clock monitor is enabled when using an external clock as the clock 
 160:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // It is enabled here but can be removed if this is not required.
 161:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 162:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 163:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure PLL
 164:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure MCG_C5
 165:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 166:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 167:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 168:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 169:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 170:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 171:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure MCG_C6
 172:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 173:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 174:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 175:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 176:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 177:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 178:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 179:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // wait for PLLST status bit to set
 180:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 181:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 182:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 183:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 184:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 185:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for LOCK bit to set
 187:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 188:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 189:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 190:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 191:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 192:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 193:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Use actual PLL settings to calculate PLL frequency
 194:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 195:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 196:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 197:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // now in PBE
 198:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 199:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 200:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 201:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for clock status bits to update
 202:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 203:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 204:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 205:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 206:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 207:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 208:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now in PEE
 209:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 210:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 211:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // pll_init
  87              		.loc 1 211 0
  88              		@ sp needed for prologue
  89              	.LVL5:
  90 0036 0CBC     		pop	{r2, r3}
  91 0038 9146     		mov	r9, r2
  92 003a 9A46     		mov	sl, r3
  93 003c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
  94              	.LVL6:
  95              	.L82:
  77:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
  96              		.loc 1 77 0
  97 003e 002D     		cmp	r5, #0
  98 0040 00D0     		beq	.LCB94
  99 0042 E0E0     		b	.L83	@long jump
 100              	.LCB94:
 101              	.L3:
 102              	.LVL7:
  89:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 103              		.loc 1 89 0
 104 0044 5C1E     		sub	r4, r3, #1
 105 0046 E4B2     		uxtb	r4, r4
 106 0048 4120     		mov	r0, #65
 107 004a 182C     		cmp	r4, #24
 108 004c F3D8     		bhi	.L2
  90:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 109              		.loc 1 90 0
 110 004e 4A46     		mov	r2, r9
 111 0050 183A     		sub	r2, r2, #24
 112 0052 D6B2     		uxtb	r6, r2
 113 0054 4220     		mov	r0, #66
 114 0056 1A2E     		cmp	r6, #26
 115 0058 EDD8     		bhi	.L2
  93:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   ref_freq = crystal_val / prdiv_val;
 116              		.loc 1 93 0
 117 005a 191C     		mov	r1, r3
 118 005c 381C     		mov	r0, r7
 119 005e FFF7FEFF 		bl	__aeabi_idiv
 120              	.LVL8:
  94:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 121              		.loc 1 94 0
 122 0062 7E4B     		ldr	r3, .L90+8
  93:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   ref_freq = crystal_val / prdiv_val;
 123              		.loc 1 93 0
 124 0064 011C     		mov	r1, r0
 125              	.LVL9:
  94:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 126              		.loc 1 94 0
 127 0066 C218     		add	r2, r0, r3
 128 0068 7D4B     		ldr	r3, .L90+12
 129 006a 4320     		mov	r0, #67
 130              	.LVL10:
 131 006c 9A42     		cmp	r2, r3
 132 006e E2D8     		bhi	.L2
 133              	.LVL11:
  97:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 134              		.loc 1 97 0
 135 0070 4846     		mov	r0, r9
 136 0072 4843     		mul	r0, r1
  98:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 137              		.loc 1 98 0
 138 0074 7B49     		ldr	r1, .L90+16
 139              	.LVL12:
 140 0076 7C4B     		ldr	r3, .L90+20
 141 0078 4218     		add	r2, r0, r1
 142              	.LVL13:
 143 007a 4520     		mov	r0, #69
 144 007c 9A42     		cmp	r2, r3
 145 007e DAD8     		bhi	.L2
  85:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 146              		.loc 1 85 0
 147 0080 5246     		mov	r2, sl
 148 0082 531E     		sub	r3, r2, #1
 149 0084 9A41     		sbc	r2, r2, r3
 104:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 150              		.loc 1 104 0
 151 0086 734B     		ldr	r3, .L90
 105:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 152              		.loc 1 105 0
 153 0088 3C20     		mov	r0, #60
 104:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 154              		.loc 1 104 0
 155 008a 5978     		ldrb	r1, [r3, #1]
 156              	.LVL14:
 105:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 157              		.loc 1 105 0
 158 008c 8143     		bic	r1, r0
 159              	.LVL15:
 107:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 8000000)
 160              		.loc 1 107 0
 161 008e 7748     		ldr	r0, .L90+24
 162 0090 8742     		cmp	r7, r0
 163 0092 00DD     		ble	.LCB151
 164 0094 BFE0     		b	.L4	@long jump
 165              	.LCB151:
 109:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 166              		.loc 1 109 0
 167 0096 1020     		mov	r0, #16
 168 0098 0143     		orr	r1, r0
 169              	.LVL16:
 170 009a A800     		lsl	r0, r5, #2
 171 009c 0143     		orr	r1, r0
 172 009e C9B2     		uxtb	r1, r1
 173 00a0 D200     		lsl	r2, r2, #3
 119:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 174              		.loc 1 119 0
 175 00a2 7348     		ldr	r0, .L90+28
 109:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 176              		.loc 1 109 0
 177 00a4 0A43     		orr	r2, r1
 178              	.LVL17:
 115:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 179              		.loc 1 115 0
 180 00a6 5A70     		strb	r2, [r3, #1]
 119:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 181              		.loc 1 119 0
 182 00a8 0023     		mov	r3, #0
 183 00aa 8742     		cmp	r7, r0
 184 00ac 00DD     		ble	.LCB166
 185 00ae CBE0     		b	.L84	@long jump
 186              	.LCB166:
 187              	.LVL18:
 188              	.L5:
 129:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 189              		.loc 1 129 0
 190 00b0 6849     		ldr	r1, .L90
 130:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 191              		.loc 1 130 0
 192 00b2 0322     		mov	r2, #3
 129:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 193              		.loc 1 129 0
 194 00b4 0878     		ldrb	r0, [r1]
 195              	.LVL19:
 131:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 196              		.loc 1 131 0
 197 00b6 DB00     		lsl	r3, r3, #3
 198              	.LVL20:
 130:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 199              		.loc 1 130 0
 200 00b8 1040     		and	r0, r2
 201              	.LVL21:
 131:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 202              		.loc 1 131 0
 203 00ba 8022     		mov	r2, #128
 204 00bc 0243     		orr	r2, r0
 205 00be 1343     		orr	r3, r2
 206              	.LVL22:
 132:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 207              		.loc 1 132 0
 208 00c0 0B70     		strb	r3, [r1]
 135:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 209              		.loc 1 135 0
 210 00c2 002D     		cmp	r5, #0
 211 00c4 13D0     		beq	.L8
 212 00c6 6B4A     		ldr	r2, .L90+32
 139:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 213              		.loc 1 139 0
 214 00c8 0225     		mov	r5, #2
 215 00ca 08E0     		b	.L10
 216              	.LVL23:
 217              	.L85:
 218 00cc 8B79     		ldrb	r3, [r1, #6]
 219 00ce 013A     		sub	r2, r2, #1
 220 00d0 92B2     		uxth	r2, r2
 221 00d2 1D42     		tst	r5, r3
 222 00d4 06D1     		bne	.L9
 223 00d6 013A     		sub	r2, r2, #1
 224 00d8 92B2     		uxth	r2, r2
 137:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 20000 ; i++)
 225              		.loc 1 137 0
 226 00da 002A     		cmp	r2, #0
 227 00dc 02D0     		beq	.L9
 228              	.L10:
 139:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 229              		.loc 1 139 0
 230 00de 8879     		ldrb	r0, [r1, #6]
 231 00e0 0542     		tst	r5, r0
 232 00e2 F3D0     		beq	.L85
 233              	.L9:
 141:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error
 234              		.loc 1 141 0
 235 00e4 5B49     		ldr	r1, .L90
 236 00e6 2320     		mov	r0, #35
 237 00e8 8D79     		ldrb	r5, [r1, #6]
 238 00ea AA07     		lsl	r2, r5, #30
 239 00ec A3D5     		bpl	.L2
 240              	.L8:
 147:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 241              		.loc 1 147 0
 242 00ee 594A     		ldr	r2, .L90
 243 00f0 1021     		mov	r1, #16
 244 00f2 9079     		ldrb	r0, [r2, #6]
 245 00f4 0142     		tst	r1, r0
 246 00f6 11D0     		beq	.L11
 247 00f8 9579     		ldrb	r5, [r2, #6]
 248 00fa 5F4B     		ldr	r3, .L90+36
 249 00fc 2942     		tst	r1, r5
 250 00fe 0DD0     		beq	.L11
 251 0100 013B     		sub	r3, r3, #1
 252 0102 08E0     		b	.L49
 253              	.L86:
 254 0104 9579     		ldrb	r5, [r2, #6]
 255 0106 013B     		sub	r3, r3, #1
 256 0108 9BB2     		uxth	r3, r3
 257 010a 2942     		tst	r1, r5
 258 010c 06D0     		beq	.L11
 259 010e 013B     		sub	r3, r3, #1
 260 0110 9BB2     		uxth	r3, r3
 145:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 261              		.loc 1 145 0
 262 0112 002B     		cmp	r3, #0
 263 0114 02D0     		beq	.L11
 264              	.L49:
 147:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 265              		.loc 1 147 0
 266 0116 9079     		ldrb	r0, [r2, #6]
 267 0118 0142     		tst	r1, r0
 268 011a F3D1     		bne	.L86
 269              	.L11:
 149:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 270              		.loc 1 149 0
 271 011c 4D49     		ldr	r1, .L90
 272 011e 1120     		mov	r0, #17
 273 0120 8A79     		ldrb	r2, [r1, #6]
 274 0122 D206     		lsl	r2, r2, #27
 275 0124 00D5     		bpl	.LCB300
 276 0126 86E7     		b	.L2	@long jump
 277              	.LCB300:
 278 0128 FA20     		mov	r0, #250
 279 012a C300     		lsl	r3, r0, #3
 154:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 280              		.loc 1 154 0
 281 012c 0C25     		mov	r5, #12
 282 012e 09E0     		b	.L13
 283              	.L87:
 284 0130 8879     		ldrb	r0, [r1, #6]
 285 0132 013B     		sub	r3, r3, #1
 286 0134 9BB2     		uxth	r3, r3
 287 0136 2840     		and	r0, r5
 288 0138 0828     		cmp	r0, #8
 289 013a 07D0     		beq	.L12
 290 013c 013B     		sub	r3, r3, #1
 291 013e 9BB2     		uxth	r3, r3
 152:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 292              		.loc 1 152 0
 293 0140 002B     		cmp	r3, #0
 294 0142 03D0     		beq	.L12
 295              	.L13:
 154:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 296              		.loc 1 154 0
 297 0144 8A79     		ldrb	r2, [r1, #6]
 298 0146 2A40     		and	r2, r5
 299 0148 082A     		cmp	r2, #8
 300 014a F1D1     		bne	.L87
 301              	.L12:
 156:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 302              		.loc 1 156 0
 303 014c 414D     		ldr	r5, .L90
 304 014e 1A20     		mov	r0, #26
 305 0150 A979     		ldrb	r1, [r5, #6]
 306 0152 0A07     		lsl	r2, r1, #28
 307 0154 930F     		lsr	r3, r2, #30
 308 0156 022B     		cmp	r3, #2
 309 0158 00D0     		beq	.LCB345
 310 015a 6CE7     		b	.L2	@long jump
 311              	.LCB345:
 161:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 312              		.loc 1 161 0
 313 015c 6879     		ldrb	r0, [r5, #5]
 314 015e 2021     		mov	r1, #32
 315 0160 0843     		orr	r0, r1
 316 0162 6871     		strb	r0, [r5, #5]
 166:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 317              		.loc 1 166 0
 318 0164 2B79     		ldrb	r3, [r5, #4]
 319              	.LVL24:
 167:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 320              		.loc 1 167 0
 321 0166 1F22     		mov	r2, #31
 322 0168 9343     		bic	r3, r2
 323              	.LVL25:
 168:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 324              		.loc 1 168 0
 325 016a 1C43     		orr	r4, r3
 326              	.LVL26:
 169:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 327              		.loc 1 169 0
 328 016c 2C71     		strb	r4, [r5, #4]
 174:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 329              		.loc 1 174 0
 330 016e 6C79     		ldrb	r4, [r5, #5]
 331              	.LVL27:
 176:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 332              		.loc 1 176 0
 333 0170 4020     		mov	r0, #64
 175:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 334              		.loc 1 175 0
 335 0172 9443     		bic	r4, r2
 336              	.LVL28:
 337 0174 231C     		mov	r3, r4
 176:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 338              		.loc 1 176 0
 339 0176 0343     		orr	r3, r0
 340 0178 1E43     		orr	r6, r3
 341              	.LVL29:
 177:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 342              		.loc 1 177 0
 343 017a 6E71     		strb	r6, [r5, #5]
 344              	.LVL30:
 345 017c FA26     		mov	r6, #250
 346              	.LVL31:
 347 017e F200     		lsl	r2, r6, #3
 348 0180 03E0     		b	.L15
 349              	.LVL32:
 350              	.L88:
 351 0182 013A     		sub	r2, r2, #1
 352 0184 92B2     		uxth	r2, r2
 180:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 353              		.loc 1 180 0
 354 0186 002A     		cmp	r2, #0
 355 0188 02D0     		beq	.L14
 356              	.L15:
 182:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 357              		.loc 1 182 0
 358 018a AC79     		ldrb	r4, [r5, #6]
 359 018c 0C42     		tst	r4, r1
 360 018e F8D0     		beq	.L88
 361              	.L14:
 184:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 362              		.loc 1 184 0
 363 0190 304D     		ldr	r5, .L90
 364 0192 1620     		mov	r0, #22
 365 0194 A979     		ldrb	r1, [r5, #6]
 366 0196 8906     		lsl	r1, r1, #26
 367 0198 00D4     		bmi	.LCB416
 368 019a 4CE7     		b	.L2	@long jump
 369              	.LCB416:
 370 019c FA23     		mov	r3, #250
 371              	.LVL33:
 372 019e 1C01     		lsl	r4, r3, #4
 189:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 373              		.loc 1 189 0
 374 01a0 4026     		mov	r6, #64
 375 01a2 03E0     		b	.L17
 376              	.L89:
 377 01a4 013C     		sub	r4, r4, #1
 378 01a6 A4B2     		uxth	r4, r4
 187:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 379              		.loc 1 187 0
 380 01a8 002C     		cmp	r4, #0
 381 01aa 02D0     		beq	.L16
 382              	.L17:
 189:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 383              		.loc 1 189 0
 384 01ac A879     		ldrb	r0, [r5, #6]
 385 01ae 3042     		tst	r0, r6
 386 01b0 F8D0     		beq	.L89
 387              	.L16:
 191:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 388              		.loc 1 191 0
 389 01b2 284B     		ldr	r3, .L90
 390 01b4 4420     		mov	r0, #68
 391 01b6 9A79     		ldrb	r2, [r3, #6]
 392 01b8 5106     		lsl	r1, r2, #25
 393 01ba 00D4     		bmi	.LCB451
 394 01bc 3BE7     		b	.L2	@long jump
 395              	.LCB451:
 194:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 396              		.loc 1 194 0
 397 01be 1979     		ldrb	r1, [r3, #4]
 195:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 398              		.loc 1 195 0
 399 01c0 5E79     		ldrb	r6, [r3, #5]
 194:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 400              		.loc 1 194 0
 401 01c2 1F25     		mov	r5, #31
 199:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 402              		.loc 1 199 0
 403 01c4 1878     		ldrb	r0, [r3]
 194:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 404              		.loc 1 194 0
 405 01c6 2940     		and	r1, r5
 199:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 406              		.loc 1 199 0
 407 01c8 3F22     		mov	r2, #63
 195:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 408              		.loc 1 195 0
 409 01ca 3540     		and	r5, r6
 410 01cc 2C1C     		mov	r4, r5
 199:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 411              		.loc 1 199 0
 412 01ce 0240     		and	r2, r0
 413 01d0 FA25     		mov	r5, #250
 414 01d2 1A70     		strb	r2, [r3]
 194:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 415              		.loc 1 194 0
 416 01d4 0131     		add	r1, r1, #1
 417              	.LVL34:
 195:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 418              		.loc 1 195 0
 419 01d6 1834     		add	r4, r4, #24
 420              	.LVL35:
 199:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 421              		.loc 1 199 0
 422 01d8 EA00     		lsl	r2, r5, #3
 204:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 423              		.loc 1 204 0
 424 01da 0C26     		mov	r6, #12
 425              	.LVL36:
 426              	.L19:
 427 01dc 9879     		ldrb	r0, [r3, #6]
 428 01de 3040     		and	r0, r6
 429 01e0 0C28     		cmp	r0, #12
 430 01e2 03D0     		beq	.L18
 431 01e4 013A     		sub	r2, r2, #1
 432 01e6 92B2     		uxth	r2, r2
 202:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 433              		.loc 1 202 0
 434 01e8 002A     		cmp	r2, #0
 435 01ea F7D1     		bne	.L19
 436              	.L18:
 206:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 437              		.loc 1 206 0
 438 01ec 194B     		ldr	r3, .L90
 439 01ee 1B20     		mov	r0, #27
 440 01f0 9D79     		ldrb	r5, [r3, #6]
 441 01f2 2E07     		lsl	r6, r5, #28
 442 01f4 B20F     		lsr	r2, r6, #30
 443 01f6 032A     		cmp	r2, #3
 444 01f8 00D0     		beq	.LCB509
 445 01fa 1CE7     		b	.L2	@long jump
 446              	.LCB509:
 210:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 447              		.loc 1 210 0
 448 01fc 381C     		mov	r0, r7
 449 01fe FFF7FEFF 		bl	__aeabi_idiv
 450              	.LVL37:
 451 0202 6043     		mul	r0, r4
 452 0204 17E7     		b	.L2
 453              	.LVL38:
 454              	.L83:
  79:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of t
 455              		.loc 1 79 0
 456 0206 1D48     		ldr	r0, .L90+40
 457 0208 1D4E     		ldr	r6, .L90+44
 458 020a 3918     		add	r1, r7, r0
 459 020c 2220     		mov	r0, #34
 460 020e B142     		cmp	r1, r6
 461 0210 00D9     		bls	.LCB535
 462 0212 10E7     		b	.L2	@long jump
 463              	.LCB535:
 464 0214 16E7     		b	.L3
 465              	.LVL39:
 466              	.L4:
 113:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 467              		.loc 1 113 0
 468 0216 2020     		mov	r0, #32
 469 0218 0143     		orr	r1, r0
 470              	.LVL40:
 471 021a A800     		lsl	r0, r5, #2
 472 021c 0143     		orr	r1, r0
 473 021e C9B2     		uxtb	r1, r1
 474 0220 D200     		lsl	r2, r2, #3
 475 0222 0A43     		orr	r2, r1
 476              	.LVL41:
 115:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 477              		.loc 1 115 0
 478 0224 5A70     		strb	r2, [r3, #1]
 479              	.LVL42:
 480              	.L7:
 121:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 481              		.loc 1 121 0
 482 0226 174A     		ldr	r2, .L90+48
 483 0228 0223     		mov	r3, #2
 484 022a 9742     		cmp	r7, r2
 485 022c 00DC     		bgt	.LCB565
 486 022e 3FE7     		b	.L5	@long jump
 487              	.LCB565:
 122:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 488              		.loc 1 122 0
 489 0230 1548     		ldr	r0, .L90+52
 490 0232 0323     		mov	r3, #3
 491 0234 8742     		cmp	r7, r0
 492 0236 00DC     		bgt	.LCB569
 493 0238 3AE7     		b	.L5	@long jump
 494              	.LCB569:
 123:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 495              		.loc 1 123 0
 496 023a 1449     		ldr	r1, .L90+56
 124:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
 497              		.loc 1 124 0
 498 023c 0523     		mov	r3, #5
 123:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 499              		.loc 1 123 0
 500 023e 8F42     		cmp	r7, r1
 501 0240 00DD     		ble	.LCB573
 502 0242 35E7     		b	.L5	@long jump
 503              	.LCB573:
 504 0244 0423     		mov	r3, #4
 505 0246 33E7     		b	.L5
 506              	.LVL43:
 507              	.L84:
 120:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 508              		.loc 1 120 0
 509 0248 1149     		ldr	r1, .L90+60
 510 024a 0123     		mov	r3, #1
 511 024c 8F42     		cmp	r7, r1
 512 024e 00DC     		bgt	.LCB583
 513 0250 2EE7     		b	.L5	@long jump
 514              	.LCB583:
 515 0252 E8E7     		b	.L7
 516              	.L91:
 517              		.align	2
 518              	.L90:
 519 0254 00400640 		.word	1074151424
 520 0258 80F0FA02 		.word	50000000
 521 025c 807BE1FF 		.word	-2000000
 522 0260 80841E00 		.word	2000000
 523 0264 009423FD 		.word	-48000000
 524 0268 00751903 		.word	52000000
 525 026c 00127A00 		.word	8000000
 526 0270 D0121300 		.word	1250000
 527 0274 204E0000 		.word	20000
 528 0278 CF070000 		.word	1999
 529 027c 4039D2FF 		.word	-3000000
 530 0280 4081BA01 		.word	29000000
 531 0284 404B4C00 		.word	5000000
 532 0288 80969800 		.word	10000000
 533 028c 002D3101 		.word	20000000
 534 0290 A0252600 		.word	2500000
 535              		.cfi_endproc
 536              	.LFE0:
 538              		.section	.text.new_pll_freq,"ax",%progbits
 539              		.align	2
 540              		.global	new_pll_freq
 541              		.code	16
 542              		.thumb_func
 544              	new_pll_freq:
 545              	.LFB1:
 212:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 213:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 214:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /*********************************************************************************************/
 215:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : new_pll_freq
 216:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 217:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: Moves from PEE to PBE mode before changing PLL settings and moves back to PEE m
 218:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 219:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function provides a safe means of updating the PLL configurations to ensure the system
 220:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * does not lose the clock source or is over-clocked as the PLL frequency changes.
 221:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Using the function parameter names the PLL frequency is calculated as follows:
 222:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
 223:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * The various passed parameters are checked to ensure they are within the allowed range. If any
 224:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * of these checks fail the driver will exit and return a fail/error code. An error code will
 225:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * also be returned if any error occurs during the PLL initialization sequence. Refer to the
 226:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * readme file in the mcg driver directory for a list of all these codes.
 227:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function first moves the MCG to PBE mode to use the external reference clock to provide the
 228:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * system clock. The PLL settings are then updated. Once the PLL has re-locked the MCG is moved bac
 229:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * to PEE to use the PLL as the system clock.
 230:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Only the PLL PRDIV0 and VDIV0 fields are changed.
 231:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * 
 232:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Prerequisistes : The MCG must be in PEE mode before calling this routine. It is the responsibili
 233:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * of the calling routine to ensure the SIM_CLKDIV1 system clock dividers and any peripheral clock
 234:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * dividers are set correctly before or after calling this function to ensure the appropriate clock
 235:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * are kept within specification. You would typically change the divider values before calling this
 236:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * routine.
 237:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * 
 238:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
 239:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           wave clock source
 240:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 241:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           PLL reference clock frequency
 242:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 243:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 244:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : PLL frequency (Hz) or error code
 245:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
 246:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 247:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 546              		.loc 1 247 0
 547              		.cfi_startproc
 548              	.LVL44:
 549 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 550              	.LCFI2:
 551              		.cfi_def_cfa_offset 20
 552              		.cfi_offset 4, -20
 553              		.cfi_offset 5, -16
 554              		.cfi_offset 6, -12
 555              		.cfi_offset 7, -8
 556              		.cfi_offset 14, -4
 557 0002 4746     		mov	r7, r8
 558 0004 80B4     		push	{r7}
 559              	.LCFI3:
 560              		.cfi_def_cfa_offset 24
 561              		.cfi_offset 8, -24
 248:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 249:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char prdiv, vdiv;
 250:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 251:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int ref_freq;
 252:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int pll_freq;
 253:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 254:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 255:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in PEE mode
 256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 562              		.loc 1 256 0
 563 0006 4F4C     		ldr	r4, .L134
 247:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 564              		.loc 1 247 0
 565 0008 071C     		mov	r7, r0
 566              		.loc 1 256 0
 567 000a A579     		ldrb	r5, [r4, #6]
 247:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 568              		.loc 1 247 0
 569 000c 161C     		mov	r6, r2
 570              		.loc 1 256 0
 571 000e 2807     		lsl	r0, r5, #28
 572              	.LVL45:
 573 0010 820F     		lsr	r2, r0, #30
 574              	.LVL46:
 257:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 258:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 259:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 260:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x8;                                                       // return error code
 575              		.loc 1 260 0
 576 0012 0820     		mov	r0, #8
 256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 577              		.loc 1 256 0
 578 0014 032A     		cmp	r2, #3
 579 0016 02D0     		beq	.L129
 580              	.LVL47:
 581              	.L93:
 261:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   } 
 262:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 263:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check PLL divider settings are within spec.
 264:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 265:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 266:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 267:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check PLL reference clock frequency is within spec.
 268:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   ref_freq = crystal_val / prdiv_val;
 269:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 270:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 271:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check PLL output frequency is within spec.
 272:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 273:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 274:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 275:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // First move to PBE mode so that the PLL frequency can be safely changed.
 276:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // As we are running from the PLL by default the PLL and external clock settings are valid
 277:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext clock 
 278:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // As CLKS is already 0 the CLKS value can simply be OR'ed into the register 
 279:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 280:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 281:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for clock status bits to update 
 282:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 283:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 284:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 285:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 286:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 287:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 288:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now in PBE mode 
 289:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // System is clocked off the external clock. 
 290:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now update the PLL settings and wait for the PLL to re-lock
 291:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure MCG_C5
 292:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 293:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 294:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 295:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 296:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 297:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure MCG_C6
 298:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
 299:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 300:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 301:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 302:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 303:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 304:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 305:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // wait for PLLST status bit to set
 306:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 307:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 308:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 309:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 310:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 311:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 312:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for LOCK bit to set
 313:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 314:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 315:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 316:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 317:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 318:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 319:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Change CLKS mux to now select the PLL output
 320:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 321:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 322:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for clock status bits to update
 323:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 324:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 325:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 326:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 327:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 328:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 329:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now in PEE
 330:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Use actual PLL settings to calculate PLL frequency
 331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 332:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 333:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 334:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 335:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // new_pll_freq
 582              		.loc 1 335 0
 583              		@ sp needed for prologue
 584 0018 04BC     		pop	{r2}
 585 001a 9046     		mov	r8, r2
 586 001c F0BD     		pop	{r4, r5, r6, r7, pc}
 587              	.LVL48:
 588              	.L129:
 257:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 589              		.loc 1 257 0
 590 001e A379     		ldrb	r3, [r4, #6]
 256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 591              		.loc 1 256 0
 592 0020 DB06     		lsl	r3, r3, #27
 593 0022 F9D4     		bmi	.L93
 258:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 594              		.loc 1 258 0
 595 0024 A579     		ldrb	r5, [r4, #6]
 256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 596              		.loc 1 256 0
 597 0026 AB06     		lsl	r3, r5, #26
 598 0028 F6D5     		bpl	.L93
 264:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 599              		.loc 1 264 0
 600 002a 481E     		sub	r0, r1, #1
 601 002c C5B2     		uxtb	r5, r0
 602 002e 4120     		mov	r0, #65
 603 0030 182D     		cmp	r5, #24
 604 0032 F1D8     		bhi	.L93
 265:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
 605              		.loc 1 265 0
 606 0034 321C     		mov	r2, r6
 607 0036 183A     		sub	r2, r2, #24
 608 0038 D3B2     		uxtb	r3, r2
 609 003a 9846     		mov	r8, r3
 610 003c 4220     		mov	r0, #66
 611 003e 1A2B     		cmp	r3, #26
 612 0040 EAD8     		bhi	.L93
 268:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   ref_freq = crystal_val / prdiv_val;
 613              		.loc 1 268 0
 614 0042 381C     		mov	r0, r7
 615 0044 FFF7FEFF 		bl	__aeabi_idiv
 616              	.LVL49:
 269:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 617              		.loc 1 269 0
 618 0048 3F49     		ldr	r1, .L134+4
 619 004a 404A     		ldr	r2, .L134+8
 620 004c 4118     		add	r1, r0, r1
 268:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   ref_freq = crystal_val / prdiv_val;
 621              		.loc 1 268 0
 622 004e 031C     		mov	r3, r0
 623              	.LVL50:
 269:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
 624              		.loc 1 269 0
 625 0050 4320     		mov	r0, #67
 626              	.LVL51:
 627 0052 9142     		cmp	r1, r2
 628 0054 E0D8     		bhi	.L93
 629              	.LVL52:
 272:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 630              		.loc 1 272 0
 631 0056 5E43     		mul	r6, r3
 632              	.LVL53:
 273:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 633              		.loc 1 273 0
 634 0058 3D48     		ldr	r0, .L134+12
 635 005a 3E49     		ldr	r1, .L134+16
 636 005c 3318     		add	r3, r6, r0
 637              	.LVL54:
 638 005e 4520     		mov	r0, #69
 639 0060 8B42     		cmp	r3, r1
 640 0062 D9D8     		bhi	.L93
 279:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 641              		.loc 1 279 0
 642 0064 2278     		ldrb	r2, [r4]
 643 0066 8026     		mov	r6, #128
 644 0068 1643     		orr	r6, r2
 645 006a FA20     		mov	r0, #250
 646 006c 2670     		strb	r6, [r4]
 647              	.LVL55:
 648 006e C000     		lsl	r0, r0, #3
 284:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 649              		.loc 1 284 0
 650 0070 0C23     		mov	r3, #12
 651 0072 09E0     		b	.L95
 652              	.LVL56:
 653              	.L130:
 654 0074 A679     		ldrb	r6, [r4, #6]
 655 0076 0138     		sub	r0, r0, #1
 656 0078 82B2     		uxth	r2, r0
 657 007a 1E40     		and	r6, r3
 658 007c 082E     		cmp	r6, #8
 659 007e 07D0     		beq	.L94
 660 0080 013A     		sub	r2, r2, #1
 661 0082 90B2     		uxth	r0, r2
 282:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 662              		.loc 1 282 0
 663 0084 0028     		cmp	r0, #0
 664 0086 03D0     		beq	.L94
 665              	.L95:
 284:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 666              		.loc 1 284 0
 667 0088 A179     		ldrb	r1, [r4, #6]
 668 008a 1940     		and	r1, r3
 669 008c 0829     		cmp	r1, #8
 670 008e F1D1     		bne	.L130
 671              	.L94:
 286:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 672              		.loc 1 286 0
 673 0090 2C4C     		ldr	r4, .L134
 674 0092 1A20     		mov	r0, #26
 675 0094 A379     		ldrb	r3, [r4, #6]
 676 0096 1907     		lsl	r1, r3, #28
 677 0098 8A0F     		lsr	r2, r1, #30
 678 009a 022A     		cmp	r2, #2
 679 009c BCD1     		bne	.L93
 292:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 680              		.loc 1 292 0
 681 009e 2679     		ldrb	r6, [r4, #4]
 682              	.LVL57:
 293:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 683              		.loc 1 293 0
 684 00a0 1F20     		mov	r0, #31
 685 00a2 8643     		bic	r6, r0
 686              	.LVL58:
 294:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 687              		.loc 1 294 0
 688 00a4 3543     		orr	r5, r6
 689              	.LVL59:
 295:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 690              		.loc 1 295 0
 691 00a6 2571     		strb	r5, [r4, #4]
 300:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 692              		.loc 1 300 0
 693 00a8 6579     		ldrb	r5, [r4, #5]
 694              	.LVL60:
 302:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 695              		.loc 1 302 0
 696 00aa 4021     		mov	r1, #64
 301:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 697              		.loc 1 301 0
 698 00ac 8543     		bic	r5, r0
 699              	.LVL61:
 700 00ae 2B1C     		mov	r3, r5
 302:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 701              		.loc 1 302 0
 702 00b0 0B43     		orr	r3, r1
 703 00b2 4246     		mov	r2, r8
 704 00b4 1343     		orr	r3, r2
 705              	.LVL62:
 303:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 706              		.loc 1 303 0
 707 00b6 FA26     		mov	r6, #250
 708 00b8 6371     		strb	r3, [r4, #5]
 709              	.LVL63:
 308:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 710              		.loc 1 308 0
 711 00ba 2025     		mov	r5, #32
 303:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 712              		.loc 1 303 0
 713 00bc F300     		lsl	r3, r6, #3
 714              	.LVL64:
 715 00be 03E0     		b	.L97
 716              	.LVL65:
 717              	.L131:
 718 00c0 013B     		sub	r3, r3, #1
 719 00c2 9BB2     		uxth	r3, r3
 306:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 720              		.loc 1 306 0
 721 00c4 002B     		cmp	r3, #0
 722 00c6 02D0     		beq	.L96
 723              	.L97:
 308:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 724              		.loc 1 308 0
 725 00c8 A079     		ldrb	r0, [r4, #6]
 726 00ca 2842     		tst	r0, r5
 727 00cc F8D0     		beq	.L131
 728              	.L96:
 310:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 729              		.loc 1 310 0
 730 00ce 1D4C     		ldr	r4, .L134
 731 00d0 1620     		mov	r0, #22
 732 00d2 A179     		ldrb	r1, [r4, #6]
 733 00d4 8B06     		lsl	r3, r1, #26
 734 00d6 9FD5     		bpl	.L93
 735 00d8 FA22     		mov	r2, #250
 736 00da 1001     		lsl	r0, r2, #4
 315:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 737              		.loc 1 315 0
 738 00dc 4026     		mov	r6, #64
 739 00de 03E0     		b	.L99
 740              	.L132:
 741 00e0 0138     		sub	r0, r0, #1
 742 00e2 80B2     		uxth	r0, r0
 313:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 4000 ; i++)
 743              		.loc 1 313 0
 744 00e4 0028     		cmp	r0, #0
 745 00e6 02D0     		beq	.L98
 746              	.L99:
 315:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 747              		.loc 1 315 0
 748 00e8 A579     		ldrb	r5, [r4, #6]
 749 00ea 3542     		tst	r5, r6
 750 00ec F8D0     		beq	.L132
 751              	.L98:
 317:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 752              		.loc 1 317 0
 753 00ee 154C     		ldr	r4, .L134
 754 00f0 4420     		mov	r0, #68
 755 00f2 A379     		ldrb	r3, [r4, #6]
 756 00f4 5B06     		lsl	r3, r3, #25
 757 00f6 00D4     		bmi	.LCB867
 758 00f8 8EE7     		b	.L93	@long jump
 759              	.LCB867:
 320:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 760              		.loc 1 320 0
 761 00fa 2178     		ldrb	r1, [r4]
 762 00fc 3F22     		mov	r2, #63
 763 00fe 0A40     		and	r2, r1
 764 0100 FA26     		mov	r6, #250
 765 0102 2270     		strb	r2, [r4]
 766              	.LVL66:
 767 0104 F300     		lsl	r3, r6, #3
 325:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 768              		.loc 1 325 0
 769 0106 0C25     		mov	r5, #12
 770 0108 03E0     		b	.L101
 771              	.LVL67:
 772              	.L133:
 773 010a 013B     		sub	r3, r3, #1
 774 010c 9BB2     		uxth	r3, r3
 323:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 775              		.loc 1 323 0
 776 010e 002B     		cmp	r3, #0
 777 0110 03D0     		beq	.L100
 778              	.L101:
 325:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 779              		.loc 1 325 0
 780 0112 A079     		ldrb	r0, [r4, #6]
 781 0114 2840     		and	r0, r5
 782 0116 0C28     		cmp	r0, #12
 783 0118 F7D1     		bne	.L133
 784              	.L100:
 327:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 785              		.loc 1 327 0
 786 011a 0A4C     		ldr	r4, .L134
 787 011c 1B20     		mov	r0, #27
 788 011e A179     		ldrb	r1, [r4, #6]
 789 0120 0A07     		lsl	r2, r1, #28
 790 0122 960F     		lsr	r6, r2, #30
 791 0124 032E     		cmp	r6, #3
 792 0126 00D0     		beq	.LCB910
 793 0128 76E7     		b	.L93	@long jump
 794              	.LCB910:
 331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 795              		.loc 1 331 0
 796 012a 2179     		ldrb	r1, [r4, #4]
 797              	.LVL68:
 332:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 798              		.loc 1 332 0
 799 012c 6579     		ldrb	r5, [r4, #5]
 800              	.LVL69:
 331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 801              		.loc 1 331 0
 802 012e 1F24     		mov	r4, #31
 803 0130 2140     		and	r1, r4
 804              	.LVL70:
 334:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 805              		.loc 1 334 0
 806 0132 381C     		mov	r0, r7
 807 0134 0131     		add	r1, r1, #1
 808 0136 FFF7FEFF 		bl	__aeabi_idiv
 809              	.LVL71:
 332:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 810              		.loc 1 332 0
 811 013a 2F1C     		mov	r7, r5
 812              	.LVL72:
 813 013c 2740     		and	r7, r4
 334:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 814              		.loc 1 334 0
 815 013e 1837     		add	r7, r7, #24
 816 0140 7843     		mul	r0, r7
 817 0142 69E7     		b	.L93
 818              	.L135:
 819              		.align	2
 820              	.L134:
 821 0144 00400640 		.word	1074151424
 822 0148 807BE1FF 		.word	-2000000
 823 014c 80841E00 		.word	2000000
 824 0150 009423FD 		.word	-48000000
 825 0154 00751903 		.word	52000000
 826              		.cfi_endproc
 827              	.LFE1:
 829              		.section	.text.pee_pbe,"ax",%progbits
 830              		.align	2
 831              		.global	pee_pbe
 832              		.code	16
 833              		.thumb_func
 835              	pee_pbe:
 836              	.LFB2:
 336:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 337:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 338:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
 339:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 340:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int pee_pbe(int crystal_val)
 341:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 837              		.loc 1 341 0
 838              		.cfi_startproc
 839              	.LVL73:
 840 0000 10B5     		push	{r4, lr}
 841              	.LCFI4:
 842              		.cfi_def_cfa_offset 8
 843              		.cfi_offset 4, -8
 844              		.cfi_offset 14, -4
 342:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 343:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 344:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in PEE mode
 345:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 845              		.loc 1 345 0
 846 0002 164B     		ldr	r3, .L155
 847 0004 9A79     		ldrb	r2, [r3, #6]
 848 0006 1107     		lsl	r1, r2, #28
 849 0008 8C0F     		lsr	r4, r1, #30
 850 000a 032C     		cmp	r4, #3
 851 000c 01D0     		beq	.L153
 852              	.L142:
 346:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 347:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 348:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 349:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x8;                                                       // return error code
 853              		.loc 1 349 0
 854 000e 0820     		mov	r0, #8
 855              	.LVL74:
 856              	.L137:
 350:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   } 
 351:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 352:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // As we are running from the PLL by default the PLL and external clock settings are valid
 353:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // To move to PBE from PEE simply requires the switching of the CLKS mux to select the ext clock 
 354:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // As CLKS is already 0 the CLKS value can simply be OR'ed into the register 
 355:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 356:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 357:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to update 
 358:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 359:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 360:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 361:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 362:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 363:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 364:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in PBE mode  
 365:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 366:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // pee_pbe
 857              		.loc 1 366 0
 858              		@ sp needed for prologue
 859 0010 10BD     		pop	{r4, pc}
 860              	.LVL75:
 861              	.L153:
 346:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 862              		.loc 1 346 0
 863 0012 9A79     		ldrb	r2, [r3, #6]
 345:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 864              		.loc 1 345 0
 865 0014 D106     		lsl	r1, r2, #27
 866 0016 FAD4     		bmi	.L142
 347:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selecte
 867              		.loc 1 347 0
 868 0018 9979     		ldrb	r1, [r3, #6]
 345:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted
 869              		.loc 1 345 0
 870 001a 8906     		lsl	r1, r1, #26
 871 001c F7D5     		bpl	.L142
 355:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
 872              		.loc 1 355 0
 873 001e 1C78     		ldrb	r4, [r3]
 874 0020 8022     		mov	r2, #128
 875 0022 2243     		orr	r2, r4
 876 0024 FA21     		mov	r1, #250
 877 0026 1A70     		strb	r2, [r3]
 878              	.LVL76:
 879 0028 CA00     		lsl	r2, r1, #3
 360:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 880              		.loc 1 360 0
 881 002a 0C21     		mov	r1, #12
 882 002c 09E0     		b	.L139
 883              	.LVL77:
 884              	.L154:
 885 002e 9C79     		ldrb	r4, [r3, #6]
 886 0030 013A     		sub	r2, r2, #1
 887 0032 92B2     		uxth	r2, r2
 888 0034 0C40     		and	r4, r1
 889 0036 082C     		cmp	r4, #8
 890 0038 07D0     		beq	.L138
 891 003a 013A     		sub	r2, r2, #1
 892 003c 92B2     		uxth	r2, r2
 358:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 893              		.loc 1 358 0
 894 003e 002A     		cmp	r2, #0
 895 0040 03D0     		beq	.L138
 896              	.L139:
 360:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 897              		.loc 1 360 0
 898 0042 9C79     		ldrb	r4, [r3, #6]
 899 0044 0C40     		and	r4, r1
 900 0046 082C     		cmp	r4, #8
 901 0048 F1D1     		bne	.L154
 902              	.L138:
 362:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 903              		.loc 1 362 0
 904 004a 044B     		ldr	r3, .L155
 905 004c 9979     		ldrb	r1, [r3, #6]
 906 004e 0C07     		lsl	r4, r1, #28
 907 0050 A20F     		lsr	r2, r4, #30
 908 0052 022A     		cmp	r2, #2
 909 0054 DCD0     		beq	.L137
 910 0056 1A20     		mov	r0, #26
 911              	.LVL78:
 912 0058 DAE7     		b	.L137
 913              	.L156:
 914 005a C046     		.align	2
 915              	.L155:
 916 005c 00400640 		.word	1074151424
 917              		.cfi_endproc
 918              	.LFE2:
 920              		.section	.text.pbe_pee,"ax",%progbits
 921              		.align	2
 922              		.global	pbe_pee
 923              		.code	16
 924              		.thumb_func
 926              	pbe_pee:
 927              	.LFB3:
 367:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 368:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 369:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int pbe_pee(int crystal_val)
 370:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 928              		.loc 1 370 0
 929              		.cfi_startproc
 930              	.LVL79:
 931 0000 70B5     		push	{r4, r5, r6, lr}
 932              	.LCFI5:
 933              		.cfi_def_cfa_offset 16
 934              		.cfi_offset 4, -16
 935              		.cfi_offset 5, -12
 936              		.cfi_offset 6, -8
 937              		.cfi_offset 14, -4
 371:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char prdiv, vdiv;
 372:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 373:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 374:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in PBE mode
 375:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 938              		.loc 1 375 0
 939 0002 294B     		ldr	r3, .L184
 940 0004 9A79     		ldrb	r2, [r3, #6]
 941 0006 1107     		lsl	r1, r2, #28
 942 0008 8E0F     		lsr	r6, r1, #30
 376:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 377:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 378:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 379:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 380:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x7;                                                       // return error code
 943              		.loc 1 380 0
 944 000a 0721     		mov	r1, #7
 375:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 945              		.loc 1 375 0
 946 000c 022E     		cmp	r6, #2
 947 000e 01D0     		beq	.L181
 948              	.LVL80:
 949              	.L158:
 381:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 382:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 383:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // As the PLL settings have already been checked when PBE mode was enterred they are not checked 
 384:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 385:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check the PLL state before transitioning to PEE mode
 386:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 387:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but g
 388:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // to re-check before switch to use PLL)
 389:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 390:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 391:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 392:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 393:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 394:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Use actual PLL settings to calculate PLL frequency
 395:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 396:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 397:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 398:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 399:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 400:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for clock status bits to update
 401:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 402:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 403:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 404:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 405:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 406:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 407:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now in PEE
 408:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 409:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 410:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** }  // pbe_pee
 950              		.loc 1 410 0
 951 0010 081C     		mov	r0, r1
 952              		@ sp needed for prologue
 953 0012 70BD     		pop	{r4, r5, r6, pc}
 954              	.LVL81:
 955              	.L181:
 376:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 956              		.loc 1 376 0
 957 0014 9C79     		ldrb	r4, [r3, #6]
 375:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 958              		.loc 1 375 0
 959 0016 E506     		lsl	r5, r4, #27
 960 0018 FAD4     		bmi	.L158
 377:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 961              		.loc 1 377 0
 962 001a 9D79     		ldrb	r5, [r3, #6]
 376:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 963              		.loc 1 376 0
 964 001c AD06     		lsl	r5, r5, #26
 965 001e F7D5     		bpl	.L158
 378:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 966              		.loc 1 378 0
 967 0020 5A78     		ldrb	r2, [r3, #1]
 375:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 968              		.loc 1 375 0
 969 0022 1642     		tst	r6, r2
 970 0024 F4D1     		bne	.L158
 971 0026 FA21     		mov	r1, #250
 972 0028 C900     		lsl	r1, r1, #3
 391:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 973              		.loc 1 391 0
 974 002a 4026     		mov	r6, #64
 975 002c 08E0     		b	.L160
 976              	.L182:
 977              	.LVL82:
 978 002e 9A79     		ldrb	r2, [r3, #6]
 979 0030 0139     		sub	r1, r1, #1
 980 0032 8DB2     		uxth	r5, r1
 981 0034 1642     		tst	r6, r2
 982 0036 06D1     		bne	.L159
 983 0038 013D     		sub	r5, r5, #1
 984 003a A9B2     		uxth	r1, r5
 389:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 985              		.loc 1 389 0
 986 003c 0029     		cmp	r1, #0
 987 003e 02D0     		beq	.L159
 988              	.L160:
 391:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 989              		.loc 1 391 0
 990 0040 9C79     		ldrb	r4, [r3, #6]
 991 0042 2642     		tst	r6, r4
 992 0044 F3D0     		beq	.L182
 993              	.L159:
 393:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 994              		.loc 1 393 0
 995 0046 184A     		ldr	r2, .L184
 996 0048 4421     		mov	r1, #68
 997 004a 9379     		ldrb	r3, [r2, #6]
 998 004c 5C06     		lsl	r4, r3, #25
 999 004e DFD5     		bpl	.L158
 395:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1000              		.loc 1 395 0
 1001 0050 1679     		ldrb	r6, [r2, #4]
 1002              	.LVL83:
 396:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1003              		.loc 1 396 0
 1004 0052 5579     		ldrb	r5, [r2, #5]
 1005              	.LVL84:
 398:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 1006              		.loc 1 398 0
 1007 0054 1478     		ldrb	r4, [r2]
 1008 0056 3F21     		mov	r1, #63
 1009 0058 0C40     		and	r4, r1
 1010 005a FA23     		mov	r3, #250
 1011 005c 1470     		strb	r4, [r2]
 1012              	.LVL85:
 403:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 1013              		.loc 1 403 0
 1014 005e 111C     		mov	r1, r2
 398:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
 1015              		.loc 1 398 0
 1016 0060 DB00     		lsl	r3, r3, #3
 403:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 1017              		.loc 1 403 0
 1018 0062 0C22     		mov	r2, #12
 1019 0064 09E0     		b	.L162
 1020              	.LVL86:
 1021              	.L183:
 1022 0066 8C79     		ldrb	r4, [r1, #6]
 1023 0068 013B     		sub	r3, r3, #1
 1024 006a 9BB2     		uxth	r3, r3
 1025 006c 1440     		and	r4, r2
 1026 006e 0C2C     		cmp	r4, #12
 1027 0070 07D0     		beq	.L161
 1028 0072 013B     		sub	r3, r3, #1
 1029 0074 9BB2     		uxth	r3, r3
 401:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1030              		.loc 1 401 0
 1031 0076 002B     		cmp	r3, #0
 1032 0078 03D0     		beq	.L161
 1033              	.L162:
 403:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST
 1034              		.loc 1 403 0
 1035 007a 8C79     		ldrb	r4, [r1, #6]
 1036 007c 1440     		and	r4, r2
 1037 007e 0C2C     		cmp	r4, #12
 1038 0080 F1D1     		bne	.L183
 1039              	.L161:
 405:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set 
 1040              		.loc 1 405 0
 1041 0082 0949     		ldr	r1, .L184
 1042 0084 8A79     		ldrb	r2, [r1, #6]
 1043 0086 1B21     		mov	r1, #27
 1044 0088 1407     		lsl	r4, r2, #28
 1045 008a A30F     		lsr	r3, r4, #30
 1046 008c 032B     		cmp	r3, #3
 1047 008e BFD1     		bne	.L158
 395:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
 1048              		.loc 1 395 0
 1049 0090 1F24     		mov	r4, #31
 1050 0092 311C     		mov	r1, r6
 1051 0094 2140     		and	r1, r4
 408:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1052              		.loc 1 408 0
 1053 0096 0131     		add	r1, r1, #1
 1054 0098 FFF7FEFF 		bl	__aeabi_idiv
 1055              	.LVL87:
 396:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
 1056              		.loc 1 396 0
 1057 009c 291C     		mov	r1, r5
 1058 009e 2140     		and	r1, r4
 408:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
 1059              		.loc 1 408 0
 1060 00a0 1831     		add	r1, r1, #24
 1061 00a2 4143     		mul	r1, r0
 1062 00a4 B4E7     		b	.L158
 1063              	.L185:
 1064 00a6 C046     		.align	2
 1065              	.L184:
 1066 00a8 00400640 		.word	1074151424
 1067              		.cfi_endproc
 1068              	.LFE3:
 1070              		.section	.text.pbe_fbe,"ax",%progbits
 1071              		.align	2
 1072              		.global	pbe_fbe
 1073              		.code	16
 1074              		.thumb_func
 1076              	pbe_fbe:
 1077              	.LFB4:
 411:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 412:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 413:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int pbe_fbe(int crystal_val)
 414:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1078              		.loc 1 414 0
 1079              		.cfi_startproc
 1080              	.LVL88:
 1081 0000 10B5     		push	{r4, lr}
 1082              	.LCFI6:
 1083              		.cfi_def_cfa_offset 8
 1084              		.cfi_offset 4, -8
 1085              		.cfi_offset 14, -4
 415:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 416:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 417:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in PBE mode
 418:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1086              		.loc 1 418 0
 1087 0002 154B     		ldr	r3, .L206
 1088 0004 9A79     		ldrb	r2, [r3, #6]
 1089 0006 1107     		lsl	r1, r2, #28
 1090 0008 8A0F     		lsr	r2, r1, #30
 1091 000a 022A     		cmp	r2, #2
 1092 000c 01D0     		beq	.L204
 1093              	.L193:
 419:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 420:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 421:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 422:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 423:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x7;                                                       // return error code
 1094              		.loc 1 423 0
 1095 000e 0720     		mov	r0, #7
 1096              	.LVL89:
 1097              	.L187:
 424:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 425:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 426:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // As we are running from the ext clock, by default the external clock settings are valid
 427:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // To move to FBE from PBE simply requires the switching of the PLLS mux to disable the PLL 
 428:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 429:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 430:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 431:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for PLLST status bit to set
 432:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 433:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 434:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 435:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 436:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 437:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 438:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBE mode  
 439:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency 
 440:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // pbe_fbe
 1098              		.loc 1 440 0
 1099              		@ sp needed for prologue
 1100 0010 10BD     		pop	{r4, pc}
 1101              	.LVL90:
 1102              	.L204:
 419:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1103              		.loc 1 419 0
 1104 0012 9C79     		ldrb	r4, [r3, #6]
 418:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1105              		.loc 1 418 0
 1106 0014 E406     		lsl	r4, r4, #27
 1107 0016 FAD4     		bmi	.L193
 420:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1108              		.loc 1 420 0
 1109 0018 9979     		ldrb	r1, [r3, #6]
 419:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1110              		.loc 1 419 0
 1111 001a 8C06     		lsl	r4, r1, #26
 1112 001c F7D5     		bpl	.L193
 421:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1113              		.loc 1 421 0
 1114 001e 5C78     		ldrb	r4, [r3, #1]
 418:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1115              		.loc 1 418 0
 1116 0020 2242     		tst	r2, r4
 1117 0022 F4D1     		bne	.L193
 429:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 1118              		.loc 1 429 0
 1119 0024 5A79     		ldrb	r2, [r3, #5]
 1120 0026 4021     		mov	r1, #64
 1121 0028 8A43     		bic	r2, r1
 1122 002a FA24     		mov	r4, #250
 1123 002c 5A71     		strb	r2, [r3, #5]
 1124              	.LVL91:
 434:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1125              		.loc 1 434 0
 1126 002e 2021     		mov	r1, #32
 429:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
 1127              		.loc 1 429 0
 1128 0030 E200     		lsl	r2, r4, #3
 1129 0032 08E0     		b	.L189
 1130              	.LVL92:
 1131              	.L205:
 434:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1132              		.loc 1 434 0
 1133 0034 9C79     		ldrb	r4, [r3, #6]
 1134 0036 013A     		sub	r2, r2, #1
 1135 0038 92B2     		uxth	r2, r2
 1136 003a 2142     		tst	r1, r4
 1137 003c 06D0     		beq	.L188
 1138 003e 013A     		sub	r2, r2, #1
 1139 0040 92B2     		uxth	r2, r2
 432:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1140              		.loc 1 432 0
 1141 0042 002A     		cmp	r2, #0
 1142 0044 02D0     		beq	.L188
 1143              	.L189:
 434:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1144              		.loc 1 434 0
 1145 0046 9C79     		ldrb	r4, [r3, #6]
 1146 0048 2142     		tst	r1, r4
 1147 004a F3D1     		bne	.L205
 1148              	.L188:
 436:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 1149              		.loc 1 436 0
 1150 004c 024B     		ldr	r3, .L206
 1151 004e 9979     		ldrb	r1, [r3, #6]
 1152 0050 8A06     		lsl	r2, r1, #26
 1153 0052 DDD5     		bpl	.L187
 1154 0054 1520     		mov	r0, #21
 1155              	.LVL93:
 1156 0056 DBE7     		b	.L187
 1157              	.L207:
 1158              		.align	2
 1159              	.L206:
 1160 0058 00400640 		.word	1074151424
 1161              		.cfi_endproc
 1162              	.LFE4:
 1164              		.section	.text.fbe_pbe,"ax",%progbits
 1165              		.align	2
 1166              		.global	fbe_pbe
 1167              		.code	16
 1168              		.thumb_func
 1170              	fbe_pbe:
 1171              	.LFB5:
 441:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 442:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 443:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
 444:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : fbe_pbe
 445:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 446:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: FBE to PBE mode
 447:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 448:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function transitions the MCG from FBE mode to PBE mode. 
 449:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soo
 450:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * The function requires the desired OSC and PLL be passed in to it for compatibility with the
 451:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * future support of OSC/PLL selection
 452:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 453:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
 454:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             prdiv_val   - value to divide the external clock source by to create the desired
 455:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           PLL reference clock frequency
 456:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             vdiv_val    - value to multiply the PLL reference clock frequency by
 457:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 458:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 459:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
 460:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 461:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1172              		.loc 1 461 0
 1173              		.cfi_startproc
 1174              	.LVL94:
 1175 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1176              	.LCFI7:
 1177              		.cfi_def_cfa_offset 20
 1178              		.cfi_offset 4, -20
 1179              		.cfi_offset 5, -16
 1180              		.cfi_offset 6, -12
 1181              		.cfi_offset 7, -8
 1182              		.cfi_offset 14, -4
 1183 0002 4746     		mov	r7, r8
 1184 0004 80B4     		push	{r7}
 1185              	.LCFI8:
 1186              		.cfi_def_cfa_offset 24
 1187              		.cfi_offset 8, -24
 462:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 463:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 464:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int pll_freq;
 465:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 466:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FBE mode
 467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1188              		.loc 1 467 0
 1189 0006 354D     		ldr	r5, .L235
 461:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1190              		.loc 1 461 0
 1191 0008 041C     		mov	r4, r0
 1192              		.loc 1 467 0
 1193 000a AB79     		ldrb	r3, [r5, #6]
 461:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1194              		.loc 1 461 0
 1195 000c 161C     		mov	r6, r2
 1196              		.loc 1 467 0
 1197 000e 1807     		lsl	r0, r3, #28
 1198              	.LVL95:
 1199 0010 870F     		lsr	r7, r0, #30
 1200 0012 022F     		cmp	r7, #2
 1201 0014 04D0     		beq	.L227
 1202              	.LVL96:
 1203              	.L217:
 468:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 469:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 470:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 471:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 472:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 1204              		.loc 1 472 0
 1205 0016 0424     		mov	r4, #4
 1206              	.LVL97:
 1207              	.L209:
 473:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 474:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 475:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 476:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 477:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check PLL divider settings are within spec.
 478:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 479:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 480:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 481:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check PLL reference clock frequency is within spec.
 482:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 483:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****        
 484:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check PLL output frequency is within spec.
 485:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 486:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 487:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 488:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure MCG_C5
 489:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user co
 490:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 491:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 492:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 493:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 494:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 495:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure MCG_C6
 496:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 497:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The clock monitor is not enabled here as it has likely been enabled previously and so the valu
 498:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // is not altered here.
 499:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 500:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 501:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 502:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 503:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 504:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 505:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // wait for PLLST status bit to set
 506:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 507:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 508:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 509:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 510:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 511:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 512:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for LOCK bit to set
 513:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 514:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 515:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 516:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 517:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 518:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     
 519:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // now in PBE 
 520:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 521:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbe_pbe
 1208              		.loc 1 521 0
 1209 0018 201C     		mov	r0, r4
 1210              		@ sp needed for prologue
 1211 001a 04BC     		pop	{r2}
 1212 001c 9046     		mov	r8, r2
 1213 001e F0BD     		pop	{r4, r5, r6, r7, pc}
 1214              	.LVL98:
 1215              	.L227:
 468:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1216              		.loc 1 468 0
 1217 0020 AA79     		ldrb	r2, [r5, #6]
 1218              	.LVL99:
 467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1219              		.loc 1 467 0
 1220 0022 D006     		lsl	r0, r2, #27
 1221 0024 F7D4     		bmi	.L217
 469:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 1222              		.loc 1 469 0
 1223 0026 AB79     		ldrb	r3, [r5, #6]
 468:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1224              		.loc 1 468 0
 1225 0028 9806     		lsl	r0, r3, #26
 1226 002a F4D4     		bmi	.L217
 470:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1227              		.loc 1 470 0
 1228 002c 6878     		ldrb	r0, [r5, #1]
 467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1229              		.loc 1 467 0
 1230 002e 0742     		tst	r7, r0
 1231 0030 F1D1     		bne	.L217
 478:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1232              		.loc 1 478 0
 1233 0032 4F1E     		sub	r7, r1, #1
 1234 0034 FFB2     		uxtb	r7, r7
 1235 0036 182F     		cmp	r7, #24
 1236 0038 01D9     		bls	.L228
 1237 003a 4124     		mov	r4, #65
 1238              	.LVL100:
 1239 003c ECE7     		b	.L209
 1240              	.LVL101:
 1241              	.L228:
 479:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1242              		.loc 1 479 0
 1243 003e 321C     		mov	r2, r6
 1244 0040 183A     		sub	r2, r2, #24
 1245 0042 D3B2     		uxtb	r3, r2
 1246 0044 9846     		mov	r8, r3
 1247 0046 1A2B     		cmp	r3, #26
 1248 0048 01D9     		bls	.L229
 1249 004a 4224     		mov	r4, #66
 1250              	.LVL102:
 1251 004c E4E7     		b	.L209
 1252              	.LVL103:
 1253              	.L229:
 482:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1254              		.loc 1 482 0
 1255 004e 201C     		mov	r0, r4
 1256 0050 FFF7FEFF 		bl	__aeabi_idiv
 1257              	.LVL104:
 1258 0054 2249     		ldr	r1, .L235+4
 1259 0056 234B     		ldr	r3, .L235+8
 1260 0058 4218     		add	r2, r0, r1
 1261 005a 9A42     		cmp	r2, r3
 1262 005c 01D9     		bls	.L230
 1263 005e 4324     		mov	r4, #67
 1264              	.LVL105:
 1265 0060 DAE7     		b	.L209
 1266              	.LVL106:
 1267              	.L230:
 485:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   pll_freq = (crystal_val / prdiv_val) * vdiv_val;
 1268              		.loc 1 485 0
 1269 0062 7043     		mul	r0, r6
 1270              	.LVL107:
 486:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
 1271              		.loc 1 486 0
 1272 0064 204E     		ldr	r6, .L235+12
 1273              	.LVL108:
 1274 0066 2149     		ldr	r1, .L235+16
 1275 0068 8019     		add	r0, r0, r6
 1276 006a 8842     		cmp	r0, r1
 1277 006c 01D9     		bls	.L231
 1278 006e 4524     		mov	r4, #69
 1279              	.LVL109:
 1280 0070 D2E7     		b	.L209
 1281              	.LVL110:
 1282              	.L231:
 490:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 1283              		.loc 1 490 0
 1284 0072 2A79     		ldrb	r2, [r5, #4]
 1285              	.LVL111:
 491:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1286              		.loc 1 491 0
 1287 0074 1F23     		mov	r3, #31
 1288 0076 9A43     		bic	r2, r3
 1289              	.LVL112:
 492:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 1290              		.loc 1 492 0
 1291 0078 1743     		orr	r7, r2
 1292              	.LVL113:
 493:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 1293              		.loc 1 493 0
 1294 007a 2F71     		strb	r7, [r5, #4]
 500:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 1295              		.loc 1 500 0
 1296 007c 6F79     		ldrb	r7, [r5, #5]
 1297              	.LVL114:
 502:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1298              		.loc 1 502 0
 1299 007e 4020     		mov	r0, #64
 501:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1300              		.loc 1 501 0
 1301 0080 9F43     		bic	r7, r3
 1302              	.LVL115:
 1303 0082 3E1C     		mov	r6, r7
 502:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1304              		.loc 1 502 0
 1305 0084 4146     		mov	r1, r8
 1306 0086 0643     		orr	r6, r0
 1307 0088 0E43     		orr	r6, r1
 1308              	.LVL116:
 503:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 1309              		.loc 1 503 0
 1310 008a FA22     		mov	r2, #250
 1311 008c 6E71     		strb	r6, [r5, #5]
 1312              	.LVL117:
 1313 008e D100     		lsl	r1, r2, #3
 508:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1314              		.loc 1 508 0
 1315 0090 2027     		mov	r7, #32
 1316 0092 08E0     		b	.L211
 1317              	.LVL118:
 1318              	.L232:
 1319 0094 A879     		ldrb	r0, [r5, #6]
 1320 0096 0139     		sub	r1, r1, #1
 1321 0098 8BB2     		uxth	r3, r1
 1322 009a 0742     		tst	r7, r0
 1323 009c 06D1     		bne	.L210
 1324 009e 013B     		sub	r3, r3, #1
 1325 00a0 99B2     		uxth	r1, r3
 506:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1326              		.loc 1 506 0
 1327 00a2 0029     		cmp	r1, #0
 1328 00a4 02D0     		beq	.L210
 1329              	.L211:
 508:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1330              		.loc 1 508 0
 1331 00a6 AE79     		ldrb	r6, [r5, #6]
 1332 00a8 3742     		tst	r7, r6
 1333 00aa F3D0     		beq	.L232
 1334              	.L210:
 510:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 1335              		.loc 1 510 0
 1336 00ac 0B4D     		ldr	r5, .L235
 1337 00ae AA79     		ldrb	r2, [r5, #6]
 1338 00b0 9106     		lsl	r1, r2, #26
 1339 00b2 01D4     		bmi	.L233
 1340 00b4 1624     		mov	r4, #22
 1341              	.LVL119:
 1342 00b6 AFE7     		b	.L209
 1343              	.LVL120:
 1344              	.L233:
 1345 00b8 FA27     		mov	r7, #250
 1346 00ba FB00     		lsl	r3, r7, #3
 515:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1347              		.loc 1 515 0
 1348 00bc 4026     		mov	r6, #64
 1349 00be 03E0     		b	.L213
 1350              	.L234:
 1351 00c0 013B     		sub	r3, r3, #1
 1352 00c2 9BB2     		uxth	r3, r3
 513:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1353              		.loc 1 513 0
 1354 00c4 002B     		cmp	r3, #0
 1355 00c6 02D0     		beq	.L212
 1356              	.L213:
 515:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1357              		.loc 1 515 0
 1358 00c8 A879     		ldrb	r0, [r5, #6]
 1359 00ca 3042     		tst	r0, r6
 1360 00cc F8D0     		beq	.L234
 1361              	.L212:
 517:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1362              		.loc 1 517 0
 1363 00ce 0349     		ldr	r1, .L235
 1364 00d0 8D79     		ldrb	r5, [r1, #6]
 1365 00d2 6A06     		lsl	r2, r5, #25
 1366 00d4 A0D4     		bmi	.L209
 1367 00d6 4424     		mov	r4, #68
 1368              	.LVL121:
 1369 00d8 9EE7     		b	.L209
 1370              	.L236:
 1371 00da C046     		.align	2
 1372              	.L235:
 1373 00dc 00400640 		.word	1074151424
 1374 00e0 807BE1FF 		.word	-2000000
 1375 00e4 80841E00 		.word	2000000
 1376 00e8 009423FD 		.word	-48000000
 1377 00ec 00751903 		.word	52000000
 1378              		.cfi_endproc
 1379              	.LFE5:
 1381              		.section	.text.pbe_blpe,"ax",%progbits
 1382              		.align	2
 1383              		.global	pbe_blpe
 1384              		.code	16
 1385              		.thumb_func
 1387              	pbe_blpe:
 1388              	.LFB6:
 522:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 523:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 524:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int pbe_blpe(int crystal_val)
 525:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1389              		.loc 1 525 0
 1390              		.cfi_startproc
 1391              	.LVL122:
 1392 0000 10B5     		push	{r4, lr}
 1393              	.LCFI9:
 1394              		.cfi_def_cfa_offset 8
 1395              		.cfi_offset 4, -8
 1396              		.cfi_offset 14, -4
 526:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in PBE mode
 527:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1397              		.loc 1 527 0
 1398 0002 0B4B     		ldr	r3, .L244
 1399 0004 9A79     		ldrb	r2, [r3, #6]
 1400 0006 1107     		lsl	r1, r2, #28
 1401 0008 8A0F     		lsr	r2, r1, #30
 1402 000a 022A     		cmp	r2, #2
 1403 000c 01D0     		beq	.L243
 1404              	.L242:
 528:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 529:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 530:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 531:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 532:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x7;                                                       // return error code
 1405              		.loc 1 532 0
 1406 000e 0720     		mov	r0, #7
 1407              	.LVL123:
 1408              	.L238:
 533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 534:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 535:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // To enter BLPE mode the LP bit must be set, disabling the PLL  
 536:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 537:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 538:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in BLPE mode
 539:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val;  
 540:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // pbe_blpe
 1409              		.loc 1 540 0
 1410              		@ sp needed for prologue
 1411 0010 10BD     		pop	{r4, pc}
 1412              	.LVL124:
 1413              	.L243:
 528:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1414              		.loc 1 528 0
 1415 0012 9C79     		ldrb	r4, [r3, #6]
 527:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1416              		.loc 1 527 0
 1417 0014 E406     		lsl	r4, r4, #27
 1418 0016 FAD4     		bmi	.L242
 529:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selecte
 1419              		.loc 1 529 0
 1420 0018 9979     		ldrb	r1, [r3, #6]
 528:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1421              		.loc 1 528 0
 1422 001a 8C06     		lsl	r4, r1, #26
 1423 001c F7D5     		bpl	.L242
 530:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1424              		.loc 1 530 0
 1425 001e 5C78     		ldrb	r4, [r3, #1]
 527:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1426              		.loc 1 527 0
 1427 0020 2242     		tst	r2, r4
 1428 0022 F4D1     		bne	.L242
 536:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 1429              		.loc 1 536 0
 1430 0024 5978     		ldrb	r1, [r3, #1]
 1431 0026 0A43     		orr	r2, r1
 1432 0028 D2B2     		uxtb	r2, r2
 1433 002a 5A70     		strb	r2, [r3, #1]
 539:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val;  
 1434              		.loc 1 539 0
 1435 002c F0E7     		b	.L238
 1436              	.L245:
 1437 002e C046     		.align	2
 1438              	.L244:
 1439 0030 00400640 		.word	1074151424
 1440              		.cfi_endproc
 1441              	.LFE6:
 1443              		.section	.text.blpe_pbe,"ax",%progbits
 1444              		.align	2
 1445              		.global	blpe_pbe
 1446              		.code	16
 1447              		.thumb_func
 1449              	blpe_pbe:
 1450              	.LFB7:
 541:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 542:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 543:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // ************************************************************************************************
 544:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been
 545:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // previously configured correctly. That is why this general purpose driver has the PLL settings as
 546:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // passed parameters.
 547:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // ************************************************************************************************
 548:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
 549:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1451              		.loc 1 549 0
 1452              		.cfi_startproc
 1453              	.LVL125:
 1454 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1455              	.LCFI10:
 1456              		.cfi_def_cfa_offset 20
 1457              		.cfi_offset 4, -20
 1458              		.cfi_offset 5, -16
 1459              		.cfi_offset 6, -12
 1460              		.cfi_offset 7, -8
 1461              		.cfi_offset 14, -4
 1462 0002 4746     		mov	r7, r8
 1463 0004 80B4     		push	{r7}
 1464              	.LCFI11:
 1465              		.cfi_def_cfa_offset 24
 1466              		.cfi_offset 8, -24
 550:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 551:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 552:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 553:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in BLPE mode
 554:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1467              		.loc 1 554 0
 1468 0006 324D     		ldr	r5, .L272
 549:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1469              		.loc 1 549 0
 1470 0008 041C     		mov	r4, r0
 1471              		.loc 1 554 0
 1472 000a AE79     		ldrb	r6, [r5, #6]
 1473 000c 3007     		lsl	r0, r6, #28
 1474              	.LVL126:
 1475 000e 860F     		lsr	r6, r0, #30
 1476 0010 022E     		cmp	r6, #2
 1477 0012 04D0     		beq	.L265
 1478              	.L254:
 555:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 556:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 557:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 558:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x6;                                                       // return error code
 1479              		.loc 1 558 0
 1480 0014 0624     		mov	r4, #6
 1481              	.LVL127:
 1482              	.L247:
 559:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 560:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 561:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // As the external frequency has already been checked when FBE mode was enterred it is not checked 
 562:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 563:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check PLL divider settings are within spec.
 564:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 565:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 566:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 567:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check PLL reference clock frequency is within spec.
 568:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 569:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****        
 570:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
 571:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 572:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Configure MCG_C5
 573:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code
 574:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 575:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 576:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 577:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 578:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 579:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Configure MCG_C6
 580:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
 581:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // The clock monitor is not enabled here as it has likely been enabled previously and so the value 
 582:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // is not altered here.
 583:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
 584:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 585:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 586:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 587:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 588:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 589:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now that PLL is configured, LP is cleared to enable the PLL
 590:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 591:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 592:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for PLLST status bit to set
 593:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 594:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 595:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 596:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 597:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 598:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 599:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for LOCK bit to set
 600:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 601:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 602:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 603:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 604:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 605:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 606:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // now in PBE 
 607:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 608:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // blpe_pbe
 1483              		.loc 1 608 0
 1484 0016 201C     		mov	r0, r4
 1485              		@ sp needed for prologue
 1486 0018 04BC     		pop	{r2}
 1487 001a 9046     		mov	r8, r2
 1488 001c F0BD     		pop	{r4, r5, r6, r7, pc}
 1489              	.LVL128:
 1490              	.L265:
 555:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1491              		.loc 1 555 0
 1492 001e AB79     		ldrb	r3, [r5, #6]
 554:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1493              		.loc 1 554 0
 1494 0020 D806     		lsl	r0, r3, #27
 1495 0022 F7D4     		bmi	.L254
 556:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 1496              		.loc 1 556 0
 1497 0024 6F78     		ldrb	r7, [r5, #1]
 554:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1498              		.loc 1 554 0
 1499 0026 3E42     		tst	r6, r7
 1500 0028 F4D0     		beq	.L254
 564:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
 1501              		.loc 1 564 0
 1502 002a 481E     		sub	r0, r1, #1
 1503 002c C7B2     		uxtb	r7, r0
 1504 002e 182F     		cmp	r7, #24
 1505 0030 01D9     		bls	.L266
 1506 0032 4124     		mov	r4, #65
 1507              	.LVL129:
 1508 0034 EFE7     		b	.L247
 1509              	.LVL130:
 1510              	.L266:
 565:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
 1511              		.loc 1 565 0
 1512 0036 183A     		sub	r2, r2, #24
 1513              	.LVL131:
 1514 0038 D2B2     		uxtb	r2, r2
 1515 003a 9046     		mov	r8, r2
 1516 003c 1A2A     		cmp	r2, #26
 1517 003e 01D9     		bls	.L267
 1518 0040 4224     		mov	r4, #66
 1519              	.LVL132:
 1520 0042 E8E7     		b	.L247
 1521              	.LVL133:
 1522              	.L267:
 568:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;
 1523              		.loc 1 568 0
 1524 0044 201C     		mov	r0, r4
 1525 0046 FFF7FEFF 		bl	__aeabi_idiv
 1526              	.LVL134:
 1527 004a 2249     		ldr	r1, .L272+4
 1528 004c 224B     		ldr	r3, .L272+8
 1529 004e 4018     		add	r0, r0, r1
 1530 0050 9842     		cmp	r0, r3
 1531 0052 01D9     		bls	.L268
 1532 0054 4324     		mov	r4, #67
 1533              	.LVL135:
 1534 0056 DEE7     		b	.L247
 1535              	.LVL136:
 1536              	.L268:
 574:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C5;
 1537              		.loc 1 574 0
 1538 0058 2A79     		ldrb	r2, [r5, #4]
 1539              	.LVL137:
 575:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C5_PRDIV0_MASK;
 1540              		.loc 1 575 0
 1541 005a 1F21     		mov	r1, #31
 1542 005c 8A43     		bic	r2, r1
 1543              	.LVL138:
 576:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
 1544              		.loc 1 576 0
 1545 005e 1743     		orr	r7, r2
 1546              	.LVL139:
 577:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C5 = temp_reg;
 1547              		.loc 1 577 0
 1548 0060 2F71     		strb	r7, [r5, #4]
 584:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C6; // store present C6 value
 1549              		.loc 1 584 0
 1550 0062 6F79     		ldrb	r7, [r5, #5]
 1551              	.LVL140:
 586:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1552              		.loc 1 586 0
 1553 0064 4023     		mov	r3, #64
 585:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
 1554              		.loc 1 585 0
 1555 0066 8F43     		bic	r7, r1
 1556              	.LVL141:
 1557 0068 381C     		mov	r0, r7
 586:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
 1558              		.loc 1 586 0
 1559 006a 1843     		orr	r0, r3
 1560 006c 4246     		mov	r2, r8
 1561 006e 1043     		orr	r0, r2
 1562              	.LVL142:
 587:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 = temp_reg; // update MCG_C6
 1563              		.loc 1 587 0
 1564 0070 6871     		strb	r0, [r5, #5]
 590:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 1565              		.loc 1 590 0
 1566 0072 6978     		ldrb	r1, [r5, #1]
 595:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1567              		.loc 1 595 0
 1568 0074 2027     		mov	r7, #32
 590:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 1569              		.loc 1 590 0
 1570 0076 B143     		bic	r1, r6
 1571 0078 FA26     		mov	r6, #250
 1572 007a 6970     		strb	r1, [r5, #1]
 1573              	.LVL143:
 1574 007c F100     		lsl	r1, r6, #3
 1575 007e 08E0     		b	.L249
 1576              	.LVL144:
 1577              	.L269:
 595:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1578              		.loc 1 595 0
 1579 0080 AA79     		ldrb	r2, [r5, #6]
 1580 0082 0139     		sub	r1, r1, #1
 1581 0084 8BB2     		uxth	r3, r1
 1582 0086 1742     		tst	r7, r2
 1583 0088 06D1     		bne	.L248
 1584 008a 013B     		sub	r3, r3, #1
 1585 008c 99B2     		uxth	r1, r3
 593:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1586              		.loc 1 593 0
 1587 008e 0029     		cmp	r1, #0
 1588 0090 02D0     		beq	.L248
 1589              	.L249:
 595:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
 1590              		.loc 1 595 0
 1591 0092 A879     		ldrb	r0, [r5, #6]
 1592 0094 0742     		tst	r7, r0
 1593 0096 F3D0     		beq	.L269
 1594              	.L248:
 597:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if
 1595              		.loc 1 597 0
 1596 0098 0D4D     		ldr	r5, .L272
 1597 009a AE79     		ldrb	r6, [r5, #6]
 1598 009c B006     		lsl	r0, r6, #26
 1599 009e 01D4     		bmi	.L270
 1600 00a0 1624     		mov	r4, #22
 1601              	.LVL145:
 1602 00a2 B8E7     		b	.L247
 1603              	.LVL146:
 1604              	.L270:
 1605 00a4 FA27     		mov	r7, #250
 1606 00a6 FE00     		lsl	r6, r7, #3
 602:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1607              		.loc 1 602 0
 1608 00a8 4023     		mov	r3, #64
 1609 00aa 08E0     		b	.L251
 1610              	.L271:
 1611 00ac A979     		ldrb	r1, [r5, #6]
 1612 00ae 013E     		sub	r6, r6, #1
 1613 00b0 B2B2     		uxth	r2, r6
 1614 00b2 0B42     		tst	r3, r1
 1615 00b4 06D1     		bne	.L250
 1616 00b6 013A     		sub	r2, r2, #1
 1617 00b8 96B2     		uxth	r6, r2
 600:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1618              		.loc 1 600 0
 1619 00ba 002E     		cmp	r6, #0
 1620 00bc 02D0     		beq	.L250
 1621              	.L251:
 602:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
 1622              		.loc 1 602 0
 1623 00be A879     		ldrb	r0, [r5, #6]
 1624 00c0 0342     		tst	r3, r0
 1625 00c2 F3D0     		beq	.L271
 1626              	.L250:
 604:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if
 1627              		.loc 1 604 0
 1628 00c4 024D     		ldr	r5, .L272
 1629 00c6 AF79     		ldrb	r7, [r5, #6]
 1630 00c8 7906     		lsl	r1, r7, #25
 1631 00ca A4D4     		bmi	.L247
 1632 00cc 4424     		mov	r4, #68
 1633              	.LVL147:
 1634 00ce A2E7     		b	.L247
 1635              	.L273:
 1636              		.align	2
 1637              	.L272:
 1638 00d0 00400640 		.word	1074151424
 1639 00d4 807BE1FF 		.word	-2000000
 1640 00d8 80841E00 		.word	2000000
 1641              		.cfi_endproc
 1642              	.LFE7:
 1644              		.section	.text.blpe_fbe,"ax",%progbits
 1645              		.align	2
 1646              		.global	blpe_fbe
 1647              		.code	16
 1648              		.thumb_func
 1650              	blpe_fbe:
 1651              	.LFB8:
 609:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 610:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 611:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int blpe_fbe(int crystal_val)
 612:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1652              		.loc 1 612 0
 1653              		.cfi_startproc
 1654              	.LVL148:
 1655 0000 10B5     		push	{r4, lr}
 1656              	.LCFI12:
 1657              		.cfi_def_cfa_offset 8
 1658              		.cfi_offset 4, -8
 1659              		.cfi_offset 14, -4
 613:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 614:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 615:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in BLPE mode
 616:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1660              		.loc 1 616 0
 1661 0002 154B     		ldr	r3, .L293
 1662 0004 9A79     		ldrb	r2, [r3, #6]
 1663 0006 1107     		lsl	r1, r2, #28
 1664 0008 8A0F     		lsr	r2, r1, #30
 1665 000a 022A     		cmp	r2, #2
 1666 000c 01D0     		beq	.L291
 1667              	.L280:
 617:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 618:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 619:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 620:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x6;                                                       // return error code
 1668              		.loc 1 620 0
 1669 000e 0620     		mov	r0, #6
 1670              	.LVL149:
 1671              	.L275:
 621:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 622:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
 623:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cle
 624:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
 625:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
 626:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 627:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for PLLST status bit to clear
 628:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 629:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 630:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 631:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 632:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 633:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 634:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // now in FBE mode
 635:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 636:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // blpe_fbe
 1672              		.loc 1 636 0
 1673              		@ sp needed for prologue
 1674 0010 10BD     		pop	{r4, pc}
 1675              	.LVL150:
 1676              	.L291:
 617:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1677              		.loc 1 617 0
 1678 0012 9C79     		ldrb	r4, [r3, #6]
 616:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1679              		.loc 1 616 0
 1680 0014 E406     		lsl	r4, r4, #27
 1681 0016 FAD4     		bmi	.L280
 618:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is se
 1682              		.loc 1 618 0
 1683 0018 5978     		ldrb	r1, [r3, #1]
 616:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1684              		.loc 1 616 0
 1685 001a 0A42     		tst	r2, r1
 1686 001c F7D0     		beq	.L280
 624:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
 1687              		.loc 1 624 0
 1688 001e 5979     		ldrb	r1, [r3, #5]
 1689 0020 4024     		mov	r4, #64
 1690 0022 A143     		bic	r1, r4
 1691 0024 5971     		strb	r1, [r3, #5]
 625:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
 1692              		.loc 1 625 0
 1693 0026 5978     		ldrb	r1, [r3, #1]
 1694 0028 FA24     		mov	r4, #250
 1695 002a 9143     		bic	r1, r2
 1696 002c 5970     		strb	r1, [r3, #1]
 1697              	.LVL151:
 1698 002e E200     		lsl	r2, r4, #3
 630:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1699              		.loc 1 630 0
 1700 0030 2021     		mov	r1, #32
 1701 0032 08E0     		b	.L277
 1702              	.LVL152:
 1703              	.L292:
 1704 0034 9C79     		ldrb	r4, [r3, #6]
 1705 0036 013A     		sub	r2, r2, #1
 1706 0038 92B2     		uxth	r2, r2
 1707 003a 2142     		tst	r1, r4
 1708 003c 06D0     		beq	.L276
 1709 003e 013A     		sub	r2, r2, #1
 1710 0040 92B2     		uxth	r2, r2
 628:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1711              		.loc 1 628 0
 1712 0042 002A     		cmp	r2, #0
 1713 0044 02D0     		beq	.L276
 1714              	.L277:
 630:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
 1715              		.loc 1 630 0
 1716 0046 9C79     		ldrb	r4, [r3, #6]
 1717 0048 2142     		tst	r1, r4
 1718 004a F3D1     		bne	.L292
 1719              	.L276:
 632:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if 
 1720              		.loc 1 632 0
 1721 004c 024B     		ldr	r3, .L293
 1722 004e 9979     		ldrb	r1, [r3, #6]
 1723 0050 8A06     		lsl	r2, r1, #26
 1724 0052 DDD5     		bpl	.L275
 1725 0054 1520     		mov	r0, #21
 1726              	.LVL153:
 1727 0056 DBE7     		b	.L275
 1728              	.L294:
 1729              		.align	2
 1730              	.L293:
 1731 0058 00400640 		.word	1074151424
 1732              		.cfi_endproc
 1733              	.LFE8:
 1735              		.section	.text.fbe_blpe,"ax",%progbits
 1736              		.align	2
 1737              		.global	fbe_blpe
 1738              		.code	16
 1739              		.thumb_func
 1741              	fbe_blpe:
 1742              	.LFB9:
 637:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 638:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 639:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbe_blpe(int crystal_val)
 640:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1743              		.loc 1 640 0
 1744              		.cfi_startproc
 1745              	.LVL154:
 1746 0000 10B5     		push	{r4, lr}
 1747              	.LCFI13:
 1748              		.cfi_def_cfa_offset 8
 1749              		.cfi_offset 4, -8
 1750              		.cfi_offset 14, -4
 641:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FBE mode
 642:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1751              		.loc 1 642 0
 1752 0002 0B4B     		ldr	r3, .L302
 1753 0004 9A79     		ldrb	r2, [r3, #6]
 1754 0006 1107     		lsl	r1, r2, #28
 1755 0008 8A0F     		lsr	r2, r1, #30
 1756 000a 022A     		cmp	r2, #2
 1757 000c 01D0     		beq	.L301
 1758              	.L300:
 643:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 644:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 645:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 646:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 647:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 1759              		.loc 1 647 0
 1760 000e 0420     		mov	r0, #4
 1761              	.LVL155:
 1762              	.L296:
 648:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 649:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
 650:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // To move from FBE to BLPE the LP bit must be set
 651:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
 652:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
 653:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // now in FBE mode
 654:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 655:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbe_blpe
 1763              		.loc 1 655 0
 1764              		@ sp needed for prologue
 1765 0010 10BD     		pop	{r4, pc}
 1766              	.LVL156:
 1767              	.L301:
 643:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1768              		.loc 1 643 0
 1769 0012 9C79     		ldrb	r4, [r3, #6]
 642:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1770              		.loc 1 642 0
 1771 0014 E406     		lsl	r4, r4, #27
 1772 0016 FAD4     		bmi	.L300
 644:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 1773              		.loc 1 644 0
 1774 0018 9979     		ldrb	r1, [r3, #6]
 643:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 1775              		.loc 1 643 0
 1776 001a 8C06     		lsl	r4, r1, #26
 1777 001c F7D4     		bmi	.L300
 645:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 1778              		.loc 1 645 0
 1779 001e 5C78     		ldrb	r4, [r3, #1]
 642:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 1780              		.loc 1 642 0
 1781 0020 2242     		tst	r2, r4
 1782 0022 F4D1     		bne	.L300
 651:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
 1783              		.loc 1 651 0
 1784 0024 5978     		ldrb	r1, [r3, #1]
 1785 0026 0A43     		orr	r2, r1
 1786 0028 D2B2     		uxtb	r2, r2
 1787 002a 5A70     		strb	r2, [r3, #1]
 654:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency     
 1788              		.loc 1 654 0
 1789 002c F0E7     		b	.L296
 1790              	.L303:
 1791 002e C046     		.align	2
 1792              	.L302:
 1793 0030 00400640 		.word	1074151424
 1794              		.cfi_endproc
 1795              	.LFE9:
 1797              		.section	.text.fei_fbe,"ax",%progbits
 1798              		.align	2
 1799              		.global	fei_fbe
 1800              		.code	16
 1801              		.thumb_func
 1803              	fei_fbe:
 1804              	.LFB11:
 656:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 657:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 658:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbe_fei(int slow_irc_freq)
 659:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 660:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 661:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 662:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int mcg_out;
 663:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 664:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FBE mode
 665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 666:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 667:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 668:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 669:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 670:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 671:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 672:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 673:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check IRC frequency is within spec.
 674:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 675:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 676:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x31;
 677:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 678:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 679:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check resulting FLL frequency 
 680:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 681:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 682:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 683:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
 684:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 685:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 686:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
 687:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 688:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 689:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 691:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 692:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to set
 693:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 694:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 696:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 697:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 698:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 699:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
 700:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 701:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 702:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 703:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 704:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is re
 705:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 706:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FEI mode
 707:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out;
 708:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbe_fei
 709:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 710:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 711:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
 712:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : fei_fbe
 713:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 714:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: FEI to FBE mode
 715:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 716:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function transitions the MCG from FEI mode to FBE mode. This is
 717:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
 718:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * check so 0 is always returned if the function was called with the MCG
 719:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
 720:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 721:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
 722:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
 723:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           for the crystal oscillator. This has no meaning if an 
 724:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           external clock is used.
 725:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
 726:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
 727:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
 728:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
 729:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 730:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 1805              		.loc 1 730 0
 1806              		.cfi_startproc
 1807              	.LVL157:
 1808 0000 70B5     		push	{r4, r5, r6, lr}
 1809              	.LCFI14:
 1810              		.cfi_def_cfa_offset 16
 1811              		.cfi_offset 4, -16
 1812              		.cfi_offset 5, -12
 1813              		.cfi_offset 6, -8
 1814              		.cfi_offset 14, -4
 731:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char frdiv_val;
 732:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 733:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 734:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 735:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check if in FEI mode
 736:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 1815              		.loc 1 736 0
 1816 0002 5C4B     		ldr	r3, .L371
 1817 0004 9C79     		ldrb	r4, [r3, #6]
 1818 0006 2507     		lsl	r5, r4, #28
 1819 0008 AE0F     		lsr	r6, r5, #30
 1820 000a 0AD1     		bne	.L319
 737:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 1821              		.loc 1 737 0
 1822 000c 9C79     		ldrb	r4, [r3, #6]
 736:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 1823              		.loc 1 736 0
 1824 000e E506     		lsl	r5, r4, #27
 1825 0010 07D5     		bpl	.L319
 738:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 1826              		.loc 1 738 0
 1827 0012 9B79     		ldrb	r3, [r3, #6]
 736:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 1828              		.loc 1 736 0
 1829 0014 9C06     		lsl	r4, r3, #26
 1830 0016 04D4     		bmi	.L319
 739:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 740:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                     // return error code
 741:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 742:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 743:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check external frequency is less than the maximum frequency
 744:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 1831              		.loc 1 744 0
 1832 0018 574D     		ldr	r5, .L371+4
 1833 001a A842     		cmp	r0, r5
 1834 001c 03DD     		ble	.L363
 1835 001e 2120     		mov	r0, #33
 1836              	.LVL158:
 1837 0020 00E0     		b	.L305
 1838              	.LVL159:
 1839              	.L319:
 740:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                     // return error code
 1840              		.loc 1 740 0
 1841 0022 0120     		mov	r0, #1
 1842              	.LVL160:
 1843              	.L305:
 745:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 746:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
 747:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 748:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 749:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 751:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 752:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 753:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 754:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
 755:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (hgo_val > 0)
 756:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 757:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 758:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 759:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 760:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // configure the MCG_C2 register
 761:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
 762:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
 763:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 764:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 765:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 766:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 767:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 768:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 769:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
 770:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 771:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 772:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 773:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 774:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 775:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 776:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 777:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 778:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // determine FRDIV based on reference clock frequency
 779:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
 780:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 781:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 782:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 783:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 784:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 785:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
 786:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 787:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
 788:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
 789:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
 790:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 791:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 792:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 793:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 794:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 795:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
 796:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 797:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 798:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 799:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
 800:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 801:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
 802:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 803:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 804:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 805:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to clear
 806:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 807:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 808:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 809:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 810:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 811:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 812:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
 813:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 814:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 815:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 816:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 817:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 818:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
 819:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBE  
 820:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
 821:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is enabled here but can be removed if this is not required.
 822:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 823:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 824:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 825:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fei_fbe
 1844              		.loc 1 825 0
 1845              		@ sp needed for prologue
 1846 0024 70BD     		pop	{r4, r5, r6, pc}
 1847              	.LVL161:
 1848              	.L363:
 747:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 1849              		.loc 1 747 0
 1850 0026 002A     		cmp	r2, #0
 1851 0028 2FD1     		bne	.L364
 1852              	.L306:
 757:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 1853              		.loc 1 757 0
 1854 002a 4B1E     		sub	r3, r1, #1
 1855 002c 9941     		sbc	r1, r1, r3
 1856              	.LVL162:
 763:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 1857              		.loc 1 763 0
 1858 002e 514B     		ldr	r3, .L371
 764:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 1859              		.loc 1 764 0
 1860 0030 3C25     		mov	r5, #60
 763:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 1861              		.loc 1 763 0
 1862 0032 5C78     		ldrb	r4, [r3, #1]
 1863              	.LVL163:
 765:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 1864              		.loc 1 765 0
 1865 0034 514E     		ldr	r6, .L371+8
 764:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 1866              		.loc 1 764 0
 1867 0036 AC43     		bic	r4, r5
 1868              	.LVL164:
 1869 0038 251C     		mov	r5, r4
 1870              	.LVL165:
 765:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 1871              		.loc 1 765 0
 1872 003a B042     		cmp	r0, r6
 1873 003c 51DC     		bgt	.L307
 767:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 1874              		.loc 1 767 0
 1875 003e 9400     		lsl	r4, r2, #2
 1876              	.LVL166:
 1877 0040 2543     		orr	r5, r4
 1878              	.LVL167:
 1879 0042 EDB2     		uxtb	r5, r5
 1880 0044 C900     		lsl	r1, r1, #3
 1881 0046 2943     		orr	r1, r5
 1882              	.LVL168:
 777:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 1883              		.loc 1 777 0
 1884 0048 5970     		strb	r1, [r3, #1]
 1885 004a 0023     		mov	r3, #0
 1886              	.LVL169:
 1887              	.L308:
 790:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 1888              		.loc 1 790 0
 1889 004c 494E     		ldr	r6, .L371
 791:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 1890              		.loc 1 791 0
 1891 004e 0325     		mov	r5, #3
 790:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 1892              		.loc 1 790 0
 1893 0050 3478     		ldrb	r4, [r6]
 1894              	.LVL170:
 792:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 1895              		.loc 1 792 0
 1896 0052 8021     		mov	r1, #128
 791:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 1897              		.loc 1 791 0
 1898 0054 2C40     		and	r4, r5
 1899              	.LVL171:
 792:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 1900              		.loc 1 792 0
 1901 0056 0C43     		orr	r4, r1
 1902 0058 2343     		orr	r3, r4
 1903              	.LVL172:
 793:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 1904              		.loc 1 793 0
 1905 005a 3370     		strb	r3, [r6]
 796:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 1906              		.loc 1 796 0
 1907 005c 002A     		cmp	r2, #0
 1908 005e 23D0     		beq	.L311
 1909 0060 4749     		ldr	r1, .L371+12
 800:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 1910              		.loc 1 800 0
 1911 0062 0222     		mov	r2, #2
 1912              	.LVL173:
 1913 0064 08E0     		b	.L313
 1914              	.LVL174:
 1915              	.L365:
 1916 0066 B579     		ldrb	r5, [r6, #6]
 1917 0068 0139     		sub	r1, r1, #1
 1918 006a 8BB2     		uxth	r3, r1
 1919 006c 2A42     		tst	r2, r5
 1920 006e 06D1     		bne	.L312
 1921 0070 013B     		sub	r3, r3, #1
 1922 0072 99B2     		uxth	r1, r3
 798:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 1923              		.loc 1 798 0
 1924 0074 0029     		cmp	r1, #0
 1925 0076 02D0     		beq	.L312
 1926              	.L313:
 800:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 1927              		.loc 1 800 0
 1928 0078 B479     		ldrb	r4, [r6, #6]
 1929 007a 2242     		tst	r2, r4
 1930 007c F3D0     		beq	.L365
 1931              	.L312:
 802:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 1932              		.loc 1 802 0
 1933 007e 3D4E     		ldr	r6, .L371
 1934 0080 B279     		ldrb	r2, [r6, #6]
 1935 0082 9207     		lsl	r2, r2, #30
 1936 0084 10D4     		bmi	.L311
 1937 0086 2320     		mov	r0, #35
 1938              	.LVL175:
 1939 0088 CCE7     		b	.L305
 1940              	.LVL176:
 1941              	.L364:
 749:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 1942              		.loc 1 749 0
 1943 008a 3E4E     		ldr	r6, .L371+16
 1944 008c B042     		cmp	r0, r6
 1945 008e 01DC     		bgt	.L366
 1946              	.L323:
 751:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 1947              		.loc 1 751 0
 1948 0090 2220     		mov	r0, #34
 1949              	.LVL177:
 1950 0092 C7E7     		b	.L305
 1951              	.LVL178:
 1952              	.L366:
 750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 1953              		.loc 1 750 0
 1954 0094 3C4C     		ldr	r4, .L371+20
 749:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 1955              		.loc 1 749 0
 1956 0096 3D4B     		ldr	r3, .L371+24
 750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 1957              		.loc 1 750 0
 1958 0098 0519     		add	r5, r0, r4
 749:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 1959              		.loc 1 749 0
 1960 009a 9D42     		cmp	r5, r3
 1961 009c F8D9     		bls	.L323
 750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 1962              		.loc 1 750 0
 1963 009e 3C4E     		ldr	r6, .L371+28
 1964 00a0 B042     		cmp	r0, r6
 1965 00a2 C2DD     		ble	.L306
 751:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 1966              		.loc 1 751 0
 1967 00a4 2220     		mov	r0, #34
 1968              	.LVL179:
 1969 00a6 BDE7     		b	.L305
 1970              	.LVL180:
 1971              	.L311:
 808:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 1972              		.loc 1 808 0
 1973 00a8 324D     		ldr	r5, .L371
 1974 00aa 1021     		mov	r1, #16
 1975 00ac AC79     		ldrb	r4, [r5, #6]
 1976 00ae 2142     		tst	r1, r4
 1977 00b0 11D0     		beq	.L314
 1978 00b2 AE79     		ldrb	r6, [r5, #6]
 1979 00b4 374B     		ldr	r3, .L371+32
 1980 00b6 3142     		tst	r1, r6
 1981 00b8 0DD0     		beq	.L314
 1982 00ba 013B     		sub	r3, r3, #1
 1983 00bc 08E0     		b	.L339
 1984              	.L367:
 1985 00be AC79     		ldrb	r4, [r5, #6]
 1986 00c0 013B     		sub	r3, r3, #1
 1987 00c2 9BB2     		uxth	r3, r3
 1988 00c4 2142     		tst	r1, r4
 1989 00c6 06D0     		beq	.L314
 1990 00c8 013B     		sub	r3, r3, #1
 1991 00ca 9BB2     		uxth	r3, r3
 806:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 1992              		.loc 1 806 0
 1993 00cc 002B     		cmp	r3, #0
 1994 00ce 02D0     		beq	.L314
 1995              	.L339:
 808:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 1996              		.loc 1 808 0
 1997 00d0 AA79     		ldrb	r2, [r5, #6]
 1998 00d2 1142     		tst	r1, r2
 1999 00d4 F3D1     		bne	.L367
 2000              	.L314:
 810:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2001              		.loc 1 810 0
 2002 00d6 274D     		ldr	r5, .L371
 2003 00d8 A979     		ldrb	r1, [r5, #6]
 2004 00da CC06     		lsl	r4, r1, #27
 2005 00dc 2BD5     		bpl	.L368
 2006 00de 1120     		mov	r0, #17
 2007              	.LVL181:
 2008 00e0 A0E7     		b	.L305
 2009              	.LVL182:
 2010              	.L307:
 769:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
 2011              		.loc 1 769 0
 2012 00e2 2D4C     		ldr	r4, .L371+36
 2013              	.LVL183:
 2014 00e4 A042     		cmp	r0, r4
 2015 00e6 1DDC     		bgt	.L309
 771:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2016              		.loc 1 771 0
 2017 00e8 1026     		mov	r6, #16
 2018 00ea 3543     		orr	r5, r6
 2019              	.LVL184:
 2020 00ec 9400     		lsl	r4, r2, #2
 2021 00ee 2543     		orr	r5, r4
 2022 00f0 EDB2     		uxtb	r5, r5
 2023 00f2 C900     		lsl	r1, r1, #3
 780:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2024              		.loc 1 780 0
 2025 00f4 294E     		ldr	r6, .L371+40
 771:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2026              		.loc 1 771 0
 2027 00f6 2943     		orr	r1, r5
 2028              	.LVL185:
 777:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 2029              		.loc 1 777 0
 2030 00f8 5970     		strb	r1, [r3, #1]
 780:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2031              		.loc 1 780 0
 2032 00fa 0023     		mov	r3, #0
 2033 00fc B042     		cmp	r0, r6
 2034 00fe A5DD     		ble	.L308
 2035              	.LVL186:
 2036              	.L310:
 781:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 2037              		.loc 1 781 0
 2038 0100 274C     		ldr	r4, .L371+44
 2039 0102 0823     		mov	r3, #8
 2040 0104 A042     		cmp	r0, r4
 2041 0106 A1DD     		ble	.L308
 782:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 2042              		.loc 1 782 0
 2043 0108 264D     		ldr	r5, .L371+48
 2044 010a 1023     		mov	r3, #16
 2045 010c A842     		cmp	r0, r5
 2046 010e 9DDD     		ble	.L308
 783:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 2047              		.loc 1 783 0
 2048 0110 2549     		ldr	r1, .L371+52
 2049 0112 1823     		mov	r3, #24
 2050 0114 8842     		cmp	r0, r1
 2051 0116 99DD     		ble	.L308
 784:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2052              		.loc 1 784 0
 2053 0118 244E     		ldr	r6, .L371+56
 2054 011a 2823     		mov	r3, #40
 2055 011c B042     		cmp	r0, r6
 2056 011e 95DC     		bgt	.L308
 2057 0120 2023     		mov	r3, #32
 2058 0122 93E7     		b	.L308
 2059              	.LVL187:
 2060              	.L309:
 775:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2061              		.loc 1 775 0
 2062 0124 2026     		mov	r6, #32
 2063 0126 3543     		orr	r5, r6
 2064              	.LVL188:
 2065 0128 9400     		lsl	r4, r2, #2
 2066 012a 2543     		orr	r5, r4
 2067 012c EDB2     		uxtb	r5, r5
 2068 012e C900     		lsl	r1, r1, #3
 2069 0130 2943     		orr	r1, r5
 2070              	.LVL189:
 777:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 2071              		.loc 1 777 0
 2072 0132 5970     		strb	r1, [r3, #1]
 2073 0134 E4E7     		b	.L310
 2074              	.LVL190:
 2075              	.L368:
 810:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2076              		.loc 1 810 0
 2077 0136 FA26     		mov	r6, #250
 2078 0138 F600     		lsl	r6, r6, #3
 815:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2079              		.loc 1 815 0
 2080 013a 0C22     		mov	r2, #12
 2081 013c 09E0     		b	.L316
 2082              	.L369:
 2083 013e A979     		ldrb	r1, [r5, #6]
 2084 0140 013E     		sub	r6, r6, #1
 2085 0142 B3B2     		uxth	r3, r6
 2086 0144 1140     		and	r1, r2
 2087 0146 0829     		cmp	r1, #8
 2088 0148 07D0     		beq	.L315
 2089 014a 013B     		sub	r3, r3, #1
 2090 014c 9EB2     		uxth	r6, r3
 813:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2091              		.loc 1 813 0
 2092 014e 002E     		cmp	r6, #0
 2093 0150 03D0     		beq	.L315
 2094              	.L316:
 815:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2095              		.loc 1 815 0
 2096 0152 AC79     		ldrb	r4, [r5, #6]
 2097 0154 1440     		and	r4, r2
 2098 0156 082C     		cmp	r4, #8
 2099 0158 F1D1     		bne	.L369
 2100              	.L315:
 817:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 2101              		.loc 1 817 0
 2102 015a 064D     		ldr	r5, .L371
 2103 015c AA79     		ldrb	r2, [r5, #6]
 2104 015e 1407     		lsl	r4, r2, #28
 2105 0160 A30F     		lsr	r3, r4, #30
 2106 0162 022B     		cmp	r3, #2
 2107 0164 01D0     		beq	.L370
 2108 0166 1A20     		mov	r0, #26
 2109              	.LVL191:
 2110 0168 5CE7     		b	.L305
 2111              	.LVL192:
 2112              	.L370:
 822:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 2113              		.loc 1 822 0
 2114 016a 6979     		ldrb	r1, [r5, #5]
 2115 016c 2026     		mov	r6, #32
 2116 016e 0E43     		orr	r6, r1
 2117 0170 6E71     		strb	r6, [r5, #5]
 824:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency
 2118              		.loc 1 824 0
 2119 0172 57E7     		b	.L305
 2120              	.L372:
 2121              		.align	2
 2122              	.L371:
 2123 0174 00400640 		.word	1074151424
 2124 0178 80F0FA02 		.word	50000000
 2125 017c 409C0000 		.word	40000
 2126 0180 10270000 		.word	10000
 2127 0184 2F750000 		.word	29999
 2128 0188 BF63FFFF 		.word	-40001
 2129 018c 7E2A2D00 		.word	2959998
 2130 0190 0048E801 		.word	32000000
 2131 0194 CF070000 		.word	1999
 2132 0198 00127A00 		.word	8000000
 2133 019c D0121300 		.word	1250000
 2134 01a0 A0252600 		.word	2500000
 2135 01a4 404B4C00 		.word	5000000
 2136 01a8 80969800 		.word	10000000
 2137 01ac 002D3101 		.word	20000000
 2138              		.cfi_endproc
 2139              	.LFE11:
 2141              		.section	.text.fee_fbe,"ax",%progbits
 2142              		.align	2
 2143              		.global	fee_fbe
 2144              		.code	16
 2145              		.thumb_func
 2147              	fee_fbe:
 2148              	.LFB13:
 826:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 827:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 828:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbe_fee(int crystal_val)
 829:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 830:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i, fll_ref_freq;
 831:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int mcg_out;
 832:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 833:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FBE mode
 834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 835:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 836:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 837:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 838:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 839:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 840:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 841:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 842:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
 843:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 844:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 845:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
 846:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 847:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 848:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 849:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)))
 850:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 851:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 852:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check resulting FLL frequency 
 853:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 854:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 855:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 856:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Clear CLKS field to switch CLKS mux to select FLL output
 857:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 858:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 859:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to show clock source is FLL
 860:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 861:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 862:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 863:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 864:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 865:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 866:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FEE mode
 867:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out;
 868:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbe_fee
 869:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 870:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 871:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fee_fbe(int crystal_val)
 872:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** { 
 2149              		.loc 1 872 0
 2150              		.cfi_startproc
 2151              	.LVL193:
 2152 0000 10B5     		push	{r4, lr}
 2153              	.LCFI15:
 2154              		.cfi_def_cfa_offset 8
 2155              		.cfi_offset 4, -8
 2156              		.cfi_offset 14, -4
 873:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 874:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 875:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FEE mode
 876:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2157              		.loc 1 876 0
 2158 0002 154B     		ldr	r3, .L392
 2159 0004 9A79     		ldrb	r2, [r3, #6]
 2160 0006 1107     		lsl	r1, r2, #28
 2161 0008 8C0F     		lsr	r4, r1, #30
 2162 000a 01D0     		beq	.L390
 2163              	.L379:
 877:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 878:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 879:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 880:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x2;                                                       // return error code
 2164              		.loc 1 880 0
 2165 000c 0220     		mov	r0, #2
 2166              	.LVL194:
 2167              	.L374:
 881:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 882:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 883:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
 884:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
 885:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
 886:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 887:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /// Wait for clock status bits to show clock source is ext ref clk
 888:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 889:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 890:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 891:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 892:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 893:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 894:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBE mode
 895:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val;
 896:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fee_fbe
 2168              		.loc 1 896 0
 2169              		@ sp needed for prologue
 2170 000e 10BD     		pop	{r4, pc}
 2171              	.LVL195:
 2172              	.L390:
 877:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2173              		.loc 1 877 0
 2174 0010 9A79     		ldrb	r2, [r3, #6]
 876:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2175              		.loc 1 876 0
 2176 0012 D106     		lsl	r1, r2, #27
 2177 0014 FAD4     		bmi	.L379
 878:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 2178              		.loc 1 878 0
 2179 0016 9979     		ldrb	r1, [r3, #6]
 876:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 2180              		.loc 1 876 0
 2181 0018 8906     		lsl	r1, r1, #26
 2182 001a F7D4     		bmi	.L379
 885:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
 2183              		.loc 1 885 0
 2184 001c 1C78     		ldrb	r4, [r3]
 2185 001e 8022     		mov	r2, #128
 2186 0020 2243     		orr	r2, r4
 2187 0022 FA21     		mov	r1, #250
 2188 0024 1A70     		strb	r2, [r3]
 2189              	.LVL196:
 2190 0026 CA00     		lsl	r2, r1, #3
 890:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2191              		.loc 1 890 0
 2192 0028 0C21     		mov	r1, #12
 2193 002a 09E0     		b	.L376
 2194              	.LVL197:
 2195              	.L391:
 2196 002c 9C79     		ldrb	r4, [r3, #6]
 2197 002e 013A     		sub	r2, r2, #1
 2198 0030 92B2     		uxth	r2, r2
 2199 0032 0C40     		and	r4, r1
 2200 0034 082C     		cmp	r4, #8
 2201 0036 07D0     		beq	.L375
 2202 0038 013A     		sub	r2, r2, #1
 2203 003a 92B2     		uxth	r2, r2
 888:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2204              		.loc 1 888 0
 2205 003c 002A     		cmp	r2, #0
 2206 003e 03D0     		beq	.L375
 2207              	.L376:
 890:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2208              		.loc 1 890 0
 2209 0040 9C79     		ldrb	r4, [r3, #6]
 2210 0042 0C40     		and	r4, r1
 2211 0044 082C     		cmp	r4, #8
 2212 0046 F1D1     		bne	.L391
 2213              	.L375:
 892:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 2214              		.loc 1 892 0
 2215 0048 034B     		ldr	r3, .L392
 2216 004a 9979     		ldrb	r1, [r3, #6]
 2217 004c 0C07     		lsl	r4, r1, #28
 2218 004e A20F     		lsr	r2, r4, #30
 2219 0050 022A     		cmp	r2, #2
 2220 0052 DCD0     		beq	.L374
 2221 0054 1A20     		mov	r0, #26
 2222              	.LVL198:
 2223 0056 DAE7     		b	.L374
 2224              	.L393:
 2225              		.align	2
 2226              	.L392:
 2227 0058 00400640 		.word	1074151424
 2228              		.cfi_endproc
 2229              	.LFE13:
 2231              		.section	.text.fbe_fbi,"ax",%progbits
 2232              		.align	2
 2233              		.global	fbe_fbi
 2234              		.code	16
 2235              		.thumb_func
 2237              	fbe_fbi:
 2238              	.LFB14:
 897:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 898:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 899:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbe_fbi(int irc_freq, unsigned char irc_select)
 900:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 2239              		.loc 1 900 0
 2240              		.cfi_startproc
 2241              	.LVL199:
 2242 0000 38B5     		push	{r3, r4, r5, lr}
 2243              	.LCFI16:
 2244              		.cfi_def_cfa_offset 16
 2245              		.cfi_offset 3, -16
 2246              		.cfi_offset 4, -12
 2247              		.cfi_offset 5, -8
 2248              		.cfi_offset 14, -4
 901:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 902:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char fcrdiv_val;
 903:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 904:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 905:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FBE mode
 906:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2249              		.loc 1 906 0
 2250 0002 524B     		ldr	r3, .L450
 2251 0004 9A79     		ldrb	r2, [r3, #6]
 2252 0006 1407     		lsl	r4, r2, #28
 2253 0008 A20F     		lsr	r2, r4, #30
 2254 000a 022A     		cmp	r2, #2
 2255 000c 01D0     		beq	.L441
 2256              	.L410:
 907:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 908:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 909:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 910:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 911:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 2257              		.loc 1 911 0
 2258 000e 0420     		mov	r0, #4
 2259              	.LVL200:
 2260              	.L395:
 912:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 913:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 914:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check that the irc frequency matches the selected IRC 
 915:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
 916:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {    
 917:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 918:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 919:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 920:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 921:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 922:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 923:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 924:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select the required IRC
 925:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 926:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 927:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 928:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 929:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 930:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 931:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 932:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 933:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 934:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
 935:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 936:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 937:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select the IRC as the CLKS mux selection
 938:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 939:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 940:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 941:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 942:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 943:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait until internal reference switches to requested irc.
 944:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
 945:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 946:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 947:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
 948:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 949:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
 950:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 951:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 952:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 953:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 954:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 955:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
 956:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 957:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
 958:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 959:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 960:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
 961:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to update
 962:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 963:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 964:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 965:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 966:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 967:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 968:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // wait for Reference clock Status bit to set
 969:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 970:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 971:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 972:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 973:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 974:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 975:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBI mode
 976:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 977:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 978:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 979:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 980:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV
 981:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 982:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
 983:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
 984:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
 985:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
 986:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } //fbe_fbi
 2261              		.loc 1 986 0
 2262              		@ sp needed for prologue
 2263 0010 38BD     		pop	{r3, r4, r5, pc}
 2264              	.LVL201:
 2265              	.L441:
 907:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2266              		.loc 1 907 0
 2267 0012 9D79     		ldrb	r5, [r3, #6]
 906:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2268              		.loc 1 906 0
 2269 0014 ED06     		lsl	r5, r5, #27
 2270 0016 FAD4     		bmi	.L410
 908:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2271              		.loc 1 908 0
 2272 0018 9D79     		ldrb	r5, [r3, #6]
 2273 001a 2024     		mov	r4, #32
 907:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 2274              		.loc 1 907 0
 2275 001c 2C42     		tst	r4, r5
 2276 001e F6D1     		bne	.L410
 909:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 2277              		.loc 1 909 0
 2278 0020 5D78     		ldrb	r5, [r3, #1]
 906:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 2279              		.loc 1 906 0
 2280 0022 2A42     		tst	r2, r5
 2281 0024 F3D1     		bne	.L410
 915:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
 2282              		.loc 1 915 0
 2283 0026 0029     		cmp	r1, #0
 2284 0028 06D1     		bne	.L396
 917:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 2285              		.loc 1 917 0
 2286 002a 494D     		ldr	r5, .L450+4
 2287 002c 494A     		ldr	r2, .L450+8
 2288 002e 4519     		add	r5, r0, r5
 2289 0030 9542     		cmp	r5, r2
 2290 0032 08D9     		bls	.L442
 2291 0034 3120     		mov	r0, #49
 2292              	.LVL202:
 2293 0036 EBE7     		b	.L395
 2294              	.LVL203:
 2295              	.L396:
 921:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 2296              		.loc 1 921 0
 2297 0038 474A     		ldr	r2, .L450+12
 2298 003a 8518     		add	r5, r0, r2
 2299 003c 474A     		ldr	r2, .L450+16
 2300 003e 9542     		cmp	r5, r2
 2301 0040 24D9     		bls	.L443
 2302 0042 3220     		mov	r0, #50
 2303              	.LVL204:
 2304 0044 E4E7     		b	.L395
 2305              	.LVL205:
 2306              	.L442:
 931:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 2307              		.loc 1 931 0
 2308 0046 5A78     		ldrb	r2, [r3, #1]
 2309 0048 0125     		mov	r5, #1
 2310 004a AA43     		bic	r2, r5
 2311 004c 5A70     		strb	r2, [r3, #1]
 935:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 2312              		.loc 1 935 0
 2313 004e 5A79     		ldrb	r2, [r3, #5]
 2314 0050 A243     		bic	r2, r4
 2315 0052 5A71     		strb	r2, [r3, #5]
 938:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 2316              		.loc 1 938 0
 2317 0054 1D78     		ldrb	r5, [r3]
 2318              	.LVL206:
 939:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 2319              		.loc 1 939 0
 2320 0056 3F24     		mov	r4, #63
 2321 0058 2C40     		and	r4, r5
 2322              	.LVL207:
 940:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 2323              		.loc 1 940 0
 2324 005a 4422     		mov	r2, #68
 2325 005c 2243     		orr	r2, r4
 2326              	.LVL208:
 941:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2327              		.loc 1 941 0
 2328 005e FA25     		mov	r5, #250
 2329 0060 1A70     		strb	r2, [r3]
 2330              	.LVL209:
 948:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 2331              		.loc 1 948 0
 2332 0062 0124     		mov	r4, #1
 941:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2333              		.loc 1 941 0
 2334 0064 EA00     		lsl	r2, r5, #3
 2335              	.LVL210:
 2336 0066 08E0     		b	.L400
 2337              	.LVL211:
 2338              	.L444:
 948:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 2339              		.loc 1 948 0
 2340 0068 9D79     		ldrb	r5, [r3, #6]
 2341 006a 013A     		sub	r2, r2, #1
 2342 006c 92B2     		uxth	r2, r2
 2343 006e 2C42     		tst	r4, r5
 2344 0070 06D0     		beq	.L399
 2345 0072 013A     		sub	r2, r2, #1
 2346 0074 92B2     		uxth	r2, r2
 946:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 2347              		.loc 1 946 0
 2348 0076 002A     		cmp	r2, #0
 2349 0078 02D0     		beq	.L399
 2350              	.L400:
 948:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 2351              		.loc 1 948 0
 2352 007a 9D79     		ldrb	r5, [r3, #6]
 2353 007c 2C42     		tst	r4, r5
 2354 007e F3D1     		bne	.L444
 2355              	.L399:
 950:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 2356              		.loc 1 950 0
 2357 0080 324B     		ldr	r3, .L450
 2358 0082 9C79     		ldrb	r4, [r3, #6]
 2359 0084 E407     		lsl	r4, r4, #31
 2360 0086 24D5     		bpl	.L403
 2361 0088 1320     		mov	r0, #19
 2362              	.LVL212:
 2363 008a C1E7     		b	.L395
 2364              	.LVL213:
 2365              	.L443:
 927:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 2366              		.loc 1 927 0
 2367 008c 5D78     		ldrb	r5, [r3, #1]
 2368 008e 0122     		mov	r2, #1
 2369 0090 2A43     		orr	r2, r5
 2370 0092 5A70     		strb	r2, [r3, #1]
 935:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 2371              		.loc 1 935 0
 2372 0094 5D79     		ldrb	r5, [r3, #5]
 2373 0096 A543     		bic	r5, r4
 2374 0098 5D71     		strb	r5, [r3, #5]
 938:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 2375              		.loc 1 938 0
 2376 009a 1A78     		ldrb	r2, [r3]
 2377              	.LVL214:
 939:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
 2378              		.loc 1 939 0
 2379 009c 3F24     		mov	r4, #63
 2380 009e 1440     		and	r4, r2
 2381              	.LVL215:
 940:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
 2382              		.loc 1 940 0
 2383 00a0 4425     		mov	r5, #68
 2384 00a2 2543     		orr	r5, r4
 2385              	.LVL216:
 941:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2386              		.loc 1 941 0
 2387 00a4 FA22     		mov	r2, #250
 2388 00a6 1D70     		strb	r5, [r3]
 2389              	.LVL217:
 2390 00a8 D200     		lsl	r2, r2, #3
 956:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 2391              		.loc 1 956 0
 2392 00aa 0124     		mov	r4, #1
 2393 00ac 08E0     		b	.L398
 2394              	.LVL218:
 2395              	.L445:
 2396 00ae 9D79     		ldrb	r5, [r3, #6]
 2397 00b0 013A     		sub	r2, r2, #1
 2398 00b2 92B2     		uxth	r2, r2
 2399 00b4 2C42     		tst	r4, r5
 2400 00b6 06D1     		bne	.L402
 2401 00b8 013A     		sub	r2, r2, #1
 2402 00ba 92B2     		uxth	r2, r2
 954:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 2403              		.loc 1 954 0
 2404 00bc 002A     		cmp	r2, #0
 2405 00be 02D0     		beq	.L402
 2406              	.L398:
 956:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 2407              		.loc 1 956 0
 2408 00c0 9D79     		ldrb	r5, [r3, #6]
 2409 00c2 2C42     		tst	r4, r5
 2410 00c4 F3D0     		beq	.L445
 2411              	.L402:
 958:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 2412              		.loc 1 958 0
 2413 00c6 214B     		ldr	r3, .L450
 2414 00c8 9C79     		ldrb	r4, [r3, #6]
 2415 00ca E507     		lsl	r5, r4, #31
 2416 00cc 01D4     		bmi	.L403
 2417 00ce 1420     		mov	r0, #20
 2418              	.LVL219:
 2419 00d0 9EE7     		b	.L395
 2420              	.LVL220:
 2421              	.L403:
 941:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 2422              		.loc 1 941 0
 2423 00d2 FA25     		mov	r5, #250
 2424 00d4 EB00     		lsl	r3, r5, #3
 964:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 2425              		.loc 1 964 0
 2426 00d6 1D4C     		ldr	r4, .L450
 2427 00d8 0C22     		mov	r2, #12
 2428 00da 09E0     		b	.L401
 2429              	.LVL221:
 2430              	.L446:
 2431 00dc A579     		ldrb	r5, [r4, #6]
 2432 00de 013B     		sub	r3, r3, #1
 2433 00e0 9BB2     		uxth	r3, r3
 2434 00e2 1540     		and	r5, r2
 2435 00e4 042D     		cmp	r5, #4
 2436 00e6 07D0     		beq	.L404
 2437 00e8 013B     		sub	r3, r3, #1
 2438 00ea 9BB2     		uxth	r3, r3
 962:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2439              		.loc 1 962 0
 2440 00ec 002B     		cmp	r3, #0
 2441 00ee 03D0     		beq	.L404
 2442              	.L401:
 964:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 2443              		.loc 1 964 0
 2444 00f0 A579     		ldrb	r5, [r4, #6]
 2445 00f2 1540     		and	r5, r2
 2446 00f4 042D     		cmp	r5, #4
 2447 00f6 F1D1     		bne	.L446
 2448              	.L404:
 966:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 2449              		.loc 1 966 0
 2450 00f8 144C     		ldr	r4, .L450
 2451 00fa A279     		ldrb	r2, [r4, #6]
 2452 00fc 1507     		lsl	r5, r2, #28
 2453 00fe AB0F     		lsr	r3, r5, #30
 2454 0100 012B     		cmp	r3, #1
 2455 0102 01D0     		beq	.L447
 2456 0104 1920     		mov	r0, #25
 2457              	.LVL222:
 2458 0106 83E7     		b	.L395
 2459              	.LVL223:
 2460              	.L447:
 2461 0108 FA22     		mov	r2, #250
 2462 010a D300     		lsl	r3, r2, #3
 971:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 2463              		.loc 1 971 0
 2464 010c 1022     		mov	r2, #16
 2465 010e 08E0     		b	.L406
 2466              	.L448:
 2467 0110 A579     		ldrb	r5, [r4, #6]
 2468 0112 013B     		sub	r3, r3, #1
 2469 0114 9BB2     		uxth	r3, r3
 2470 0116 2A42     		tst	r2, r5
 2471 0118 06D1     		bne	.L405
 2472 011a 013B     		sub	r3, r3, #1
 2473 011c 9BB2     		uxth	r3, r3
 969:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2474              		.loc 1 969 0
 2475 011e 002B     		cmp	r3, #0
 2476 0120 02D0     		beq	.L405
 2477              	.L406:
 971:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 2478              		.loc 1 971 0
 2479 0122 A579     		ldrb	r5, [r4, #6]
 2480 0124 2A42     		tst	r2, r5
 2481 0126 F3D0     		beq	.L448
 2482              	.L405:
 973:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 2483              		.loc 1 973 0
 2484 0128 084D     		ldr	r5, .L450
 2485 012a AC79     		ldrb	r4, [r5, #6]
 2486 012c E406     		lsl	r4, r4, #27
 2487 012e 01D4     		bmi	.L449
 2488 0130 1220     		mov	r0, #18
 2489              	.LVL224:
 2490 0132 6DE7     		b	.L395
 2491              	.LVL225:
 2492              	.L449:
 977:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 2493              		.loc 1 977 0
 2494 0134 0029     		cmp	r1, #0
 2495 0136 00D1     		bne	.LCB3080
 2496 0138 6AE7     		b	.L395	@long jump
 2497              	.LCB3080:
 979:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 2498              		.loc 1 979 0
 2499 013a 297A     		ldrb	r1, [r5, #8]
 2500              	.LVL226:
 2501 013c 0125     		mov	r5, #1
 2502 013e 0A07     		lsl	r2, r1, #28
 2503 0140 530F     		lsr	r3, r2, #29
 2504 0142 9D40     		lsl	r5, r5, r3
 980:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV
 2505              		.loc 1 980 0
 2506 0144 E9B2     		uxtb	r1, r5
 2507              	.LVL227:
 2508 0146 FFF7FEFF 		bl	__aeabi_idiv
 2509              	.LVL228:
 2510 014a 61E7     		b	.L395
 2511              	.L451:
 2512              		.align	2
 2513              	.L450:
 2514 014c 00400640 		.word	1074151424
 2515 0150 EE85FFFF 		.word	-31250
 2516 0154 851E0000 		.word	7813
 2517 0158 4039D2FF 		.word	-3000000
 2518 015c 80841E00 		.word	2000000
 2519              		.cfi_endproc
 2520              	.LFE14:
 2522              		.section	.text.fbi_fbe,"ax",%progbits
 2523              		.align	2
 2524              		.global	fbi_fbe
 2525              		.code	16
 2526              		.thumb_func
 2528              	fbi_fbe:
 2529              	.LFB15:
 987:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 988:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
 989:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
 990:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 2530              		.loc 1 990 0
 2531              		.cfi_startproc
 2532              	.LVL229:
 2533 0000 30B5     		push	{r4, r5, lr}
 2534              	.LCFI17:
 2535              		.cfi_def_cfa_offset 12
 2536              		.cfi_offset 4, -12
 2537              		.cfi_offset 5, -8
 2538              		.cfi_offset 14, -4
 991:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
 992:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char frdiv_val;
 993:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
 994:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
 995:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check if in FBI mode
 996:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2539              		.loc 1 996 0
 2540 0002 5D4B     		ldr	r3, .L519
 2541 0004 9C79     		ldrb	r4, [r3, #6]
 2542 0006 2507     		lsl	r5, r4, #28
 2543 0008 AC0F     		lsr	r4, r5, #30
 2544 000a 012C     		cmp	r4, #1
 2545 000c 01D0     		beq	.L511
 2546              	.L468:
 997:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 998:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 999:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1000:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {  
1001:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 2547              		.loc 1 1001 0
 2548 000e 0320     		mov	r0, #3
 2549              	.LVL230:
 2550              	.L453:
1002:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1003:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
1004:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check external frequency is less than the maximum frequency
1005:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
1006:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1007:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
1008:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
1009:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1010:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
1011:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
1012:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
1013:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1014:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1015:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1016:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (hgo_val > 0)
1017:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1018:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
1019:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1020:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1021:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // configure the MCG_C2 register
1022:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1023:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
1024:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
1025:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
1026:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
1027:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1028:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1029:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1030:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
1031:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1032:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1033:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1034:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1035:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1036:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1037:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1038:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
1039:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1040:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // determine FRDIV based on reference clock frequency
1041:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1042:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
1043:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
1044:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
1045:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
1046:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
1047:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
1048:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1049:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1050:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1051:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1052:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
1053:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
1054:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
1055:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
1056:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1057:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
1058:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
1059:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1060:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 10000 ; i++)
1061:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1062:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
1063:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1064:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
1065:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1066:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1067:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to clear
1068:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1069:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1070:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
1071:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1072:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
1073:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1074:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
1075:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1076:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1077:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
1078:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1079:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
1080:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
1081:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBE  
1082:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1083:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is enabled here but can be removed if this is not required.
1084:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
1085:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1086:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
1087:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbi_fbe
 2551              		.loc 1 1087 0
 2552              		@ sp needed for prologue
 2553 0010 30BD     		pop	{r4, r5, pc}
 2554              	.LVL231:
 2555              	.L511:
 997:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2556              		.loc 1 997 0
 2557 0012 9D79     		ldrb	r5, [r3, #6]
 996:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2558              		.loc 1 996 0
 2559 0014 ED06     		lsl	r5, r5, #27
 2560 0016 FAD5     		bpl	.L468
 998:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2561              		.loc 1 998 0
 2562 0018 9C79     		ldrb	r4, [r3, #6]
 997:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2563              		.loc 1 997 0
 2564 001a A506     		lsl	r5, r4, #26
 2565 001c F7D4     		bmi	.L468
 999:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 2566              		.loc 1 999 0
 2567 001e 5B78     		ldrb	r3, [r3, #1]
 996:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2568              		.loc 1 996 0
 2569 0020 9C07     		lsl	r4, r3, #30
 2570 0022 F4D4     		bmi	.L468
1005:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 2571              		.loc 1 1005 0
 2572 0024 554D     		ldr	r5, .L519+4
 2573 0026 A842     		cmp	r0, r5
 2574 0028 01DD     		ble	.L512
 2575 002a 2120     		mov	r0, #33
 2576              	.LVL232:
 2577 002c F0E7     		b	.L453
 2578              	.LVL233:
 2579              	.L512:
1008:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 2580              		.loc 1 1008 0
 2581 002e 002A     		cmp	r2, #0
 2582 0030 0CD0     		beq	.L454
1010:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 2583              		.loc 1 1010 0
 2584 0032 534C     		ldr	r4, .L519+8
 2585 0034 A042     		cmp	r0, r4
 2586 0036 01DC     		bgt	.L513
 2587              	.L472:
1012:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 2588              		.loc 1 1012 0
 2589 0038 2220     		mov	r0, #34
 2590              	.LVL234:
 2591 003a E9E7     		b	.L453
 2592              	.LVL235:
 2593              	.L513:
1011:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2594              		.loc 1 1011 0
 2595 003c 514B     		ldr	r3, .L519+12
1010:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 2596              		.loc 1 1010 0
 2597 003e 524C     		ldr	r4, .L519+16
1011:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2598              		.loc 1 1011 0
 2599 0040 C518     		add	r5, r0, r3
1010:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 2600              		.loc 1 1010 0
 2601 0042 A542     		cmp	r5, r4
 2602 0044 F8D9     		bls	.L472
1011:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 2603              		.loc 1 1011 0
 2604 0046 514B     		ldr	r3, .L519+20
 2605 0048 9842     		cmp	r0, r3
 2606 004a F5DC     		bgt	.L472
 2607              	.L454:
1018:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 2608              		.loc 1 1018 0
 2609 004c 4B1E     		sub	r3, r1, #1
 2610 004e 9941     		sbc	r1, r1, r3
 2611              	.LVL236:
1024:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 2612              		.loc 1 1024 0
 2613 0050 494B     		ldr	r3, .L519
1025:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 2614              		.loc 1 1025 0
 2615 0052 3C25     		mov	r5, #60
1024:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 2616              		.loc 1 1024 0
 2617 0054 5C78     		ldrb	r4, [r3, #1]
 2618              	.LVL237:
1025:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 2619              		.loc 1 1025 0
 2620 0056 AC43     		bic	r4, r5
 2621              	.LVL238:
1026:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 2622              		.loc 1 1026 0
 2623 0058 4D4D     		ldr	r5, .L519+24
 2624 005a A842     		cmp	r0, r5
 2625 005c 43DC     		bgt	.L455
1028:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2626              		.loc 1 1028 0
 2627 005e 9500     		lsl	r5, r2, #2
 2628 0060 2C43     		orr	r4, r5
 2629              	.LVL239:
 2630 0062 E4B2     		uxtb	r4, r4
 2631 0064 C900     		lsl	r1, r1, #3
 2632 0066 2143     		orr	r1, r4
 2633              	.LVL240:
1038:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 2634              		.loc 1 1038 0
 2635 0068 5970     		strb	r1, [r3, #1]
1042:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2636              		.loc 1 1042 0
 2637 006a 0023     		mov	r3, #0
 2638              	.LVL241:
 2639              	.L456:
1052:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 2640              		.loc 1 1052 0
 2641 006c 4249     		ldr	r1, .L519
1053:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 2642              		.loc 1 1053 0
 2643 006e 0325     		mov	r5, #3
1052:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 2644              		.loc 1 1052 0
 2645 0070 0C78     		ldrb	r4, [r1]
 2646              	.LVL242:
1054:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 2647              		.loc 1 1054 0
 2648 0072 DB00     		lsl	r3, r3, #3
 2649              	.LVL243:
1053:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 2650              		.loc 1 1053 0
 2651 0074 2540     		and	r5, r4
1054:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 2652              		.loc 1 1054 0
 2653 0076 8024     		mov	r4, #128
 2654              	.LVL244:
 2655 0078 2C43     		orr	r4, r5
 2656 007a 2343     		orr	r3, r4
 2657              	.LVL245:
1055:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 2658              		.loc 1 1055 0
 2659 007c 0B70     		strb	r3, [r1]
1058:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 2660              		.loc 1 1058 0
 2661 007e 002A     		cmp	r2, #0
 2662 0080 14D0     		beq	.L459
 2663 0082 444B     		ldr	r3, .L519+28
 2664              	.LVL246:
1062:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 2665              		.loc 1 1062 0
 2666 0084 0222     		mov	r2, #2
 2667              	.LVL247:
 2668 0086 08E0     		b	.L461
 2669              	.L514:
 2670              	.LVL248:
 2671 0088 8C79     		ldrb	r4, [r1, #6]
 2672 008a 013B     		sub	r3, r3, #1
 2673 008c 9BB2     		uxth	r3, r3
 2674 008e 2242     		tst	r2, r4
 2675 0090 06D1     		bne	.L460
 2676 0092 013B     		sub	r3, r3, #1
 2677 0094 9BB2     		uxth	r3, r3
1060:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 2678              		.loc 1 1060 0
 2679 0096 002B     		cmp	r3, #0
 2680 0098 02D0     		beq	.L460
 2681              	.L461:
1062:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 2682              		.loc 1 1062 0
 2683 009a 8D79     		ldrb	r5, [r1, #6]
 2684 009c 2A42     		tst	r2, r5
 2685 009e F3D0     		beq	.L514
 2686              	.L460:
1064:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 2687              		.loc 1 1064 0
 2688 00a0 3549     		ldr	r1, .L519
 2689 00a2 8A79     		ldrb	r2, [r1, #6]
 2690 00a4 9107     		lsl	r1, r2, #30
 2691 00a6 01D4     		bmi	.L459
 2692 00a8 2320     		mov	r0, #35
 2693              	.LVL249:
 2694 00aa B1E7     		b	.L453
 2695              	.LVL250:
 2696              	.L459:
1070:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 2697              		.loc 1 1070 0
 2698 00ac 324D     		ldr	r5, .L519
 2699 00ae 1021     		mov	r1, #16
 2700 00b0 AC79     		ldrb	r4, [r5, #6]
 2701 00b2 2142     		tst	r1, r4
 2702 00b4 11D0     		beq	.L462
 2703 00b6 AA79     		ldrb	r2, [r5, #6]
 2704 00b8 374B     		ldr	r3, .L519+32
 2705 00ba 1142     		tst	r1, r2
 2706 00bc 0DD0     		beq	.L462
 2707 00be 013B     		sub	r3, r3, #1
 2708 00c0 08E0     		b	.L488
 2709              	.L515:
 2710 00c2 AA79     		ldrb	r2, [r5, #6]
 2711 00c4 013B     		sub	r3, r3, #1
 2712 00c6 9BB2     		uxth	r3, r3
 2713 00c8 1142     		tst	r1, r2
 2714 00ca 06D0     		beq	.L462
 2715 00cc 013B     		sub	r3, r3, #1
 2716 00ce 9BB2     		uxth	r3, r3
1068:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2717              		.loc 1 1068 0
 2718 00d0 002B     		cmp	r3, #0
 2719 00d2 02D0     		beq	.L462
 2720              	.L488:
1070:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 2721              		.loc 1 1070 0
 2722 00d4 AC79     		ldrb	r4, [r5, #6]
 2723 00d6 2142     		tst	r1, r4
 2724 00d8 F3D1     		bne	.L515
 2725              	.L462:
1072:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2726              		.loc 1 1072 0
 2727 00da 274D     		ldr	r5, .L519
 2728 00dc A979     		ldrb	r1, [r5, #6]
 2729 00de CC06     		lsl	r4, r1, #27
 2730 00e0 22D5     		bpl	.L516
 2731 00e2 1120     		mov	r0, #17
 2732              	.LVL251:
 2733 00e4 94E7     		b	.L453
 2734              	.LVL252:
 2735              	.L455:
1030:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
 2736              		.loc 1 1030 0
 2737 00e6 2D4D     		ldr	r5, .L519+36
 2738 00e8 A842     		cmp	r0, r5
 2739 00ea 37DC     		bgt	.L457
1032:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2740              		.loc 1 1032 0
 2741 00ec 1025     		mov	r5, #16
 2742 00ee 2C43     		orr	r4, r5
 2743              	.LVL253:
 2744 00f0 9500     		lsl	r5, r2, #2
 2745 00f2 2C43     		orr	r4, r5
 2746 00f4 E4B2     		uxtb	r4, r4
 2747 00f6 C900     		lsl	r1, r1, #3
1042:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2748              		.loc 1 1042 0
 2749 00f8 294D     		ldr	r5, .L519+40
1032:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2750              		.loc 1 1032 0
 2751 00fa 2143     		orr	r1, r4
 2752              	.LVL254:
1038:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 2753              		.loc 1 1038 0
 2754 00fc 5970     		strb	r1, [r3, #1]
1042:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 2755              		.loc 1 1042 0
 2756 00fe 0023     		mov	r3, #0
 2757 0100 A842     		cmp	r0, r5
 2758 0102 B3DD     		ble	.L456
 2759              	.LVL255:
 2760              	.L458:
1043:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 2761              		.loc 1 1043 0
 2762 0104 274C     		ldr	r4, .L519+44
 2763 0106 0123     		mov	r3, #1
 2764 0108 A042     		cmp	r0, r4
 2765 010a AFDD     		ble	.L456
1044:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 2766              		.loc 1 1044 0
 2767 010c 2649     		ldr	r1, .L519+48
 2768 010e 0223     		mov	r3, #2
 2769 0110 8842     		cmp	r0, r1
 2770 0112 ABDD     		ble	.L456
1045:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 2771              		.loc 1 1045 0
 2772 0114 254D     		ldr	r5, .L519+52
 2773 0116 0323     		mov	r3, #3
 2774 0118 A842     		cmp	r0, r5
 2775 011a A7DD     		ble	.L456
1046:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2776              		.loc 1 1046 0
 2777 011c 244C     		ldr	r4, .L519+56
1047:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
 2778              		.loc 1 1047 0
 2779 011e 0523     		mov	r3, #5
1046:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 2780              		.loc 1 1046 0
 2781 0120 A042     		cmp	r0, r4
 2782 0122 A3DC     		bgt	.L456
 2783 0124 0423     		mov	r3, #4
 2784 0126 A1E7     		b	.L456
 2785              	.LVL256:
 2786              	.L516:
1072:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 2787              		.loc 1 1072 0
 2788 0128 FA24     		mov	r4, #250
 2789 012a E100     		lsl	r1, r4, #3
1077:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2790              		.loc 1 1077 0
 2791 012c 0C22     		mov	r2, #12
 2792 012e 09E0     		b	.L464
 2793              	.L517:
 2794 0130 AC79     		ldrb	r4, [r5, #6]
 2795 0132 0139     		sub	r1, r1, #1
 2796 0134 89B2     		uxth	r1, r1
 2797 0136 1440     		and	r4, r2
 2798 0138 082C     		cmp	r4, #8
 2799 013a 07D0     		beq	.L463
 2800 013c 0139     		sub	r1, r1, #1
 2801 013e 89B2     		uxth	r1, r1
1075:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 2802              		.loc 1 1075 0
 2803 0140 0029     		cmp	r1, #0
 2804 0142 03D0     		beq	.L463
 2805              	.L464:
1077:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST
 2806              		.loc 1 1077 0
 2807 0144 AB79     		ldrb	r3, [r5, #6]
 2808 0146 1340     		and	r3, r2
 2809 0148 082B     		cmp	r3, #8
 2810 014a F1D1     		bne	.L517
 2811              	.L463:
1079:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is re
 2812              		.loc 1 1079 0
 2813 014c 0A4D     		ldr	r5, .L519
 2814 014e AA79     		ldrb	r2, [r5, #6]
 2815 0150 1307     		lsl	r3, r2, #28
 2816 0152 9C0F     		lsr	r4, r3, #30
 2817 0154 022C     		cmp	r4, #2
 2818 0156 0AD0     		beq	.L518
 2819 0158 1A20     		mov	r0, #26
 2820              	.LVL257:
 2821 015a 59E7     		b	.L453
 2822              	.LVL258:
 2823              	.L457:
1036:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 2824              		.loc 1 1036 0
 2825 015c 2025     		mov	r5, #32
 2826 015e 2C43     		orr	r4, r5
 2827              	.LVL259:
 2828 0160 9500     		lsl	r5, r2, #2
 2829 0162 2C43     		orr	r4, r5
 2830 0164 E4B2     		uxtb	r4, r4
 2831 0166 C900     		lsl	r1, r1, #3
 2832 0168 2143     		orr	r1, r4
 2833              	.LVL260:
1038:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 2834              		.loc 1 1038 0
 2835 016a 5970     		strb	r1, [r3, #1]
 2836 016c CAE7     		b	.L458
 2837              	.LVL261:
 2838              	.L518:
1084:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 2839              		.loc 1 1084 0
 2840 016e 6A79     		ldrb	r2, [r5, #5]
 2841 0170 2021     		mov	r1, #32
 2842 0172 0A43     		orr	r2, r1
 2843 0174 6A71     		strb	r2, [r5, #5]
1086:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return crystal_val; // MCGOUT frequency equals external clock frequency  
 2844              		.loc 1 1086 0
 2845 0176 4BE7     		b	.L453
 2846              	.L520:
 2847              		.align	2
 2848              	.L519:
 2849 0178 00400640 		.word	1074151424
 2850 017c 80F0FA02 		.word	50000000
 2851 0180 2F750000 		.word	29999
 2852 0184 BF63FFFF 		.word	-40001
 2853 0188 7E2A2D00 		.word	2959998
 2854 018c 0048E801 		.word	32000000
 2855 0190 409C0000 		.word	40000
 2856 0194 10270000 		.word	10000
 2857 0198 CF070000 		.word	1999
 2858 019c 00127A00 		.word	8000000
 2859 01a0 D0121300 		.word	1250000
 2860 01a4 A0252600 		.word	2500000
 2861 01a8 404B4C00 		.word	5000000
 2862 01ac 80969800 		.word	10000000
 2863 01b0 002D3101 		.word	20000000
 2864              		.cfi_endproc
 2865              	.LFE15:
 2867              		.section	.text.fbi_blpi,"ax",%progbits
 2868              		.align	2
 2869              		.global	fbi_blpi
 2870              		.code	16
 2871              		.thumb_func
 2873              	fbi_blpi:
 2874              	.LFB16:
1088:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1089:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1090:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
1091:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : fbi_blpi
1092:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1093:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: FBI to BLPI mode
1094:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1095:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function transitions the MCG from FBI mode to BLPI mode. This is
1096:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1097:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1098:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * in FBI mode. 
1099:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1100:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1101:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1102:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1103:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : MCGOUT frequency or error code 0x13
1104:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
1105:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbi_blpi(int irc_freq, unsigned char irc_select)
1106:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 2875              		.loc 1 1106 0
 2876              		.cfi_startproc
 2877              	.LVL262:
 2878 0000 38B5     		push	{r3, r4, r5, lr}
 2879              	.LCFI18:
 2880              		.cfi_def_cfa_offset 16
 2881              		.cfi_offset 3, -16
 2882              		.cfi_offset 4, -12
 2883              		.cfi_offset 5, -8
 2884              		.cfi_offset 14, -4
1107:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char fcrdiv_val;
1108:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1109:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check if in FBI mode
1110:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2885              		.loc 1 1110 0
 2886 0002 104B     		ldr	r3, .L531
 2887 0004 9A79     		ldrb	r2, [r3, #6]
 2888 0006 1407     		lsl	r4, r2, #28
 2889 0008 A20F     		lsr	r2, r4, #30
 2890 000a 012A     		cmp	r2, #1
 2891 000c 01D0     		beq	.L530
 2892              	.L526:
1111:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1112:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1113:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1114:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {  
1115:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 2893              		.loc 1 1115 0
 2894 000e 0320     		mov	r0, #3
 2895              	.LVL263:
 2896              	.L522:
1116:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1117:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1118:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Set LP bit to disable the FLL and enter BLPI
1119:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK;
1120:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1121:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in BLPI
1122:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
1123:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1124:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1125:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1126:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1127:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1128:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1129:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1130:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }   
1131:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbi_blpi
 2897              		.loc 1 1131 0
 2898              		@ sp needed for prologue
 2899 0010 38BD     		pop	{r3, r4, r5, pc}
 2900              	.LVL264:
 2901              	.L530:
1111:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2902              		.loc 1 1111 0
 2903 0012 9D79     		ldrb	r5, [r3, #6]
1110:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2904              		.loc 1 1110 0
 2905 0014 ED06     		lsl	r5, r5, #27
 2906 0016 FAD5     		bpl	.L526
1112:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2907              		.loc 1 1112 0
 2908 0018 9C79     		ldrb	r4, [r3, #6]
1111:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2909              		.loc 1 1111 0
 2910 001a A506     		lsl	r5, r4, #26
 2911 001c F7D4     		bmi	.L526
1113:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 2912              		.loc 1 1113 0
 2913 001e 5D78     		ldrb	r5, [r3, #1]
1110:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2914              		.loc 1 1110 0
 2915 0020 AD07     		lsl	r5, r5, #30
 2916 0022 F4D4     		bmi	.L526
1119:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 |= MCG_C2_LP_MASK;
 2917              		.loc 1 1119 0
 2918 0024 5D78     		ldrb	r5, [r3, #1]
 2919 0026 0224     		mov	r4, #2
 2920 0028 2C43     		orr	r4, r5
 2921 002a E5B2     		uxtb	r5, r4
 2922 002c 5D70     		strb	r5, [r3, #1]
1122:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 2923              		.loc 1 1122 0
 2924 002e 0029     		cmp	r1, #0
 2925 0030 EED0     		beq	.L522
1124:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 2926              		.loc 1 1124 0
 2927 0032 197A     		ldrb	r1, [r3, #8]
 2928              	.LVL265:
 2929 0034 0B07     		lsl	r3, r1, #28
 2930 0036 5C0F     		lsr	r4, r3, #29
 2931 0038 A240     		lsl	r2, r2, r4
1125:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 2932              		.loc 1 1125 0
 2933 003a FF21     		mov	r1, #255
 2934              	.LVL266:
 2935 003c 1140     		and	r1, r2
 2936 003e FFF7FEFF 		bl	__aeabi_idiv
 2937              	.LVL267:
 2938 0042 E5E7     		b	.L522
 2939              	.L532:
 2940              		.align	2
 2941              	.L531:
 2942 0044 00400640 		.word	1074151424
 2943              		.cfi_endproc
 2944              	.LFE16:
 2946              		.section	.text.blpi_fbi,"ax",%progbits
 2947              		.align	2
 2948              		.global	blpi_fbi
 2949              		.code	16
 2950              		.thumb_func
 2952              	blpi_fbi:
 2953              	.LFB17:
1132:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1133:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1134:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1135:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
1136:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : blpi_fbi
1137:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1138:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: BLPI to FBI mode
1139:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1140:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function transitions the MCG from BLPI mode to FBI mode. This is
1141:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
1142:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1143:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * in BLPI mode. 
1144:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1145:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: irc_freq - internal reference clock frequency
1146:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             ircs_select - 0 if slow irc, 1 if fast irc
1147:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1148:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : MCGOUT frequency or error code 0x15
1149:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
1150:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int blpi_fbi(int irc_freq, unsigned char irc_select)
1151:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 2954              		.loc 1 1151 0
 2955              		.cfi_startproc
 2956              	.LVL268:
 2957 0000 38B5     		push	{r3, r4, r5, lr}
 2958              	.LCFI19:
 2959              		.cfi_def_cfa_offset 16
 2960              		.cfi_offset 3, -16
 2961              		.cfi_offset 4, -12
 2962              		.cfi_offset 5, -8
 2963              		.cfi_offset 14, -4
1152:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char fcrdiv_val;
1153:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check if in BLPI mode
1154:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2964              		.loc 1 1154 0
 2965 0002 104B     		ldr	r3, .L543
 2966 0004 9A79     		ldrb	r2, [r3, #6]
 2967 0006 1407     		lsl	r4, r2, #28
 2968 0008 A20F     		lsr	r2, r4, #30
 2969 000a 012A     		cmp	r2, #1
 2970 000c 01D0     		beq	.L542
 2971              	.L538:
1155:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1156:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1157:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
1158:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1159:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x5;                                                       // MCG not in correct mode re
 2972              		.loc 1 1159 0
 2973 000e 0520     		mov	r0, #5
 2974              	.LVL269:
 2975              	.L534:
1160:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1161:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1162:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Clear LP bit to enable the FLL and enter FBI mode   
1163:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
1164:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1165:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBI mode
1166:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
1167:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1168:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1169:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1170:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1171:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1172:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1173:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1174:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1175:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // blpi_fbi
 2976              		.loc 1 1175 0
 2977              		@ sp needed for prologue
 2978 0010 38BD     		pop	{r3, r4, r5, pc}
 2979              	.LVL270:
 2980              	.L542:
1155:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2981              		.loc 1 1155 0
 2982 0012 9D79     		ldrb	r5, [r3, #6]
1154:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2983              		.loc 1 1154 0
 2984 0014 ED06     		lsl	r5, r5, #27
 2985 0016 FAD5     		bpl	.L538
1156:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 2986              		.loc 1 1156 0
 2987 0018 9C79     		ldrb	r4, [r3, #6]
1155:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 2988              		.loc 1 1155 0
 2989 001a A506     		lsl	r5, r4, #26
 2990 001c F7D4     		bmi	.L538
1157:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
 2991              		.loc 1 1157 0
 2992 001e 5D78     		ldrb	r5, [r3, #1]
 2993 0020 0224     		mov	r4, #2
1154:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 2994              		.loc 1 1154 0
 2995 0022 2C42     		tst	r4, r5
 2996 0024 F3D0     		beq	.L538
1163:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 &= ~MCG_C2_LP_MASK;
 2997              		.loc 1 1163 0
 2998 0026 5D78     		ldrb	r5, [r3, #1]
 2999 0028 A543     		bic	r5, r4
 3000 002a 5D70     		strb	r5, [r3, #1]
1166:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 3001              		.loc 1 1166 0
 3002 002c 0029     		cmp	r1, #0
 3003 002e EFD0     		beq	.L534
1168:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3004              		.loc 1 1168 0
 3005 0030 197A     		ldrb	r1, [r3, #8]
 3006              	.LVL271:
 3007 0032 0B07     		lsl	r3, r1, #28
 3008 0034 5D0F     		lsr	r5, r3, #29
 3009 0036 AA40     		lsl	r2, r2, r5
1169:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3010              		.loc 1 1169 0
 3011 0038 FF21     		mov	r1, #255
 3012              	.LVL272:
 3013 003a 1140     		and	r1, r2
 3014 003c FFF7FEFF 		bl	__aeabi_idiv
 3015              	.LVL273:
 3016 0040 E6E7     		b	.L534
 3017              	.L544:
 3018 0042 C046     		.align	2
 3019              	.L543:
 3020 0044 00400640 		.word	1074151424
 3021              		.cfi_endproc
 3022              	.LFE17:
 3024              		.section	.text.fee_fbi,"ax",%progbits
 3025              		.align	2
 3026              		.global	fee_fbi
 3027              		.code	16
 3028              		.thumb_func
 3030              	fee_fbi:
 3031              	.LFB19:
1176:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1177:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1178:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1179:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
1180:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
1181:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char frdiv_val;
1182:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
1183:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int mcg_out, fll_ref_freq;
1184:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1185:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check if in FBI mode
1186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1187:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1188:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1189:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1190:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {  
1191:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
1192:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1193:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1194:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check external frequency is less than the maximum frequency
1195:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
1196:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1197:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
1198:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
1199:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1200:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
1201:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
1202:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
1203:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1204:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1205:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1206:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (hgo_val > 0)
1207:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1208:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
1209:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1210:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1211:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // configure the MCG_C2 register
1212:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1213:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
1214:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
1215:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
1216:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
1217:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1218:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1219:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1220:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
1221:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1222:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1223:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1224:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1225:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1226:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1227:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1228:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
1229:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1230:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // determine FRDIV based on reference clock frequency
1231:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1232:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
1233:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
1234:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
1235:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
1236:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
1237:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
1238:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // The FLL ref clk divide value depends on FRDIV and the RANGE value
1239:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
1240:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1241:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
1242:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1243:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1244:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1245:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
1246:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1247:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1248:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check resulting FLL frequency 
1249:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
1250:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1251:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1252:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1253:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1254:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
1255:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
1256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
1257:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
1258:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
1259:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1260:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
1261:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
1262:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1263:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 10000 ; i++)
1264:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1265:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
1266:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1267:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
1268:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1269:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1270:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to clear
1271:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1272:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1273:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
1274:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1275:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
1276:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1277:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
1278:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1279:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1280:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
1281:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1282:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is reall
1283:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
1284:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FEE  
1285:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1286:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is enabled here but can be removed if this is not required.
1287:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLP
1288:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
1289:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1290:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
1291:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } //fbi_fee
1292:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1293:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1294:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fee_fbi(int irc_freq, unsigned char irc_select)
1295:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** { 
 3032              		.loc 1 1295 0
 3033              		.cfi_startproc
 3034              	.LVL274:
 3035 0000 38B5     		push	{r3, r4, r5, lr}
 3036              	.LCFI20:
 3037              		.cfi_def_cfa_offset 16
 3038              		.cfi_offset 3, -16
 3039              		.cfi_offset 4, -12
 3040              		.cfi_offset 5, -8
 3041              		.cfi_offset 14, -4
1296:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char fcrdiv_val;
1297:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
1298:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1299:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FEE mode
1300:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3042              		.loc 1 1300 0
 3043 0002 4E4B     		ldr	r3, .L600
 3044 0004 9A79     		ldrb	r2, [r3, #6]
 3045 0006 1407     		lsl	r4, r2, #28
 3046 0008 A50F     		lsr	r5, r4, #30
 3047 000a 01D0     		beq	.L591
 3048              	.L560:
1301:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
1302:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
1303:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1304:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x2;                                                     // return error code
 3049              		.loc 1 1304 0
 3050 000c 0220     		mov	r0, #2
 3051              	.LVL275:
 3052              	.L546:
1305:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1306:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1307:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check that the irc frequency matches the selected IRC 
1308:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
1309:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {    
1310:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
1311:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1312:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1313:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1314:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
1315:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1316:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1317:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select the required IRC
1318:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
1319:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1320:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
1321:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1322:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1323:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1324:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
1325:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1326:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1327:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
1328:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
1329:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1330:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select the IRC as the CLKS mux selection
1331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
1332:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  
1333:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait until internal reference switches to requested irc.
1334:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
1335:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1336:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
1337:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1338:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
1339:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1340:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
1341:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1342:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1343:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1344:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
1345:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1346:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
1347:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1348:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
1349:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1350:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1351:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to update
1352:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1353:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1354:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
1355:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1356:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
1357:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1358:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to set
1359:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1360:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1361:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
1362:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1363:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
1364:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1365:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBI mode
1366:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
1367:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1368:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1369:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1370:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1371:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1372:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1373:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1374:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1375:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fee_fbi 
 3053              		.loc 1 1375 0
 3054              		@ sp needed for prologue
 3055 000e 38BD     		pop	{r3, r4, r5, pc}
 3056              	.LVL276:
 3057              	.L591:
1301:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 3058              		.loc 1 1301 0
 3059 0010 9A79     		ldrb	r2, [r3, #6]
1300:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3060              		.loc 1 1300 0
 3061 0012 D406     		lsl	r4, r2, #27
 3062 0014 FAD4     		bmi	.L560
1302:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 3063              		.loc 1 1302 0
 3064 0016 9C79     		ldrb	r4, [r3, #6]
 3065 0018 2022     		mov	r2, #32
1300:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3066              		.loc 1 1300 0
 3067 001a 2242     		tst	r2, r4
 3068 001c F6D1     		bne	.L560
1308:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
 3069              		.loc 1 1308 0
 3070 001e 0029     		cmp	r1, #0
 3071 0020 06D1     		bne	.L547
1310:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 3072              		.loc 1 1310 0
 3073 0022 474D     		ldr	r5, .L600+4
 3074 0024 474C     		ldr	r4, .L600+8
 3075 0026 4519     		add	r5, r0, r5
 3076 0028 A542     		cmp	r5, r4
 3077 002a 08D9     		bls	.L592
 3078 002c 3120     		mov	r0, #49
 3079              	.LVL277:
 3080 002e EEE7     		b	.L546
 3081              	.LVL278:
 3082              	.L547:
1314:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 3083              		.loc 1 1314 0
 3084 0030 454D     		ldr	r5, .L600+12
 3085 0032 464C     		ldr	r4, .L600+16
 3086 0034 4519     		add	r5, r0, r5
 3087 0036 A542     		cmp	r5, r4
 3088 0038 22D9     		bls	.L593
 3089 003a 3220     		mov	r0, #50
 3090              	.LVL279:
 3091 003c E7E7     		b	.L546
 3092              	.LVL280:
 3093              	.L592:
1324:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
 3094              		.loc 1 1324 0
 3095 003e 5C78     		ldrb	r4, [r3, #1]
 3096 0040 0125     		mov	r5, #1
 3097 0042 AC43     		bic	r4, r5
 3098 0044 5C70     		strb	r4, [r3, #1]
1328:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3099              		.loc 1 1328 0
 3100 0046 5C79     		ldrb	r4, [r3, #5]
 3101 0048 9443     		bic	r4, r2
 3102 004a 5C71     		strb	r4, [r3, #5]
1331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 3103              		.loc 1 1331 0
 3104 004c 1D78     		ldrb	r5, [r3]
 3105 004e 4424     		mov	r4, #68
 3106 0050 2C43     		orr	r4, r5
 3107 0052 FA22     		mov	r2, #250
 3108 0054 1C70     		strb	r4, [r3]
 3109              	.LVL281:
 3110 0056 D200     		lsl	r2, r2, #3
1338:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3111              		.loc 1 1338 0
 3112 0058 0124     		mov	r4, #1
 3113 005a 08E0     		b	.L551
 3114              	.LVL282:
 3115              	.L594:
 3116 005c 9D79     		ldrb	r5, [r3, #6]
 3117 005e 013A     		sub	r2, r2, #1
 3118 0060 92B2     		uxth	r2, r2
 3119 0062 2C42     		tst	r4, r5
 3120 0064 06D0     		beq	.L550
 3121 0066 013A     		sub	r2, r2, #1
 3122 0068 92B2     		uxth	r2, r2
1336:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 3123              		.loc 1 1336 0
 3124 006a 002A     		cmp	r2, #0
 3125 006c 02D0     		beq	.L550
 3126              	.L551:
1338:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3127              		.loc 1 1338 0
 3128 006e 9D79     		ldrb	r5, [r3, #6]
 3129 0070 2C42     		tst	r4, r5
 3130 0072 F3D1     		bne	.L594
 3131              	.L550:
1340:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 3132              		.loc 1 1340 0
 3133 0074 314B     		ldr	r3, .L600
 3134 0076 9C79     		ldrb	r4, [r3, #6]
 3135 0078 E207     		lsl	r2, r4, #31
 3136 007a 22D5     		bpl	.L554
 3137 007c 1320     		mov	r0, #19
 3138              	.LVL283:
 3139 007e C6E7     		b	.L546
 3140              	.LVL284:
 3141              	.L593:
1320:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
 3142              		.loc 1 1320 0
 3143 0080 5D78     		ldrb	r5, [r3, #1]
 3144 0082 0124     		mov	r4, #1
 3145 0084 2C43     		orr	r4, r5
 3146 0086 5C70     		strb	r4, [r3, #1]
1328:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3147              		.loc 1 1328 0
 3148 0088 5D79     		ldrb	r5, [r3, #5]
 3149 008a 9543     		bic	r5, r2
 3150 008c 5D71     		strb	r5, [r3, #5]
1331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 3151              		.loc 1 1331 0
 3152 008e 1C78     		ldrb	r4, [r3]
 3153 0090 4425     		mov	r5, #68
 3154 0092 2543     		orr	r5, r4
 3155 0094 FA22     		mov	r2, #250
 3156 0096 1D70     		strb	r5, [r3]
 3157              	.LVL285:
 3158 0098 D200     		lsl	r2, r2, #3
1346:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3159              		.loc 1 1346 0
 3160 009a 0124     		mov	r4, #1
 3161 009c 08E0     		b	.L549
 3162              	.LVL286:
 3163              	.L595:
 3164 009e 9D79     		ldrb	r5, [r3, #6]
 3165 00a0 013A     		sub	r2, r2, #1
 3166 00a2 92B2     		uxth	r2, r2
 3167 00a4 2C42     		tst	r4, r5
 3168 00a6 06D1     		bne	.L553
 3169 00a8 013A     		sub	r2, r2, #1
 3170 00aa 92B2     		uxth	r2, r2
1344:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 3171              		.loc 1 1344 0
 3172 00ac 002A     		cmp	r2, #0
 3173 00ae 02D0     		beq	.L553
 3174              	.L549:
1346:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3175              		.loc 1 1346 0
 3176 00b0 9D79     		ldrb	r5, [r3, #6]
 3177 00b2 2C42     		tst	r4, r5
 3178 00b4 F3D0     		beq	.L595
 3179              	.L553:
1348:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 3180              		.loc 1 1348 0
 3181 00b6 214B     		ldr	r3, .L600
 3182 00b8 9C79     		ldrb	r4, [r3, #6]
 3183 00ba E407     		lsl	r4, r4, #31
 3184 00bc 01D4     		bmi	.L554
 3185 00be 1420     		mov	r0, #20
 3186              	.LVL287:
 3187 00c0 A5E7     		b	.L546
 3188              	.LVL288:
 3189              	.L554:
1331:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
 3190              		.loc 1 1331 0
 3191 00c2 FA25     		mov	r5, #250
 3192 00c4 EB00     		lsl	r3, r5, #3
1354:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3193              		.loc 1 1354 0
 3194 00c6 1D4C     		ldr	r4, .L600
 3195 00c8 0C22     		mov	r2, #12
 3196 00ca 09E0     		b	.L552
 3197              	.LVL289:
 3198              	.L596:
 3199 00cc A579     		ldrb	r5, [r4, #6]
 3200 00ce 013B     		sub	r3, r3, #1
 3201 00d0 9BB2     		uxth	r3, r3
 3202 00d2 1540     		and	r5, r2
 3203 00d4 042D     		cmp	r5, #4
 3204 00d6 07D0     		beq	.L555
 3205 00d8 013B     		sub	r3, r3, #1
 3206 00da 9BB2     		uxth	r3, r3
1352:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3207              		.loc 1 1352 0
 3208 00dc 002B     		cmp	r3, #0
 3209 00de 03D0     		beq	.L555
 3210              	.L552:
1354:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3211              		.loc 1 1354 0
 3212 00e0 A579     		ldrb	r5, [r4, #6]
 3213 00e2 1540     		and	r5, r2
 3214 00e4 042D     		cmp	r5, #4
 3215 00e6 F1D1     		bne	.L596
 3216              	.L555:
1356:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 3217              		.loc 1 1356 0
 3218 00e8 144C     		ldr	r4, .L600
 3219 00ea A279     		ldrb	r2, [r4, #6]
 3220 00ec 1507     		lsl	r5, r2, #28
 3221 00ee AB0F     		lsr	r3, r5, #30
 3222 00f0 012B     		cmp	r3, #1
 3223 00f2 01D0     		beq	.L597
 3224 00f4 1920     		mov	r0, #25
 3225              	.LVL290:
 3226 00f6 8AE7     		b	.L546
 3227              	.LVL291:
 3228              	.L597:
 3229 00f8 FA22     		mov	r2, #250
 3230 00fa D300     		lsl	r3, r2, #3
1361:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3231              		.loc 1 1361 0
 3232 00fc 1022     		mov	r2, #16
 3233 00fe 08E0     		b	.L557
 3234              	.L598:
 3235 0100 A579     		ldrb	r5, [r4, #6]
 3236 0102 013B     		sub	r3, r3, #1
 3237 0104 9BB2     		uxth	r3, r3
 3238 0106 2A42     		tst	r2, r5
 3239 0108 06D1     		bne	.L556
 3240 010a 013B     		sub	r3, r3, #1
 3241 010c 9BB2     		uxth	r3, r3
1359:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3242              		.loc 1 1359 0
 3243 010e 002B     		cmp	r3, #0
 3244 0110 02D0     		beq	.L556
 3245              	.L557:
1361:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3246              		.loc 1 1361 0
 3247 0112 A579     		ldrb	r5, [r4, #6]
 3248 0114 2A42     		tst	r2, r5
 3249 0116 F3D0     		beq	.L598
 3250              	.L556:
1363:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 3251              		.loc 1 1363 0
 3252 0118 084D     		ldr	r5, .L600
 3253 011a AC79     		ldrb	r4, [r5, #6]
 3254 011c E406     		lsl	r4, r4, #27
 3255 011e 01D4     		bmi	.L599
 3256 0120 1220     		mov	r0, #18
 3257              	.LVL292:
 3258 0122 74E7     		b	.L546
 3259              	.LVL293:
 3260              	.L599:
1366:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 3261              		.loc 1 1366 0
 3262 0124 0029     		cmp	r1, #0
 3263 0126 00D1     		bne	.LCB4075
 3264 0128 71E7     		b	.L546	@long jump
 3265              	.LCB4075:
1368:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3266              		.loc 1 1368 0
 3267 012a 297A     		ldrb	r1, [r5, #8]
 3268              	.LVL294:
 3269 012c 0125     		mov	r5, #1
 3270 012e 0A07     		lsl	r2, r1, #28
 3271 0130 530F     		lsr	r3, r2, #29
 3272 0132 9D40     		lsl	r5, r5, r3
1369:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3273              		.loc 1 1369 0
 3274 0134 E9B2     		uxtb	r1, r5
 3275              	.LVL295:
 3276 0136 FFF7FEFF 		bl	__aeabi_idiv
 3277              	.LVL296:
 3278 013a 68E7     		b	.L546
 3279              	.L601:
 3280              		.align	2
 3281              	.L600:
 3282 013c 00400640 		.word	1074151424
 3283 0140 EE85FFFF 		.word	-31250
 3284 0144 851E0000 		.word	7813
 3285 0148 4039D2FF 		.word	-3000000
 3286 014c 80841E00 		.word	2000000
 3287              		.cfi_endproc
 3288              	.LFE19:
 3290              		.section	.text.fei_fbi,"ax",%progbits
 3291              		.align	2
 3292              		.global	fei_fbi
 3293              		.code	16
 3294              		.thumb_func
 3296              	fei_fbi:
 3297              	.LFB21:
1376:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1377:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1378:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fbi_fei(int slow_irc_freq)
1379:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
1380:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
1381:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
1382:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int mcg_out;
1383:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1384:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check if in FBI mode
1385:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
1386:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1387:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
1388:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
1389:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {  
1390:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
1391:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1392:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1393:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check IRC frequency is within spec.
1394:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
1395:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1396:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x31;
1397:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1398:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1399:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check resulting FLL frequency 
1400:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
1401:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1402:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1403:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Change the CLKS mux to select the FLL output as MCGOUT  
1404:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
1405:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
1406:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
1407:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
1408:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
1409:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1410:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to clear
1411:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1412:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1413:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
1414:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1415:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
1416:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1417:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to show clock source is ext ref clk
1418:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1419:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1420:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
1421:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1422:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
1423:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1424:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FEI mode
1425:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out;  
1426:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbi_fei
1427:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1428:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1429:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fei_fbi(int irc_freq, unsigned char irc_select)
1430:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 3298              		.loc 1 1430 0
 3299              		.cfi_startproc
 3300              	.LVL297:
 3301 0000 38B5     		push	{r3, r4, r5, lr}
 3302              	.LCFI21:
 3303              		.cfi_def_cfa_offset 16
 3304              		.cfi_offset 3, -16
 3305              		.cfi_offset 4, -12
 3306              		.cfi_offset 5, -8
 3307              		.cfi_offset 14, -4
1431:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
1432:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char fcrdiv_val;
1433:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
1434:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1435:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FEI mode
1436:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3308              		.loc 1 1436 0
 3309 0002 414B     		ldr	r3, .L648
 3310 0004 9A79     		ldrb	r2, [r3, #6]
 3311 0006 1407     		lsl	r4, r2, #28
 3312 0008 A50F     		lsr	r5, r4, #30
 3313 000a 0ED1     		bne	.L615
1437:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3314              		.loc 1 1437 0
 3315 000c 9A79     		ldrb	r2, [r3, #6]
1436:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3316              		.loc 1 1436 0
 3317 000e D406     		lsl	r4, r2, #27
 3318 0010 0BD5     		bpl	.L615
1438:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3319              		.loc 1 1438 0
 3320 0012 9C79     		ldrb	r4, [r3, #6]
1436:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3321              		.loc 1 1436 0
 3322 0014 A406     		lsl	r4, r4, #26
 3323 0016 08D4     		bmi	.L615
1439:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1440:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                       // return error code
1441:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   } 
1442:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1443:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check that the irc frequency matches the selected IRC 
1444:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
 3324              		.loc 1 1444 0
 3325 0018 0029     		cmp	r1, #0
 3326 001a 08D1     		bne	.L604
1445:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {    
1446:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
 3327              		.loc 1 1446 0
 3328 001c 3B4D     		ldr	r5, .L648+4
 3329 001e 3C4A     		ldr	r2, .L648+8
 3330 0020 4419     		add	r4, r0, r5
 3331 0022 9442     		cmp	r4, r2
 3332 0024 2AD9     		bls	.L642
 3333 0026 3120     		mov	r0, #49
 3334              	.LVL298:
 3335 0028 00E0     		b	.L603
 3336              	.LVL299:
 3337              	.L615:
1440:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                       // return error code
 3338              		.loc 1 1440 0
 3339 002a 0120     		mov	r0, #1
 3340              	.LVL300:
 3341              	.L603:
1447:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1448:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1449:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1450:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
1451:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1452:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1453:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select the desired IRC
1454:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
1455:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1456:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
1457:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1458:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1459:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1460:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
1461:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1462:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1463:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Change the CLKS mux to select the IRC as the MCGOUT
1464:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
1465:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
1466:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
1467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
1468:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1469:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait until internal reference switches to requested irc.
1470:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(irc_select))
1471:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1472:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
1473:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1474:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
1475:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1476:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
1477:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1478:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1479:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1480:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
1481:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1482:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
1483:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1484:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
1485:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1486:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1487:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Wait for clock status bits to update
1488:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1489:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1490:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
1491:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1492:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
1493:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1494:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBI mode
1495:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
1496:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1497:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
1498:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
1499:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1500:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1501:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1502:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return irc_freq; // MCGOUT frequency equals slow IRC frequency
1503:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }   
1504:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fei_fbi
 3342              		.loc 1 1504 0
 3343              		@ sp needed for prologue
 3344 002c 38BD     		pop	{r3, r4, r5, pc}
 3345              	.LVL301:
 3346              	.L604:
1450:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
 3347              		.loc 1 1450 0
 3348 002e 394D     		ldr	r5, .L648+12
 3349 0030 394A     		ldr	r2, .L648+16
 3350 0032 4419     		add	r4, r0, r5
 3351 0034 9442     		cmp	r4, r2
 3352 0036 01D9     		bls	.L643
 3353 0038 3220     		mov	r0, #50
 3354              	.LVL302:
 3355 003a F7E7     		b	.L603
 3356              	.LVL303:
 3357              	.L643:
1456:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
 3358              		.loc 1 1456 0
 3359 003c 5D78     		ldrb	r5, [r3, #1]
 3360 003e 0124     		mov	r4, #1
 3361 0040 2C43     		orr	r4, r5
 3362 0042 5C70     		strb	r4, [r3, #1]
1464:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 3363              		.loc 1 1464 0
 3364 0044 1A78     		ldrb	r2, [r3]
 3365              	.LVL304:
1465:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3366              		.loc 1 1465 0
 3367 0046 3F25     		mov	r5, #63
1466:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3368              		.loc 1 1466 0
 3369 0048 4024     		mov	r4, #64
1465:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3370              		.loc 1 1465 0
 3371 004a 2A40     		and	r2, r5
 3372              	.LVL305:
1466:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3373              		.loc 1 1466 0
 3374 004c 2243     		orr	r2, r4
 3375              	.LVL306:
1467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 3376              		.loc 1 1467 0
 3377 004e 1A70     		strb	r2, [r3]
 3378              	.LVL307:
 3379 0050 FA22     		mov	r2, #250
 3380              	.LVL308:
 3381 0052 D200     		lsl	r2, r2, #3
1482:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3382              		.loc 1 1482 0
 3383 0054 0124     		mov	r4, #1
 3384 0056 08E0     		b	.L606
 3385              	.LVL309:
 3386              	.L644:
 3387 0058 9D79     		ldrb	r5, [r3, #6]
 3388 005a 013A     		sub	r2, r2, #1
 3389 005c 92B2     		uxth	r2, r2
 3390 005e 2C42     		tst	r4, r5
 3391 0060 06D1     		bne	.L610
 3392 0062 013A     		sub	r2, r2, #1
 3393 0064 92B2     		uxth	r2, r2
1480:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 3394              		.loc 1 1480 0
 3395 0066 002A     		cmp	r2, #0
 3396 0068 02D0     		beq	.L610
 3397              	.L606:
1482:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
 3398              		.loc 1 1482 0
 3399 006a 9D79     		ldrb	r5, [r3, #6]
 3400 006c 2C42     		tst	r4, r5
 3401 006e F3D0     		beq	.L644
 3402              	.L610:
1484:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error 
 3403              		.loc 1 1484 0
 3404 0070 254B     		ldr	r3, .L648
 3405 0072 9C79     		ldrb	r4, [r3, #6]
 3406 0074 E207     		lsl	r2, r4, #31
 3407 0076 21D4     		bmi	.L611
 3408 0078 1420     		mov	r0, #20
 3409              	.LVL310:
 3410 007a D7E7     		b	.L603
 3411              	.LVL311:
 3412              	.L642:
1460:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
 3413              		.loc 1 1460 0
 3414 007c 5D78     		ldrb	r5, [r3, #1]
 3415 007e 0124     		mov	r4, #1
 3416 0080 A543     		bic	r5, r4
 3417 0082 5D70     		strb	r5, [r3, #1]
1464:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 3418              		.loc 1 1464 0
 3419 0084 1A78     		ldrb	r2, [r3]
 3420              	.LVL312:
1465:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3421              		.loc 1 1465 0
 3422 0086 3F25     		mov	r5, #63
1466:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3423              		.loc 1 1466 0
 3424 0088 4024     		mov	r4, #64
1465:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
 3425              		.loc 1 1465 0
 3426 008a 2A40     		and	r2, r5
 3427              	.LVL313:
1466:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
 3428              		.loc 1 1466 0
 3429 008c 2243     		orr	r2, r4
 3430              	.LVL314:
1467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 3431              		.loc 1 1467 0
 3432 008e 1A70     		strb	r2, [r3]
 3433              	.LVL315:
 3434 0090 FA22     		mov	r2, #250
 3435              	.LVL316:
 3436 0092 D200     		lsl	r2, r2, #3
1474:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3437              		.loc 1 1474 0
 3438 0094 0124     		mov	r4, #1
 3439 0096 08E0     		b	.L608
 3440              	.LVL317:
 3441              	.L645:
 3442 0098 9D79     		ldrb	r5, [r3, #6]
 3443 009a 013A     		sub	r2, r2, #1
 3444 009c 92B2     		uxth	r2, r2
 3445 009e 2C42     		tst	r4, r5
 3446 00a0 06D0     		beq	.L607
 3447 00a2 013A     		sub	r2, r2, #1
 3448 00a4 92B2     		uxth	r2, r2
1472:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 2000 ; i++)
 3449              		.loc 1 1472 0
 3450 00a6 002A     		cmp	r2, #0
 3451 00a8 02D0     		beq	.L607
 3452              	.L608:
1474:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishe
 3453              		.loc 1 1474 0
 3454 00aa 9D79     		ldrb	r5, [r3, #6]
 3455 00ac 2C42     		tst	r4, r5
 3456 00ae F3D1     		bne	.L645
 3457              	.L607:
1476:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error i
 3458              		.loc 1 1476 0
 3459 00b0 154B     		ldr	r3, .L648
 3460 00b2 9C79     		ldrb	r4, [r3, #6]
 3461 00b4 E407     		lsl	r4, r4, #31
 3462 00b6 01D5     		bpl	.L611
 3463 00b8 1320     		mov	r0, #19
 3464              	.LVL318:
 3465 00ba B7E7     		b	.L603
 3466              	.LVL319:
 3467              	.L611:
1467:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 3468              		.loc 1 1467 0
 3469 00bc FA25     		mov	r5, #250
 3470 00be EB00     		lsl	r3, r5, #3
1490:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3471              		.loc 1 1490 0
 3472 00c0 114C     		ldr	r4, .L648
 3473 00c2 0C22     		mov	r2, #12
 3474 00c4 09E0     		b	.L609
 3475              	.LVL320:
 3476              	.L646:
 3477 00c6 A579     		ldrb	r5, [r4, #6]
 3478 00c8 013B     		sub	r3, r3, #1
 3479 00ca 9BB2     		uxth	r3, r3
 3480 00cc 1540     		and	r5, r2
 3481 00ce 042D     		cmp	r5, #4
 3482 00d0 07D0     		beq	.L612
 3483 00d2 013B     		sub	r3, r3, #1
 3484 00d4 9BB2     		uxth	r3, r3
1488:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3485              		.loc 1 1488 0
 3486 00d6 002B     		cmp	r3, #0
 3487 00d8 03D0     		beq	.L612
 3488              	.L609:
1490:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST
 3489              		.loc 1 1490 0
 3490 00da A579     		ldrb	r5, [r4, #6]
 3491 00dc 1540     		and	r5, r2
 3492 00de 042D     		cmp	r5, #4
 3493 00e0 F1D1     		bne	.L646
 3494              	.L612:
1492:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really
 3495              		.loc 1 1492 0
 3496 00e2 094C     		ldr	r4, .L648
 3497 00e4 A279     		ldrb	r2, [r4, #6]
 3498 00e6 1507     		lsl	r5, r2, #28
 3499 00e8 AB0F     		lsr	r3, r5, #30
 3500 00ea 012B     		cmp	r3, #1
 3501 00ec 01D0     		beq	.L647
 3502 00ee 1920     		mov	r0, #25
 3503              	.LVL321:
 3504 00f0 9CE7     		b	.L603
 3505              	.LVL322:
 3506              	.L647:
1495:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select)
 3507              		.loc 1 1495 0
 3508 00f2 0029     		cmp	r1, #0
 3509 00f4 9AD0     		beq	.L603
1497:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fa
 3510              		.loc 1 1497 0
 3511 00f6 217A     		ldrb	r1, [r4, #8]
 3512              	.LVL323:
 3513 00f8 0C07     		lsl	r4, r1, #28
 3514 00fa 620F     		lsr	r2, r4, #29
 3515 00fc 9340     		lsl	r3, r3, r2
1498:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
 3516              		.loc 1 1498 0
 3517 00fe FF21     		mov	r1, #255
 3518              	.LVL324:
 3519 0100 1940     		and	r1, r3
 3520 0102 FFF7FEFF 		bl	__aeabi_idiv
 3521              	.LVL325:
 3522 0106 91E7     		b	.L603
 3523              	.L649:
 3524              		.align	2
 3525              	.L648:
 3526 0108 00400640 		.word	1074151424
 3527 010c EE85FFFF 		.word	-31250
 3528 0110 851E0000 		.word	7813
 3529 0114 4039D2FF 		.word	-3000000
 3530 0118 80841E00 		.word	2000000
 3531              		.cfi_endproc
 3532              	.LFE21:
 3534              		.section	.text.fll_freq,"ax",%progbits
 3535              		.align	2
 3536              		.global	fll_freq
 3537              		.code	16
 3538              		.thumb_func
 3540              	fll_freq:
 3541              	.LFB25:
1505:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1506:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1507:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
1508:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : fei_fee
1509:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1510:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Mode transition: FEI to FEE mode
1511:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1512:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function transitions the MCG from FEI mode to FEE mode. This is
1513:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
1514:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * check so 0 is always returned if the function was called with the MCG
1515:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * in FBI mode. The MCGCLKOUT frequency does not change
1516:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1517:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: crystal_val - external clock frequency in Hz
1518:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             hgo_val     - selects whether low power or high gain mode is selected
1519:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           for the crystal oscillator. This has no meaning if an 
1520:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *                           external clock is used.
1521:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *             erefs_val   - selects external clock (=0) or crystal osc (=1)
1522:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1523:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : MCGCLKOUT frequency (Hz) or error code
1524:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
1525:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
1526:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
1527:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char frdiv_val;
1528:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char temp_reg;
1529:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  // short i;
1530:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int mcg_out, fll_ref_freq, i;
1531:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1532:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check if in FEI mode
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
1534:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
1535:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
1536:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1537:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                     // return error code
1538:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1539:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1540:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check external frequency is less than the maximum frequency
1541:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
1542:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1543:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // check crystal frequency is within spec. if crystal osc is being used
1544:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
1545:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1546:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
1547:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
1548:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
1549:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1550:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1551:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // make sure HGO will never be greater than 1. Could return an error instead if desired.  
1552:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (hgo_val > 0)
1553:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1554:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
1555:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1556:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1557:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // configure the MCG_C2 register
1558:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the F
1559:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // it still needs to be set correctly even if the oscillator is not being used
1560:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
1561:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
1562:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
1563:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1564:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1565:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1566:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
1567:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1568:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1569:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1570:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1571:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1572:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
1573:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1574:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
1575:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1576:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // determine FRDIV based on reference clock frequency
1577:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // since the external frequency has already been checked only the maximum frequency for each FRDIV 
1578:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
1579:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
1580:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
1581:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
1582:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
1583:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
1584:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****    
1585:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // The FLL ref clk divide value depends on FRDIV and the RANGE value
1586:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
1587:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1588:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
1589:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1590:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1591:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1592:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
1593:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1594:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1595:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check resulting FLL frequency 
1596:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
1597:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1598:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1599:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Select external oscilator and Reference Divider and clear IREFS to start ext osc
1600:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // If IRCLK is required it must be enabled outside of this driver, existing state will be maintaine
1601:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
1602:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
1603:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
1604:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
1605:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
1606:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1607:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // if the external oscillator is used need to wait for OSCINIT to set
1608:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
1609:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1610:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 20000000 ; i++)
1611:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1612:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
1613:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1614:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
1615:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1616:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1617:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock Status bit to clear
1618:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1619:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1620:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
1621:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1622:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
1623:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1624:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FBE  
1625:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is recommended that the clock monitor is enabled when using an external clock as the clock so
1626:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // It is enabled here but can be removed if this is not required.
1627:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
1628:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1629:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
1630:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fei_fee
1631:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1632:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1633:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fee_fei(int slow_irc_freq)
1634:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
1635:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
1636:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int mcg_out;
1637:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1638:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check MCG is in FEE mode
1639:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
1640:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
1641:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
1642:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1643:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x2;                                                     // return error code
1644:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   } 
1645:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       
1646:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Check IRC frequency is within spec.
1647:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
1648:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1649:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x31;
1650:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1651:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1652:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check resulting FLL frequency 
1653:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
1654:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
1655:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1656:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
1657:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
1658:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1659:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Change FLL reference clock from external to internal by setting IREFS bit
1660:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
1661:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1662:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // wait for Reference clock to switch to internal reference 
1663:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
1664:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
1666:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1667:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
1668:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1669:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Now in FEI mode  
1670:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out;  
1671:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fee_fei
1672:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1673:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1674:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1675:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
1676:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
1677:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char mcg_mode;
1678:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned short atcv;
1679:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int bus_clock_freq;
1680:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int  bus_clk_div_val;
1681:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int orig_div;
1682:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int temp_reg;
1683:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1684:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select > 0) // force irc to 1 if greater than 0
1685:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1686:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     irc_select = 1;
1687:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1688:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1689:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
1690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
1691:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1692:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 1; // return error code if not in PEE, PBE or FBE modes
1693:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1694:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
1696:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1697:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
1698:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = SIM_CLKDIV1;
1699:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
1700:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // set all bus and flash dividers to same value to ensure clocking restrictions are met
1701:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
1702:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   SIM_CLKDIV1 = temp_reg; // set actual dividers
1703:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1704:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same
1705:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
1706:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1707:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1708:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 3; // error, bus clock frequency is not within 8MHz to 16MHz
1709:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1710:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****                 
1711:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if(!irc_select) //determine if slow or fast IRC to be trimmed
1712:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1713:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq < 31250) // check frequency is above min spec.
1714:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1715:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1716:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 4;
1717:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1718:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq > 39062) // check frequency is below max spec.
1719:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1720:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1721:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 5;
1722:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }         
1723:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1724:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1725:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1726:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq < 3000000) // check frequency is above min spec.
1727:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1728:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1729:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 6;
1730:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1731:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq > 5000000) // check frequency is below max spec.
1732:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1733:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1734:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 7;
1735:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }            
1736:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   } // if
1737:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         
1738:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Set up autocal registers, must use floating point calculation
1739:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select) 
1740:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
1741:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1742:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
1743:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         
1744:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
1745:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
1746:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1747:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** // Enable autocal
1748:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
1749:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enabl
1750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_SC |= temp_reg;
1751:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         
1752:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
1753:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         
1754:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
1755:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1756:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1757:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 8;
1758:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   } 
1759:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else 
1760:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {      
1761:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!irc_select)
1762:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1763:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
1764:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       {
1765:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1766:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         return 9;
1767:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       }
1768:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1769:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     else
1770:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1771:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
1772:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
1773:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       {
1774:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1775:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         return 10;
1776:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       }
1777:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1778:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1779:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
1780:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return 0;
1781:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** }// atc
1782:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1783:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1784:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1785:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1786:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** int fll_freq(int fll_ref)
1787:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 3542              		.loc 1 1787 0
 3543              		.cfi_startproc
 3544              	.LVL326:
 3545 0000 10B5     		push	{r4, lr}
 3546              	.LCFI22:
 3547              		.cfi_def_cfa_offset 8
 3548              		.cfi_offset 4, -8
 3549              		.cfi_offset 14, -4
1788:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   int fll_freq_hz = 0;
1789:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1790:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check that only allowed ranges have been selected
1791:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 3550              		.loc 1 1791 0
 3551 0002 324A     		ldr	r2, .L685
 3552 0004 6021     		mov	r1, #96
 3553 0006 D478     		ldrb	r4, [r2, #3]
1792:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1793:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3B; // return error code if DRS range 2 or 3 selected
 3554              		.loc 1 1793 0
 3555 0008 3B23     		mov	r3, #59
1791:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
 3556              		.loc 1 1791 0
 3557 000a 0C40     		and	r4, r1
 3558 000c 202C     		cmp	r4, #32
 3559 000e 01D9     		bls	.L683
 3560              	.LVL327:
 3561              	.L651:
1794:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1795:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1796:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
1797:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1798:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
1799:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1800:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 0:
1801:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 732);
1802:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
1803:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
1804:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1805:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 1:
1806:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1464);
1807:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
1808:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
1809:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1810:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 2:
1811:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2197);
1812:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
1813:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
1814:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1815:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 3:
1816:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2929);
1817:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
1818:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
1819:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1820:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1821:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1822:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else // if DMX32 = 0
1823:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1824:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
1825:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     {
1826:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 0:
1827:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 640);
1828:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
1829:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
1830:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1831:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 1:
1832:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1280);
1833:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
1834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
1835:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1836:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 2:
1837:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1920);
1838:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
1839:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
1840:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1841:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     case 3:
1842:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2560);
1843:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
1844:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
1845:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       break;
1846:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     }
1847:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }    
1848:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return fll_freq_hz;
1849:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fll_freq
 3562              		.loc 1 1849 0
 3563 0010 181C     		mov	r0, r3
 3564              		@ sp needed for prologue
 3565 0012 10BD     		pop	{r4, pc}
 3566              	.LVL328:
 3567              	.L683:
 3568              	.LBB4:
 3569              	.LBB5:
1796:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
 3570              		.loc 1 1796 0
 3571 0014 D378     		ldrb	r3, [r2, #3]
 3572 0016 5CB2     		sxtb	r4, r3
 3573 0018 002C     		cmp	r4, #0
 3574 001a 16DB     		blt	.L684
1824:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 3575              		.loc 1 1824 0
 3576 001c D278     		ldrb	r2, [r2, #3]
 3577 001e 1140     		and	r1, r2
 3578 0020 4909     		lsr	r1, r1, #5
 3579 0022 0229     		cmp	r1, #2
 3580 0024 3FD0     		beq	.L660
1842:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2560);
 3581              		.loc 1 1842 0
 3582 0026 8300     		lsl	r3, r0, #2
 3583 0028 1818     		add	r0, r3, r0
 3584              	.LVL329:
1824:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 3585              		.loc 1 1824 0
 3586 002a 0329     		cmp	r1, #3
 3587 002c 2BD0     		beq	.L661
 3588 002e 0129     		cmp	r1, #1
 3589 0030 05D0     		beq	.L659
1828:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 3590              		.loc 1 1828 0
 3591 0032 274C     		ldr	r4, .L685+4
1827:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 640);
 3592              		.loc 1 1827 0
 3593 0034 C301     		lsl	r3, r0, #7
 3594              	.LVL330:
1828:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 3595              		.loc 1 1828 0
 3596 0036 A342     		cmp	r3, r4
 3597 0038 16DC     		bgt	.L676
 3598              	.L667:
1802:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 3599              		.loc 1 1802 0
 3600 003a 3323     		mov	r3, #51
 3601              	.LVL331:
 3602 003c E8E7     		b	.L651
 3603              	.L659:
1833:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 3604              		.loc 1 1833 0
 3605 003e 254A     		ldr	r2, .L685+8
1832:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1280);
 3606              		.loc 1 1832 0
 3607 0040 0302     		lsl	r3, r0, #8
 3608              	.LVL332:
1833:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 3609              		.loc 1 1833 0
 3610 0042 9342     		cmp	r3, r2
 3611 0044 1ADC     		bgt	.L678
 3612              	.L668:
1807:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 3613              		.loc 1 1807 0
 3614 0046 3523     		mov	r3, #53
 3615              	.LVL333:
 3616 0048 E2E7     		b	.L651
 3617              	.LVL334:
 3618              	.L684:
1798:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 3619              		.loc 1 1798 0
 3620 004a D278     		ldrb	r2, [r2, #3]
 3621 004c 1140     		and	r1, r2
 3622 004e 4909     		lsr	r1, r1, #5
 3623 0050 0229     		cmp	r1, #2
 3624 0052 30D0     		beq	.L655
 3625 0054 0329     		cmp	r1, #3
 3626 0056 1CD0     		beq	.L656
1806:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1464);
 3627              		.loc 1 1806 0
 3628 0058 B723     		mov	r3, #183
1798:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based
 3629              		.loc 1 1798 0
 3630 005a 0129     		cmp	r1, #1
 3631 005c 09D0     		beq	.L654
1801:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 732);
 3632              		.loc 1 1801 0
 3633 005e 9B00     		lsl	r3, r3, #2
 3634 0060 4343     		mul	r3, r0
 3635              	.LVL335:
1802:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 20000000) {return 0x33;}
 3636              		.loc 1 1802 0
 3637 0062 1B48     		ldr	r0, .L685+4
 3638              	.LVL336:
 3639 0064 8342     		cmp	r3, r0
 3640 0066 E8DD     		ble	.L667
 3641              	.L676:
1829:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
 3642              		.loc 1 1829 0
 3643 0068 1B4C     		ldr	r4, .L685+12
 3644 006a A342     		cmp	r3, r4
 3645 006c D0DD     		ble	.L651
1803:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 25000000) {return 0x34;}
 3646              		.loc 1 1803 0
 3647 006e 3423     		mov	r3, #52
 3648              	.LVL337:
 3649 0070 CEE7     		b	.L651
 3650              	.LVL338:
 3651              	.L654:
1806:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1464);
 3652              		.loc 1 1806 0
 3653 0072 DB00     		lsl	r3, r3, #3
 3654 0074 4343     		mul	r3, r0
 3655              	.LVL339:
1807:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 40000000) {return 0x35;}
 3656              		.loc 1 1807 0
 3657 0076 174A     		ldr	r2, .L685+8
 3658 0078 9342     		cmp	r3, r2
 3659 007a E4DD     		ble	.L668
 3660              	.LVL340:
 3661              	.L678:
1834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 3662              		.loc 1 1834 0
 3663 007c 1749     		ldr	r1, .L685+16
 3664 007e 8B42     		cmp	r3, r1
 3665 0080 C6DD     		ble	.L651
1808:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 50000000) {return 0x36;}
 3666              		.loc 1 1808 0
 3667 0082 3623     		mov	r3, #54
 3668              	.LVL341:
 3669 0084 C4E7     		b	.L651
 3670              	.L661:
1843:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 3671              		.loc 1 1843 0
 3672 0086 1649     		ldr	r1, .L685+20
1842:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2560);
 3673              		.loc 1 1842 0
 3674 0088 4302     		lsl	r3, r0, #9
 3675              	.LVL342:
1843:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 3676              		.loc 1 1843 0
 3677 008a 8B42     		cmp	r3, r1
 3678 008c 06DC     		bgt	.L682
 3679              	.L670:
1817:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 3680              		.loc 1 1817 0
 3681 008e 3923     		mov	r3, #57
 3682              	.LVL343:
 3683 0090 BEE7     		b	.L651
 3684              	.LVL344:
 3685              	.L656:
1816:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2929);
 3686              		.loc 1 1816 0
 3687 0092 144B     		ldr	r3, .L685+24
 3688 0094 4343     		mul	r3, r0
 3689              	.LVL345:
1817:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 80000000) {return 0x39;}
 3690              		.loc 1 1817 0
 3691 0096 1248     		ldr	r0, .L685+20
 3692              	.LVL346:
 3693 0098 8342     		cmp	r3, r0
 3694 009a F8DD     		ble	.L670
 3695              	.L682:
1844:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 3696              		.loc 1 1844 0
 3697 009c 124C     		ldr	r4, .L685+28
 3698 009e A342     		cmp	r3, r4
 3699 00a0 B6DD     		ble	.L651
1818:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 100000000) {return 0x3A;}
 3700              		.loc 1 1818 0
 3701 00a2 3A23     		mov	r3, #58
 3702              	.LVL347:
 3703 00a4 B4E7     		b	.L651
 3704              	.LVL348:
 3705              	.L660:
1837:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1920);
 3706              		.loc 1 1837 0
 3707 00a6 0301     		lsl	r3, r0, #4
1838:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 3708              		.loc 1 1838 0
 3709 00a8 104C     		ldr	r4, .L685+32
1837:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 1920);
 3710              		.loc 1 1837 0
 3711 00aa 181A     		sub	r0, r3, r0
 3712              	.LVL349:
 3713 00ac C301     		lsl	r3, r0, #7
 3714              	.LVL350:
1838:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 3715              		.loc 1 1838 0
 3716 00ae A342     		cmp	r3, r4
 3717 00b0 06DC     		bgt	.L680
 3718              	.L669:
1812:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 3719              		.loc 1 1812 0
 3720 00b2 3723     		mov	r3, #55
 3721              	.LVL351:
 3722 00b4 ACE7     		b	.L651
 3723              	.LVL352:
 3724              	.L655:
1811:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2197);
 3725              		.loc 1 1811 0
 3726 00b6 0E4B     		ldr	r3, .L685+36
1812:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 3727              		.loc 1 1812 0
 3728 00b8 0C4A     		ldr	r2, .L685+32
1811:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       fll_freq_hz = (fll_ref * 2197);
 3729              		.loc 1 1811 0
 3730 00ba 4343     		mul	r3, r0
 3731              	.LVL353:
1812:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (fll_freq_hz < 60000000) {return 0x37;}
 3732              		.loc 1 1812 0
 3733 00bc 9342     		cmp	r3, r2
 3734 00be F8DD     		ble	.L669
 3735              	.LVL354:
 3736              	.L680:
1839:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 3737              		.loc 1 1839 0
 3738 00c0 0C49     		ldr	r1, .L685+40
 3739 00c2 8B42     		cmp	r3, r1
 3740 00c4 A4DD     		ble	.L651
1813:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       else if (fll_freq_hz > 75000000) {return 0x38;}
 3741              		.loc 1 1813 0
 3742 00c6 3823     		mov	r3, #56
 3743              	.LVL355:
 3744 00c8 A2E7     		b	.L651
 3745              	.L686:
 3746 00ca C046     		.align	2
 3747              	.L685:
 3748 00cc 00400640 		.word	1074151424
 3749 00d0 FF2C3101 		.word	19999999
 3750 00d4 FF596202 		.word	39999999
 3751 00d8 40787D01 		.word	25000000
 3752 00dc 80F0FA02 		.word	50000000
 3753 00e0 FFB3C404 		.word	79999999
 3754 00e4 710B0000 		.word	2929
 3755 00e8 00E1F505 		.word	100000000
 3756 00ec FF869303 		.word	59999999
 3757 00f0 95080000 		.word	2197
 3758 00f4 C0687804 		.word	75000000
 3759              	.LBE5:
 3760              	.LBE4:
 3761              		.cfi_endproc
 3762              	.LFE25:
 3764              		.section	.text.fee_fei,"ax",%progbits
 3765              		.align	2
 3766              		.global	fee_fei
 3767              		.code	16
 3768              		.thumb_func
 3770              	fee_fei:
 3771              	.LFB23:
1634:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 3772              		.loc 1 1634 0
 3773              		.cfi_startproc
 3774              	.LVL356:
 3775 0000 38B5     		push	{r3, r4, r5, lr}
 3776              	.LCFI23:
 3777              		.cfi_def_cfa_offset 16
 3778              		.cfi_offset 3, -16
 3779              		.cfi_offset 4, -12
 3780              		.cfi_offset 5, -8
 3781              		.cfi_offset 14, -4
1639:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3782              		.loc 1 1639 0
 3783 0002 1B4C     		ldr	r4, .L700
1643:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x2;                                                     // return error code
 3784              		.loc 1 1643 0
 3785 0004 0223     		mov	r3, #2
1639:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3786              		.loc 1 1639 0
 3787 0006 A279     		ldrb	r2, [r4, #6]
 3788 0008 1107     		lsl	r1, r2, #28
 3789 000a 8D0F     		lsr	r5, r1, #30
 3790 000c 01D0     		beq	.L698
 3791              	.LVL357:
 3792              	.L688:
1671:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fee_fei
 3793              		.loc 1 1671 0
 3794 000e 181C     		mov	r0, r3
 3795              		@ sp needed for prologue
 3796 0010 38BD     		pop	{r3, r4, r5, pc}
 3797              	.LVL358:
 3798              	.L698:
1640:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external re
 3799              		.loc 1 1640 0
 3800 0012 A279     		ldrb	r2, [r4, #6]
1639:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3801              		.loc 1 1639 0
 3802 0014 D106     		lsl	r1, r2, #27
 3803 0016 FAD4     		bmi	.L688
1641:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected 
 3804              		.loc 1 1641 0
 3805 0018 A179     		ldrb	r1, [r4, #6]
 3806 001a 2025     		mov	r5, #32
1639:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3807              		.loc 1 1639 0
 3808 001c 0D42     		tst	r5, r1
 3809 001e F6D1     		bne	.L688
1647:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 3810              		.loc 1 1647 0
 3811 0020 144B     		ldr	r3, .L700+4
 3812 0022 154A     		ldr	r2, .L700+8
 3813 0024 C118     		add	r1, r0, r3
1649:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x31;
 3814              		.loc 1 1649 0
 3815 0026 3123     		mov	r3, #49
1647:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 3816              		.loc 1 1647 0
 3817 0028 9142     		cmp	r1, r2
 3818 002a F0D8     		bhi	.L688
1653:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 3819              		.loc 1 1653 0
 3820 002c FFF7FEFF 		bl	fll_freq
 3821              	.LVL359:
 3822 0030 031E     		sub	r3, r0, #0
 3823              	.LVL360:
1654:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 3824              		.loc 1 1654 0
 3825 0032 3B2B     		cmp	r3, #59
 3826 0034 EBDD     		ble	.L688
1657:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3827              		.loc 1 1657 0
 3828 0036 6079     		ldrb	r0, [r4, #5]
 3829              	.LVL361:
1660:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 3830              		.loc 1 1660 0
 3831 0038 0421     		mov	r1, #4
1657:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK;
 3832              		.loc 1 1657 0
 3833 003a A843     		bic	r0, r5
 3834 003c 6071     		strb	r0, [r4, #5]
1660:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 3835              		.loc 1 1660 0
 3836 003e 2578     		ldrb	r5, [r4]
 3837 0040 FA22     		mov	r2, #250
 3838 0042 2943     		orr	r1, r5
 3839 0044 2170     		strb	r1, [r4]
 3840              	.LVL362:
1665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3841              		.loc 1 1665 0
 3842 0046 1025     		mov	r5, #16
1660:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
 3843              		.loc 1 1660 0
 3844 0048 D100     		lsl	r1, r2, #3
 3845 004a 08E0     		b	.L690
 3846              	.LVL363:
 3847              	.L699:
1665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3848              		.loc 1 1665 0
 3849 004c A279     		ldrb	r2, [r4, #6]
 3850 004e 0139     		sub	r1, r1, #1
 3851 0050 89B2     		uxth	r1, r1
 3852 0052 1542     		tst	r5, r2
 3853 0054 06D1     		bne	.L689
 3854 0056 0139     		sub	r1, r1, #1
 3855 0058 89B2     		uxth	r1, r1
1663:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 3856              		.loc 1 1663 0
 3857 005a 0029     		cmp	r1, #0
 3858 005c 02D0     		beq	.L689
 3859              	.L690:
1665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 3860              		.loc 1 1665 0
 3861 005e A079     		ldrb	r0, [r4, #6]
 3862 0060 0542     		tst	r5, r0
 3863 0062 F3D0     		beq	.L699
 3864              	.L689:
1667:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 3865              		.loc 1 1667 0
 3866 0064 024C     		ldr	r4, .L700
 3867 0066 A579     		ldrb	r5, [r4, #6]
 3868 0068 E906     		lsl	r1, r5, #27
 3869 006a D0D4     		bmi	.L688
 3870 006c 1223     		mov	r3, #18
 3871              	.LVL364:
 3872 006e CEE7     		b	.L688
 3873              	.L701:
 3874              		.align	2
 3875              	.L700:
 3876 0070 00400640 		.word	1074151424
 3877 0074 EE85FFFF 		.word	-31250
 3878 0078 851E0000 		.word	7813
 3879              		.cfi_endproc
 3880              	.LFE23:
 3882              		.section	.text.fei_fee,"ax",%progbits
 3883              		.align	2
 3884              		.global	fei_fee
 3885              		.code	16
 3886              		.thumb_func
 3888              	fei_fee:
 3889              	.LFB22:
1526:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 3890              		.loc 1 1526 0
 3891              		.cfi_startproc
 3892              	.LVL365:
 3893 0000 70B5     		push	{r4, r5, r6, lr}
 3894              	.LCFI24:
 3895              		.cfi_def_cfa_offset 16
 3896              		.cfi_offset 4, -16
 3897              		.cfi_offset 5, -12
 3898              		.cfi_offset 6, -8
 3899              		.cfi_offset 14, -4
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3900              		.loc 1 1533 0
 3901 0002 5B4B     		ldr	r3, .L759
1526:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 3902              		.loc 1 1526 0
 3903 0004 051C     		mov	r5, r0
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3904              		.loc 1 1533 0
 3905 0006 9C79     		ldrb	r4, [r3, #6]
1526:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 3906              		.loc 1 1526 0
 3907 0008 161C     		mov	r6, r2
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3908              		.loc 1 1533 0
 3909 000a 2007     		lsl	r0, r4, #28
 3910              	.LVL366:
 3911 000c 820F     		lsr	r2, r0, #30
 3912              	.LVL367:
1537:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x1;                                                     // return error code
 3913              		.loc 1 1537 0
 3914 000e 0120     		mov	r0, #1
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3915              		.loc 1 1533 0
 3916 0010 002A     		cmp	r2, #0
 3917 0012 09D1     		bne	.L703
1534:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 3918              		.loc 1 1534 0
 3919 0014 9C79     		ldrb	r4, [r3, #6]
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3920              		.loc 1 1533 0
 3921 0016 E206     		lsl	r2, r4, #27
 3922 0018 06D5     		bpl	.L703
1535:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selecte
 3923              		.loc 1 1535 0
 3924 001a 9B79     		ldrb	r3, [r3, #6]
1533:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted
 3925              		.loc 1 1533 0
 3926 001c 9A06     		lsl	r2, r3, #26
 3927 001e 03D4     		bmi	.L703
1541:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 3928              		.loc 1 1541 0
 3929 0020 544A     		ldr	r2, .L759+4
 3930 0022 2120     		mov	r0, #33
 3931 0024 9542     		cmp	r5, r2
 3932 0026 00DD     		ble	.L754
 3933              	.LVL368:
 3934              	.L703:
1630:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fei_fee
 3935              		.loc 1 1630 0
 3936              		@ sp needed for prologue
 3937 0028 70BD     		pop	{r4, r5, r6, pc}
 3938              	.LVL369:
 3939              	.L754:
1544:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 3940              		.loc 1 1544 0
 3941 002a 002E     		cmp	r6, #0
 3942 002c 3BD1     		bne	.L755
 3943              	.L704:
1554:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 3944              		.loc 1 1554 0
 3945 002e 4B1E     		sub	r3, r1, #1
 3946 0030 9941     		sbc	r1, r1, r3
 3947              	.LVL370:
1560:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 3948              		.loc 1 1560 0
 3949 0032 4F4B     		ldr	r3, .L759
1561:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 3950              		.loc 1 1561 0
 3951 0034 3C20     		mov	r0, #60
1560:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 3952              		.loc 1 1560 0
 3953 0036 5A78     		ldrb	r2, [r3, #1]
 3954              	.LVL371:
1562:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 3955              		.loc 1 1562 0
 3956 0038 4F4C     		ldr	r4, .L759+8
1561:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 3957              		.loc 1 1561 0
 3958 003a 8243     		bic	r2, r0
 3959              	.LVL372:
 3960 003c 101C     		mov	r0, r2
 3961              	.LVL373:
1562:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 3962              		.loc 1 1562 0
 3963 003e A542     		cmp	r5, r4
 3964 0040 44DC     		bgt	.L705
1564:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 3965              		.loc 1 1564 0
 3966 0042 B200     		lsl	r2, r6, #2
 3967 0044 1043     		orr	r0, r2
 3968              	.LVL374:
 3969 0046 C0B2     		uxtb	r0, r0
 3970 0048 C900     		lsl	r1, r1, #3
 3971 004a 0143     		orr	r1, r0
 3972              	.LVL375:
1574:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 3973              		.loc 1 1574 0
 3974 004c 5970     		strb	r1, [r3, #1]
 3975              	.LVL376:
 3976              	.L753:
 3977 004e 0023     		mov	r3, #0
1578:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 3978              		.loc 1 1578 0
 3979 0050 0024     		mov	r4, #0
 3980              	.L706:
 3981              	.LVL377:
1586:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 3982              		.loc 1 1586 0
 3983 0052 474A     		ldr	r2, .L759
 3984 0054 5078     		ldrb	r0, [r2, #1]
 3985 0056 8106     		lsl	r1, r0, #26
 3986 0058 8A0F     		lsr	r2, r1, #30
 3987 005a 31D0     		beq	.L709
1588:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 3988              		.loc 1 1588 0
 3989 005c 2021     		mov	r1, #32
 3990 005e 9940     		lsl	r1, r1, r3
 3991 0060 281C     		mov	r0, r5
 3992 0062 FFF7FEFF 		bl	__aeabi_idiv
 3993              	.LVL378:
 3994              	.L710:
1596:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 3995              		.loc 1 1596 0
 3996 0066 FFF7FEFF 		bl	fll_freq
 3997              	.LVL379:
1597:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 3998              		.loc 1 1597 0
 3999 006a 3B28     		cmp	r0, #59
 4000 006c DCDD     		ble	.L703
1602:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 4001              		.loc 1 1602 0
 4002 006e 404D     		ldr	r5, .L759
 4003              	.LVL380:
1603:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 4004              		.loc 1 1603 0
 4005 0070 0321     		mov	r1, #3
1602:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 4006              		.loc 1 1602 0
 4007 0072 2B78     		ldrb	r3, [r5]
 4008              	.LVL381:
1604:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4009              		.loc 1 1604 0
 4010 0074 E200     		lsl	r2, r4, #3
1603:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these
 4011              		.loc 1 1603 0
 4012 0076 1940     		and	r1, r3
 4013              	.LVL382:
1604:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4014              		.loc 1 1604 0
 4015 0078 0C1C     		mov	r4, r1
 4016              	.LVL383:
 4017 007a 1443     		orr	r4, r2
 4018              	.LVL384:
1605:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 4019              		.loc 1 1605 0
 4020 007c 2C70     		strb	r4, [r5]
1608:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 4021              		.loc 1 1608 0
 4022 007e 002E     		cmp	r6, #0
 4023 0080 41D0     		beq	.L711
 4024 0082 3E4E     		ldr	r6, .L759+12
1612:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4025              		.loc 1 1612 0
 4026 0084 0223     		mov	r3, #2
 4027 0086 05E0     		b	.L713
 4028              	.L756:
 4029              	.LVL385:
 4030 0088 AA79     		ldrb	r2, [r5, #6]
 4031 008a 1342     		tst	r3, r2
 4032 008c 05D1     		bne	.L712
 4033 008e 023E     		sub	r6, r6, #2
1610:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 20000000 ; i++)
 4034              		.loc 1 1610 0
 4035 0090 002E     		cmp	r6, #0
 4036 0092 02D0     		beq	.L712
 4037              	.L713:
1612:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4038              		.loc 1 1612 0
 4039 0094 A979     		ldrb	r1, [r5, #6]
 4040 0096 0B42     		tst	r3, r1
 4041 0098 F6D0     		beq	.L756
 4042              	.L712:
1614:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 4043              		.loc 1 1614 0
 4044 009a 354D     		ldr	r5, .L759
 4045 009c AC79     		ldrb	r4, [r5, #6]
 4046              	.LVL386:
 4047 009e A107     		lsl	r1, r4, #30
 4048 00a0 31D4     		bmi	.L711
 4049 00a2 2320     		mov	r0, #35
 4050              	.LVL387:
 4051 00a4 C0E7     		b	.L703
 4052              	.LVL388:
 4053              	.L755:
1546:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4054              		.loc 1 1546 0
 4055 00a6 364C     		ldr	r4, .L759+16
1548:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 4056              		.loc 1 1548 0
 4057 00a8 2220     		mov	r0, #34
1546:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4058              		.loc 1 1546 0
 4059 00aa A542     		cmp	r5, r4
 4060 00ac BCDD     		ble	.L703
1547:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4061              		.loc 1 1547 0
 4062 00ae 354B     		ldr	r3, .L759+20
1546:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4063              		.loc 1 1546 0
 4064 00b0 354C     		ldr	r4, .L759+24
1547:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4065              		.loc 1 1547 0
 4066 00b2 EA18     		add	r2, r5, r3
1546:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4067              		.loc 1 1546 0
 4068 00b4 A242     		cmp	r2, r4
 4069 00b6 B7D9     		bls	.L703
1547:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4070              		.loc 1 1547 0
 4071 00b8 344B     		ldr	r3, .L759+28
 4072 00ba 9D42     		cmp	r5, r3
 4073 00bc B4DC     		bgt	.L703
 4074 00be B6E7     		b	.L704
 4075              	.LVL389:
 4076              	.L709:
1592:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 4077              		.loc 1 1592 0
 4078 00c0 0121     		mov	r1, #1
 4079 00c2 9940     		lsl	r1, r1, r3
 4080 00c4 281C     		mov	r0, r5
 4081 00c6 FFF7FEFF 		bl	__aeabi_idiv
 4082              	.LVL390:
 4083 00ca CCE7     		b	.L710
 4084              	.LVL391:
 4085              	.L705:
1566:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
 4086              		.loc 1 1566 0
 4087 00cc 304A     		ldr	r2, .L759+32
 4088 00ce 9542     		cmp	r5, r2
 4089 00d0 36DC     		bgt	.L707
1568:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4090              		.loc 1 1568 0
 4091 00d2 1024     		mov	r4, #16
 4092 00d4 2043     		orr	r0, r4
 4093              	.LVL392:
 4094 00d6 B200     		lsl	r2, r6, #2
 4095 00d8 1043     		orr	r0, r2
 4096 00da C0B2     		uxtb	r0, r0
 4097 00dc C900     		lsl	r1, r1, #3
 4098 00de 0143     		orr	r1, r0
 4099              	.LVL393:
1574:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 4100              		.loc 1 1574 0
 4101 00e0 5970     		strb	r1, [r3, #1]
1578:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4102              		.loc 1 1578 0
 4103 00e2 2C4B     		ldr	r3, .L759+36
 4104 00e4 9D42     		cmp	r5, r3
 4105 00e6 B2DD     		ble	.L753
 4106              	.LVL394:
 4107              	.L708:
1579:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4108              		.loc 1 1579 0
 4109 00e8 2B4C     		ldr	r4, .L759+40
 4110 00ea A542     		cmp	r5, r4
 4111 00ec 25DD     		ble	.L723
1580:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4112              		.loc 1 1580 0
 4113 00ee 2B4A     		ldr	r2, .L759+44
 4114 00f0 9542     		cmp	r5, r2
 4115 00f2 33DD     		ble	.L724
1581:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4116              		.loc 1 1581 0
 4117 00f4 2A48     		ldr	r0, .L759+48
 4118 00f6 8542     		cmp	r5, r0
 4119 00f8 33DD     		ble	.L725
1582:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4120              		.loc 1 1582 0
 4121 00fa 2049     		ldr	r1, .L759+12
 4122 00fc 8D42     		cmp	r5, r1
 4123 00fe 33DC     		bgt	.L726
 4124 0100 0423     		mov	r3, #4
 4125 0102 0424     		mov	r4, #4
 4126 0104 A5E7     		b	.L706
 4127              	.LVL395:
 4128              	.L711:
1620:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4129              		.loc 1 1620 0
 4130 0106 1A4E     		ldr	r6, .L759
 4131 0108 1021     		mov	r1, #16
 4132 010a B379     		ldrb	r3, [r6, #6]
 4133 010c 1942     		tst	r1, r3
 4134 010e 0ED0     		beq	.L714
 4135 0110 B579     		ldrb	r5, [r6, #6]
 4136 0112 244A     		ldr	r2, .L759+52
 4137 0114 2942     		tst	r1, r5
 4138 0116 0AD0     		beq	.L714
 4139 0118 013A     		sub	r2, r2, #1
 4140 011a 05E0     		b	.L734
 4141              	.L757:
 4142 011c B379     		ldrb	r3, [r6, #6]
 4143 011e 1942     		tst	r1, r3
 4144 0120 05D0     		beq	.L714
 4145 0122 023A     		sub	r2, r2, #2
1618:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4146              		.loc 1 1618 0
 4147 0124 002A     		cmp	r2, #0
 4148 0126 02D0     		beq	.L714
 4149              	.L734:
1620:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4150              		.loc 1 1620 0
 4151 0128 B479     		ldrb	r4, [r6, #6]
 4152 012a 2142     		tst	r1, r4
 4153 012c F6D1     		bne	.L757
 4154              	.L714:
1622:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4155              		.loc 1 1622 0
 4156 012e 104E     		ldr	r6, .L759
 4157 0130 B179     		ldrb	r1, [r6, #6]
 4158 0132 C906     		lsl	r1, r1, #27
 4159 0134 0DD5     		bpl	.L758
 4160 0136 1120     		mov	r0, #17
 4161              	.LVL396:
 4162 0138 76E7     		b	.L703
 4163              	.LVL397:
 4164              	.L723:
1579:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4165              		.loc 1 1579 0
 4166 013a 0123     		mov	r3, #1
 4167 013c 0124     		mov	r4, #1
 4168 013e 88E7     		b	.L706
 4169              	.LVL398:
 4170              	.L707:
1572:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4171              		.loc 1 1572 0
 4172 0140 2024     		mov	r4, #32
 4173 0142 2043     		orr	r0, r4
 4174              	.LVL399:
 4175 0144 B200     		lsl	r2, r6, #2
 4176 0146 1043     		orr	r0, r2
 4177 0148 C0B2     		uxtb	r0, r0
 4178 014a C900     		lsl	r1, r1, #3
 4179 014c 0143     		orr	r1, r0
 4180              	.LVL400:
1574:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 4181              		.loc 1 1574 0
 4182 014e 5970     		strb	r1, [r3, #1]
 4183 0150 CAE7     		b	.L708
 4184              	.LVL401:
 4185              	.L758:
1627:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 4186              		.loc 1 1627 0
 4187 0152 7579     		ldrb	r5, [r6, #5]
 4188 0154 2022     		mov	r2, #32
 4189 0156 2A43     		orr	r2, r5
 4190 0158 7271     		strb	r2, [r6, #5]
1629:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 4191              		.loc 1 1629 0
 4192 015a 65E7     		b	.L703
 4193              	.LVL402:
 4194              	.L724:
1580:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4195              		.loc 1 1580 0
 4196 015c 0223     		mov	r3, #2
 4197 015e 0224     		mov	r4, #2
 4198 0160 77E7     		b	.L706
 4199              	.L725:
1581:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4200              		.loc 1 1581 0
 4201 0162 0323     		mov	r3, #3
 4202 0164 0324     		mov	r4, #3
 4203 0166 74E7     		b	.L706
 4204              	.L726:
1582:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4205              		.loc 1 1582 0
 4206 0168 0523     		mov	r3, #5
1583:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
 4207              		.loc 1 1583 0
 4208 016a 0524     		mov	r4, #5
 4209 016c 71E7     		b	.L706
 4210              	.L760:
 4211 016e C046     		.align	2
 4212              	.L759:
 4213 0170 00400640 		.word	1074151424
 4214 0174 80F0FA02 		.word	50000000
 4215 0178 409C0000 		.word	40000
 4216 017c 002D3101 		.word	20000000
 4217 0180 2F750000 		.word	29999
 4218 0184 BF63FFFF 		.word	-40001
 4219 0188 7E2A2D00 		.word	2959998
 4220 018c 0048E801 		.word	32000000
 4221 0190 00127A00 		.word	8000000
 4222 0194 D0121300 		.word	1250000
 4223 0198 A0252600 		.word	2500000
 4224 019c 404B4C00 		.word	5000000
 4225 01a0 80969800 		.word	10000000
 4226 01a4 CF070000 		.word	1999
 4227              		.cfi_endproc
 4228              	.LFE22:
 4230              		.section	.text.fbi_fei,"ax",%progbits
 4231              		.align	2
 4232              		.global	fbi_fei
 4233              		.code	16
 4234              		.thumb_func
 4236              	fbi_fei:
 4237              	.LFB20:
1379:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 4238              		.loc 1 1379 0
 4239              		.cfi_startproc
 4240              	.LVL403:
 4241 0000 10B5     		push	{r4, lr}
 4242              	.LCFI25:
 4243              		.cfi_def_cfa_offset 8
 4244              		.cfi_offset 4, -8
 4245              		.cfi_offset 14, -4
1385:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4246              		.loc 1 1385 0
 4247 0002 284C     		ldr	r4, .L791
1390:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 4248              		.loc 1 1390 0
 4249 0004 0323     		mov	r3, #3
1385:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4250              		.loc 1 1385 0
 4251 0006 A279     		ldrb	r2, [r4, #6]
 4252 0008 1107     		lsl	r1, r2, #28
 4253 000a 8A0F     		lsr	r2, r1, #30
 4254 000c 012A     		cmp	r2, #1
 4255 000e 01D0     		beq	.L787
 4256              	.LVL404:
 4257              	.L762:
1426:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbi_fei
 4258              		.loc 1 1426 0
 4259 0010 181C     		mov	r0, r3
 4260              		@ sp needed for prologue
 4261 0012 10BD     		pop	{r4, pc}
 4262              	.LVL405:
 4263              	.L787:
1386:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4264              		.loc 1 1386 0
 4265 0014 A179     		ldrb	r1, [r4, #6]
1385:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4266              		.loc 1 1385 0
 4267 0016 C906     		lsl	r1, r1, #27
 4268 0018 FAD5     		bpl	.L762
1387:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4269              		.loc 1 1387 0
 4270 001a A279     		ldrb	r2, [r4, #6]
1386:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4271              		.loc 1 1386 0
 4272 001c 9106     		lsl	r1, r2, #26
 4273 001e F7D4     		bmi	.L762
1388:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4274              		.loc 1 1388 0
 4275 0020 6178     		ldrb	r1, [r4, #1]
1385:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4276              		.loc 1 1385 0
 4277 0022 8907     		lsl	r1, r1, #30
 4278 0024 F4D4     		bmi	.L762
1394:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4279              		.loc 1 1394 0
 4280 0026 204B     		ldr	r3, .L791+4
 4281 0028 204A     		ldr	r2, .L791+8
 4282 002a C118     		add	r1, r0, r3
1396:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x31;
 4283              		.loc 1 1396 0
 4284 002c 3123     		mov	r3, #49
1394:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4285              		.loc 1 1394 0
 4286 002e 9142     		cmp	r1, r2
 4287 0030 EED8     		bhi	.L762
1400:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 4288              		.loc 1 1400 0
 4289 0032 FFF7FEFF 		bl	fll_freq
 4290              	.LVL406:
 4291 0036 031E     		sub	r3, r0, #0
 4292              	.LVL407:
1401:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4293              		.loc 1 1401 0
 4294 0038 3B2B     		cmp	r3, #59
 4295 003a E9DD     		ble	.L762
1404:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 4296              		.loc 1 1404 0
 4297 003c 2078     		ldrb	r0, [r4]
 4298              	.LVL408:
1405:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
 4299              		.loc 1 1405 0
 4300 003e 3F22     		mov	r2, #63
 4301 0040 0240     		and	r2, r0
 4302              	.LVL409:
1407:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
 4303              		.loc 1 1407 0
 4304 0042 0421     		mov	r1, #4
 4305 0044 0A43     		orr	r2, r1
 4306              	.LVL410:
1408:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 4307              		.loc 1 1408 0
 4308 0046 FA20     		mov	r0, #250
 4309 0048 2270     		strb	r2, [r4]
 4310              	.LVL411:
1413:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 4311              		.loc 1 1413 0
 4312 004a 1021     		mov	r1, #16
1408:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1
 4313              		.loc 1 1408 0
 4314 004c C200     		lsl	r2, r0, #3
 4315              	.LVL412:
 4316 004e 08E0     		b	.L764
 4317              	.LVL413:
 4318              	.L788:
1413:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 4319              		.loc 1 1413 0
 4320 0050 A079     		ldrb	r0, [r4, #6]
 4321 0052 013A     		sub	r2, r2, #1
 4322 0054 92B2     		uxth	r2, r2
 4323 0056 0142     		tst	r1, r0
 4324 0058 06D1     		bne	.L763
 4325 005a 013A     		sub	r2, r2, #1
 4326 005c 92B2     		uxth	r2, r2
1411:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4327              		.loc 1 1411 0
 4328 005e 002A     		cmp	r2, #0
 4329 0060 02D0     		beq	.L763
 4330              	.L764:
1413:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
 4331              		.loc 1 1413 0
 4332 0062 A079     		ldrb	r0, [r4, #6]
 4333 0064 0142     		tst	r1, r0
 4334 0066 F3D0     		beq	.L788
 4335              	.L763:
1415:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 4336              		.loc 1 1415 0
 4337 0068 0E48     		ldr	r0, .L791
 4338 006a 8479     		ldrb	r4, [r0, #6]
 4339 006c E106     		lsl	r1, r4, #27
 4340 006e 01D4     		bmi	.L789
 4341 0070 1223     		mov	r3, #18
 4342              	.LVL414:
 4343 0072 CDE7     		b	.L762
 4344              	.LVL415:
 4345              	.L789:
 4346 0074 FA21     		mov	r1, #250
 4347 0076 CA00     		lsl	r2, r1, #3
1420:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4348              		.loc 1 1420 0
 4349 0078 0C21     		mov	r1, #12
 4350 007a 08E0     		b	.L766
 4351              	.L790:
 4352 007c 8479     		ldrb	r4, [r0, #6]
 4353 007e 013A     		sub	r2, r2, #1
 4354 0080 92B2     		uxth	r2, r2
 4355 0082 2142     		tst	r1, r4
 4356 0084 06D0     		beq	.L765
 4357 0086 013A     		sub	r2, r2, #1
 4358 0088 92B2     		uxth	r2, r2
1418:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4359              		.loc 1 1418 0
 4360 008a 002A     		cmp	r2, #0
 4361 008c 02D0     		beq	.L765
 4362              	.L766:
1420:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4363              		.loc 1 1420 0
 4364 008e 8479     		ldrb	r4, [r0, #6]
 4365 0090 2142     		tst	r1, r4
 4366 0092 F3D1     		bne	.L790
 4367              	.L765:
1422:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 4368              		.loc 1 1422 0
 4369 0094 0348     		ldr	r0, .L791
 4370 0096 8179     		ldrb	r1, [r0, #6]
 4371 0098 0C07     		lsl	r4, r1, #28
 4372 009a A20F     		lsr	r2, r4, #30
 4373 009c B8D0     		beq	.L762
 4374 009e 1823     		mov	r3, #24
 4375              	.LVL416:
 4376 00a0 B6E7     		b	.L762
 4377              	.L792:
 4378 00a2 C046     		.align	2
 4379              	.L791:
 4380 00a4 00400640 		.word	1074151424
 4381 00a8 EE85FFFF 		.word	-31250
 4382 00ac 851E0000 		.word	7813
 4383              		.cfi_endproc
 4384              	.LFE20:
 4386              		.section	.text.fbi_fee,"ax",%progbits
 4387              		.align	2
 4388              		.global	fbi_fee
 4389              		.code	16
 4390              		.thumb_func
 4392              	fbi_fee:
 4393              	.LFB18:
1179:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 4394              		.loc 1 1179 0
 4395              		.cfi_startproc
 4396              	.LVL417:
 4397 0000 70B5     		push	{r4, r5, r6, lr}
 4398              	.LCFI26:
 4399              		.cfi_def_cfa_offset 16
 4400              		.cfi_offset 4, -16
 4401              		.cfi_offset 5, -12
 4402              		.cfi_offset 6, -8
 4403              		.cfi_offset 14, -4
1186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4404              		.loc 1 1186 0
 4405 0002 654B     		ldr	r3, .L861
1179:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 4406              		.loc 1 1179 0
 4407 0004 161C     		mov	r6, r2
1186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4408              		.loc 1 1186 0
 4409 0006 9D79     		ldrb	r5, [r3, #6]
1191:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x3;                                                       // MCG not in correct mode re
 4410              		.loc 1 1191 0
 4411 0008 0324     		mov	r4, #3
1186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4412              		.loc 1 1186 0
 4413 000a 2A07     		lsl	r2, r5, #28
 4414              	.LVL418:
 4415 000c 950F     		lsr	r5, r2, #30
 4416 000e 012D     		cmp	r5, #1
 4417 0010 01D0     		beq	.L855
 4418              	.LVL419:
 4419              	.L794:
1291:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } //fbi_fee
 4420              		.loc 1 1291 0
 4421 0012 201C     		mov	r0, r4
 4422              		@ sp needed for prologue
 4423 0014 70BD     		pop	{r4, r5, r6, pc}
 4424              	.LVL420:
 4425              	.L855:
1187:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4426              		.loc 1 1187 0
 4427 0016 9A79     		ldrb	r2, [r3, #6]
1186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4428              		.loc 1 1186 0
 4429 0018 D506     		lsl	r5, r2, #27
 4430 001a FAD5     		bpl	.L794
1188:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4431              		.loc 1 1188 0
 4432 001c 9D79     		ldrb	r5, [r3, #6]
1187:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal 
 4433              		.loc 1 1187 0
 4434 001e AD06     		lsl	r5, r5, #26
 4435 0020 F7D4     		bmi	.L794
1189:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
 4436              		.loc 1 1189 0
 4437 0022 5B78     		ldrb	r3, [r3, #1]
1186:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted
 4438              		.loc 1 1186 0
 4439 0024 9A07     		lsl	r2, r3, #30
 4440 0026 F4D4     		bmi	.L794
1195:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if  (crystal_val > 50000000) {return 0x21;}
 4441              		.loc 1 1195 0
 4442 0028 5C4A     		ldr	r2, .L861+4
 4443 002a 2124     		mov	r4, #33
 4444 002c 9042     		cmp	r0, r2
 4445 002e F0DC     		bgt	.L794
1198:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 4446              		.loc 1 1198 0
 4447 0030 002E     		cmp	r6, #0
 4448 0032 0BD0     		beq	.L795
1200:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4449              		.loc 1 1200 0
 4450 0034 5A4D     		ldr	r5, .L861+8
1202:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal op
 4451              		.loc 1 1202 0
 4452 0036 2224     		mov	r4, #34
1200:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4453              		.loc 1 1200 0
 4454 0038 A842     		cmp	r0, r5
 4455 003a EADD     		ble	.L794
1201:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4456              		.loc 1 1201 0
 4457 003c 594B     		ldr	r3, .L861+12
1200:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4458              		.loc 1 1200 0
 4459 003e 5A4D     		ldr	r5, .L861+16
1201:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4460              		.loc 1 1201 0
 4461 0040 C218     		add	r2, r0, r3
1200:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if ((crystal_val < 30000) ||
 4462              		.loc 1 1200 0
 4463 0042 AA42     		cmp	r2, r5
 4464 0044 E5D9     		bls	.L794
1201:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         ((crystal_val > 40000) && (crystal_val < 3000000)) ||
 4465              		.loc 1 1201 0
 4466 0046 594B     		ldr	r3, .L861+20
 4467 0048 9842     		cmp	r0, r3
 4468 004a E2DC     		bgt	.L794
 4469              	.L795:
1214:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 4470              		.loc 1 1214 0
 4471 004c 524D     		ldr	r5, .L861
1208:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     hgo_val = 1; // force hgo_val to 1 if > 0
 4472              		.loc 1 1208 0
 4473 004e 0A1C     		mov	r2, r1
 4474 0050 511E     		sub	r1, r2, #1
 4475 0052 8A41     		sbc	r2, r2, r1
 4476              	.LVL421:
1216:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 4477              		.loc 1 1216 0
 4478 0054 564B     		ldr	r3, .L861+24
1214:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C2;
 4479              		.loc 1 1214 0
 4480 0056 6978     		ldrb	r1, [r5, #1]
 4481              	.LVL422:
1215:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before
 4482              		.loc 1 1215 0
 4483 0058 3C24     		mov	r4, #60
 4484 005a A143     		bic	r1, r4
 4485              	.LVL423:
1216:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 40000)
 4486              		.loc 1 1216 0
 4487 005c 9842     		cmp	r0, r3
 4488 005e 54DC     		bgt	.L796
1218:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4489              		.loc 1 1218 0
 4490 0060 B400     		lsl	r4, r6, #2
 4491 0062 2143     		orr	r1, r4
 4492              	.LVL424:
 4493 0064 C9B2     		uxtb	r1, r1
 4494 0066 D200     		lsl	r2, r2, #3
 4495 0068 0A43     		orr	r2, r1
 4496              	.LVL425:
1228:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 4497              		.loc 1 1228 0
 4498 006a 6A70     		strb	r2, [r5, #1]
1232:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4499              		.loc 1 1232 0
 4500 006c 0025     		mov	r5, #0
 4501              	.LVL426:
 4502              	.L797:
1239:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4503              		.loc 1 1239 0
 4504 006e 4A4B     		ldr	r3, .L861
 4505 0070 5C78     		ldrb	r4, [r3, #1]
 4506 0072 A106     		lsl	r1, r4, #26
 4507 0074 8A0F     		lsr	r2, r1, #30
 4508 0076 43D0     		beq	.L800
1241:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
 4509              		.loc 1 1241 0
 4510 0078 2021     		mov	r1, #32
 4511 007a A940     		lsl	r1, r1, r5
 4512 007c FFF7FEFF 		bl	__aeabi_idiv
 4513              	.LVL427:
 4514              	.L801:
1249:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 4515              		.loc 1 1249 0
 4516 0080 FFF7FEFF 		bl	fll_freq
 4517              	.LVL428:
 4518 0084 041E     		sub	r4, r0, #0
 4519              	.LVL429:
1250:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4520              		.loc 1 1250 0
 4521 0086 3B2C     		cmp	r4, #59
 4522 0088 C3DD     		ble	.L794
1255:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 4523              		.loc 1 1255 0
 4524 008a 4349     		ldr	r1, .L861
1256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
 4525              		.loc 1 1256 0
 4526 008c 0323     		mov	r3, #3
1255:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 4527              		.loc 1 1255 0
 4528 008e 0878     		ldrb	r0, [r1]
 4529              	.LVL430:
1257:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4530              		.loc 1 1257 0
 4531 0090 ED00     		lsl	r5, r5, #3
 4532              	.LVL431:
1256:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and
 4533              		.loc 1 1256 0
 4534 0092 0340     		and	r3, r0
 4535              	.LVL432:
1257:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
 4536              		.loc 1 1257 0
 4537 0094 1D43     		orr	r5, r3
 4538              	.LVL433:
1258:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg;
 4539              		.loc 1 1258 0
 4540 0096 0D70     		strb	r5, [r1]
1261:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (erefs_val)
 4541              		.loc 1 1261 0
 4542 0098 002E     		cmp	r6, #0
 4543 009a 14D0     		beq	.L802
 4544 009c 454D     		ldr	r5, .L861+28
 4545              	.LVL434:
1265:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4546              		.loc 1 1265 0
 4547 009e 0226     		mov	r6, #2
 4548 00a0 08E0     		b	.L804
 4549              	.L856:
 4550              	.LVL435:
 4551 00a2 8879     		ldrb	r0, [r1, #6]
 4552 00a4 013D     		sub	r5, r5, #1
 4553 00a6 ABB2     		uxth	r3, r5
 4554 00a8 0642     		tst	r6, r0
 4555 00aa 06D1     		bne	.L803
 4556 00ac 013B     		sub	r3, r3, #1
 4557 00ae 9DB2     		uxth	r5, r3
1263:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     for (i = 0 ; i < 10000 ; i++)
 4558              		.loc 1 1263 0
 4559 00b0 002D     		cmp	r5, #0
 4560 00b2 02D0     		beq	.L803
 4561              	.L804:
1265:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishe
 4562              		.loc 1 1265 0
 4563 00b4 8A79     		ldrb	r2, [r1, #6]
 4564 00b6 1642     		tst	r6, r2
 4565 00b8 F3D0     		beq	.L856
 4566              	.L803:
1267:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with err
 4567              		.loc 1 1267 0
 4568 00ba 3749     		ldr	r1, .L861
 4569 00bc 8E79     		ldrb	r6, [r1, #6]
 4570 00be B507     		lsl	r5, r6, #30
 4571 00c0 01D4     		bmi	.L802
 4572 00c2 2324     		mov	r4, #35
 4573              	.LVL436:
 4574 00c4 A5E7     		b	.L794
 4575              	.LVL437:
 4576              	.L802:
1273:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4577              		.loc 1 1273 0
 4578 00c6 344A     		ldr	r2, .L861
 4579 00c8 1025     		mov	r5, #16
 4580 00ca 9379     		ldrb	r3, [r2, #6]
 4581 00cc 1D42     		tst	r5, r3
 4582 00ce 11D0     		beq	.L805
 4583 00d0 9079     		ldrb	r0, [r2, #6]
 4584 00d2 394E     		ldr	r6, .L861+32
 4585 00d4 0542     		tst	r5, r0
 4586 00d6 0DD0     		beq	.L805
 4587 00d8 013E     		sub	r6, r6, #1
 4588 00da 08E0     		b	.L831
 4589              	.L857:
 4590 00dc 9379     		ldrb	r3, [r2, #6]
 4591 00de 013E     		sub	r6, r6, #1
 4592 00e0 B6B2     		uxth	r6, r6
 4593 00e2 1D42     		tst	r5, r3
 4594 00e4 06D0     		beq	.L805
 4595 00e6 013E     		sub	r6, r6, #1
 4596 00e8 B6B2     		uxth	r6, r6
1271:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4597              		.loc 1 1271 0
 4598 00ea 002E     		cmp	r6, #0
 4599 00ec 02D0     		beq	.L805
 4600              	.L831:
1273:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishe
 4601              		.loc 1 1273 0
 4602 00ee 9179     		ldrb	r1, [r2, #6]
 4603 00f0 0D42     		tst	r5, r1
 4604 00f2 F3D1     		bne	.L857
 4605              	.L805:
1275:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4606              		.loc 1 1275 0
 4607 00f4 284D     		ldr	r5, .L861
 4608 00f6 AA79     		ldrb	r2, [r5, #6]
 4609 00f8 D206     		lsl	r2, r2, #27
 4610 00fa 30D5     		bpl	.L858
 4611 00fc 1124     		mov	r4, #17
 4612              	.LVL438:
 4613 00fe 88E7     		b	.L794
 4614              	.LVL439:
 4615              	.L800:
1245:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
 4616              		.loc 1 1245 0
 4617 0100 0121     		mov	r1, #1
 4618 0102 A940     		lsl	r1, r1, r5
 4619 0104 FFF7FEFF 		bl	__aeabi_idiv
 4620              	.LVL440:
 4621 0108 BAE7     		b	.L801
 4622              	.LVL441:
 4623              	.L796:
1220:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 8000000)
 4624              		.loc 1 1220 0
 4625 010a 2C4C     		ldr	r4, .L861+36
 4626 010c A042     		cmp	r0, r4
 4627 010e 1DDC     		bgt	.L798
1222:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4628              		.loc 1 1222 0
 4629 0110 1023     		mov	r3, #16
 4630 0112 1943     		orr	r1, r3
 4631              	.LVL442:
 4632 0114 B400     		lsl	r4, r6, #2
 4633 0116 2143     		orr	r1, r4
 4634 0118 C9B2     		uxtb	r1, r1
 4635 011a D200     		lsl	r2, r2, #3
1232:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4636              		.loc 1 1232 0
 4637 011c 284B     		ldr	r3, .L861+40
1222:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4638              		.loc 1 1222 0
 4639 011e 0A43     		orr	r2, r1
 4640              	.LVL443:
1228:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 4641              		.loc 1 1228 0
 4642 0120 6A70     		strb	r2, [r5, #1]
1232:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (crystal_val <= 1250000) {frdiv_val = 0;}
 4643              		.loc 1 1232 0
 4644 0122 0025     		mov	r5, #0
 4645 0124 9842     		cmp	r0, r3
 4646 0126 A2DD     		ble	.L797
 4647              	.LVL444:
 4648              	.L799:
1233:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 2500000) {frdiv_val = 1;}
 4649              		.loc 1 1233 0
 4650 0128 264C     		ldr	r4, .L861+44
 4651 012a 0125     		mov	r5, #1
 4652 012c A042     		cmp	r0, r4
 4653 012e 9EDD     		ble	.L797
1234:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 5000000) {frdiv_val = 2;}
 4654              		.loc 1 1234 0
 4655 0130 2549     		ldr	r1, .L861+48
 4656 0132 0225     		mov	r5, #2
 4657 0134 8842     		cmp	r0, r1
 4658 0136 9ADD     		ble	.L797
1235:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 10000000) {frdiv_val = 3;}
 4659              		.loc 1 1235 0
 4660 0138 244A     		ldr	r2, .L861+52
 4661 013a 0325     		mov	r5, #3
 4662 013c 9042     		cmp	r0, r2
 4663 013e 96DD     		ble	.L797
1236:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4664              		.loc 1 1236 0
 4665 0140 234B     		ldr	r3, .L861+56
1237:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else {frdiv_val = 5;}
 4666              		.loc 1 1237 0
 4667 0142 0525     		mov	r5, #5
1236:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if (crystal_val <= 20000000) {frdiv_val = 4;}
 4668              		.loc 1 1236 0
 4669 0144 9842     		cmp	r0, r3
 4670 0146 92DC     		bgt	.L797
 4671 0148 0425     		mov	r5, #4
 4672 014a 90E7     		b	.L797
 4673              	.LVL445:
 4674              	.L798:
1226:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SH
 4675              		.loc 1 1226 0
 4676 014c 2023     		mov	r3, #32
 4677 014e 1943     		orr	r1, r3
 4678              	.LVL446:
 4679 0150 B400     		lsl	r4, r6, #2
 4680 0152 2143     		orr	r1, r4
 4681 0154 C9B2     		uxtb	r1, r1
 4682 0156 D200     		lsl	r2, r2, #3
 4683 0158 0A43     		orr	r2, r1
 4684              	.LVL447:
1228:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C2 = temp_reg;
 4685              		.loc 1 1228 0
 4686 015a 6A70     		strb	r2, [r5, #1]
 4687 015c E4E7     		b	.L799
 4688              	.LVL448:
 4689              	.L858:
1275:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if
 4690              		.loc 1 1275 0
 4691 015e FA20     		mov	r0, #250
 4692 0160 C000     		lsl	r0, r0, #3
1280:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4693              		.loc 1 1280 0
 4694 0162 0C21     		mov	r1, #12
 4695 0164 08E0     		b	.L807
 4696              	.L859:
 4697 0166 AA79     		ldrb	r2, [r5, #6]
 4698 0168 0138     		sub	r0, r0, #1
 4699 016a 83B2     		uxth	r3, r0
 4700 016c 1142     		tst	r1, r2
 4701 016e 06D0     		beq	.L806
 4702 0170 013B     		sub	r3, r3, #1
 4703 0172 98B2     		uxth	r0, r3
1278:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4704              		.loc 1 1278 0
 4705 0174 0028     		cmp	r0, #0
 4706 0176 02D0     		beq	.L806
 4707              	.L807:
1280:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4708              		.loc 1 1280 0
 4709 0178 AE79     		ldrb	r6, [r5, #6]
 4710 017a 3142     		tst	r1, r6
 4711 017c F3D1     		bne	.L859
 4712              	.L806:
1282:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is reall
 4713              		.loc 1 1282 0
 4714 017e 064D     		ldr	r5, .L861
 4715 0180 A979     		ldrb	r1, [r5, #6]
 4716 0182 0E07     		lsl	r6, r1, #28
 4717 0184 B30F     		lsr	r3, r6, #30
 4718 0186 01D0     		beq	.L860
 4719 0188 1824     		mov	r4, #24
 4720              	.LVL449:
 4721 018a 42E7     		b	.L794
 4722              	.LVL450:
 4723              	.L860:
1288:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 |= MCG_C6_CME0_MASK;
 4724              		.loc 1 1288 0
 4725 018c 6A79     		ldrb	r2, [r5, #5]
 4726 018e 2020     		mov	r0, #32
 4727 0190 0243     		orr	r2, r0
 4728 0192 6A71     		strb	r2, [r5, #5]
1290:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return mcg_out; // MCGOUT frequency equals FLL frequency
 4729              		.loc 1 1290 0
 4730 0194 3DE7     		b	.L794
 4731              	.L862:
 4732 0196 C046     		.align	2
 4733              	.L861:
 4734 0198 00400640 		.word	1074151424
 4735 019c 80F0FA02 		.word	50000000
 4736 01a0 2F750000 		.word	29999
 4737 01a4 BF63FFFF 		.word	-40001
 4738 01a8 7E2A2D00 		.word	2959998
 4739 01ac 0048E801 		.word	32000000
 4740 01b0 409C0000 		.word	40000
 4741 01b4 10270000 		.word	10000
 4742 01b8 CF070000 		.word	1999
 4743 01bc 00127A00 		.word	8000000
 4744 01c0 D0121300 		.word	1250000
 4745 01c4 A0252600 		.word	2500000
 4746 01c8 404B4C00 		.word	5000000
 4747 01cc 80969800 		.word	10000000
 4748 01d0 002D3101 		.word	20000000
 4749              		.cfi_endproc
 4750              	.LFE18:
 4752              		.section	.text.fbe_fee,"ax",%progbits
 4753              		.align	2
 4754              		.global	fbe_fee
 4755              		.code	16
 4756              		.thumb_func
 4758              	fbe_fee:
 4759              	.LFB12:
 829:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 4760              		.loc 1 829 0
 4761              		.cfi_startproc
 4762              	.LVL451:
 4763 0000 38B5     		push	{r3, r4, r5, lr}
 4764              	.LCFI27:
 4765              		.cfi_def_cfa_offset 16
 4766              		.cfi_offset 3, -16
 4767              		.cfi_offset 4, -12
 4768              		.cfi_offset 5, -8
 4769              		.cfi_offset 14, -4
 834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4770              		.loc 1 834 0
 4771 0002 254B     		ldr	r3, .L885
 829:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 4772              		.loc 1 829 0
 4773 0004 041C     		mov	r4, r0
 834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4774              		.loc 1 834 0
 4775 0006 9A79     		ldrb	r2, [r3, #6]
 4776 0008 1007     		lsl	r0, r2, #28
 4777              	.LVL452:
 4778 000a 820F     		lsr	r2, r0, #30
 839:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 4779              		.loc 1 839 0
 4780 000c 0420     		mov	r0, #4
 834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4781              		.loc 1 834 0
 4782 000e 022A     		cmp	r2, #2
 4783 0010 00D0     		beq	.L883
 4784              	.LVL453:
 4785              	.L864:
 868:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbe_fee
 4786              		.loc 1 868 0
 4787              		@ sp needed for prologue
 4788 0012 38BD     		pop	{r3, r4, r5, pc}
 4789              	.LVL454:
 4790              	.L883:
 835:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4791              		.loc 1 835 0
 4792 0014 9979     		ldrb	r1, [r3, #6]
 834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4793              		.loc 1 834 0
 4794 0016 CD06     		lsl	r5, r1, #27
 4795 0018 FBD4     		bmi	.L864
 836:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4796              		.loc 1 836 0
 4797 001a 9D79     		ldrb	r5, [r3, #6]
 4798 001c 2021     		mov	r1, #32
 835:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4799              		.loc 1 835 0
 4800 001e 2942     		tst	r1, r5
 4801 0020 F7D1     		bne	.L864
 837:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 4802              		.loc 1 837 0
 4803 0022 5D78     		ldrb	r5, [r3, #1]
 834:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4804              		.loc 1 834 0
 4805 0024 2A42     		tst	r2, r5
 4806 0026 F4D1     		bne	.L864
 843:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
 4807              		.loc 1 843 0
 4808 0028 5878     		ldrb	r0, [r3, #1]
 4809 002a 3022     		mov	r2, #48
 4810 002c 0242     		tst	r2, r0
 4811 002e 28D0     		beq	.L865
 845:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
 4812              		.loc 1 845 0
 4813 0030 1878     		ldrb	r0, [r3]
 4814 0032 8206     		lsl	r2, r0, #26
 4815 0034 530F     		lsr	r3, r2, #29
 4816 0036 201C     		mov	r0, r4
 4817 0038 9940     		lsl	r1, r1, r3
 4818 003a FFF7FEFF 		bl	__aeabi_idiv
 4819              	.LVL455:
 4820 003e 84B2     		uxth	r4, r0
 4821              	.LVL456:
 4822              	.L866:
 853:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRD
 4823              		.loc 1 853 0
 4824 0040 20B2     		sxth	r0, r4
 4825 0042 FFF7FEFF 		bl	fll_freq
 4826              	.LVL457:
 854:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4827              		.loc 1 854 0
 4828 0046 3B28     		cmp	r0, #59
 4829 0048 E3DD     		ble	.L864
 857:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 4830              		.loc 1 857 0
 4831 004a 1349     		ldr	r1, .L885
 4832 004c 3F24     		mov	r4, #63
 4833              	.LVL458:
 4834 004e 0D78     		ldrb	r5, [r1]
 4835 0050 FA22     		mov	r2, #250
 4836 0052 2540     		and	r5, r4
 4837 0054 0D70     		strb	r5, [r1]
 4838              	.LVL459:
 4839 0056 D300     		lsl	r3, r2, #3
 862:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4840              		.loc 1 862 0
 4841 0058 0C25     		mov	r5, #12
 4842 005a 08E0     		b	.L868
 4843              	.LVL460:
 4844              	.L884:
 4845 005c 8A79     		ldrb	r2, [r1, #6]
 4846 005e 013B     		sub	r3, r3, #1
 4847 0060 9BB2     		uxth	r3, r3
 4848 0062 1542     		tst	r5, r2
 4849 0064 06D0     		beq	.L867
 4850 0066 013B     		sub	r3, r3, #1
 4851 0068 9BB2     		uxth	r3, r3
 860:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4852              		.loc 1 860 0
 4853 006a 002B     		cmp	r3, #0
 4854 006c 02D0     		beq	.L867
 4855              	.L868:
 862:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 4856              		.loc 1 862 0
 4857 006e 8C79     		ldrb	r4, [r1, #6]
 4858 0070 2542     		tst	r5, r4
 4859 0072 F3D1     		bne	.L884
 4860              	.L867:
 864:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really
 4861              		.loc 1 864 0
 4862 0074 0849     		ldr	r1, .L885
 4863 0076 8D79     		ldrb	r5, [r1, #6]
 4864 0078 2C07     		lsl	r4, r5, #28
 4865 007a A20F     		lsr	r2, r4, #30
 4866 007c C9D0     		beq	.L864
 4867 007e 1820     		mov	r0, #24
 4868              	.LVL461:
 4869 0080 C7E7     		b	.L864
 4870              	.LVL462:
 4871              	.L865:
 849:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT)))
 4872              		.loc 1 849 0
 4873 0082 5B78     		ldrb	r3, [r3, #1]
 4874 0084 0121     		mov	r1, #1
 4875 0086 1A40     		and	r2, r3
 4876 0088 1509     		lsr	r5, r2, #4
 4877 008a 201C     		mov	r0, r4
 4878 008c A940     		lsl	r1, r1, r5
 4879 008e FFF7FEFF 		bl	__aeabi_idiv
 4880              	.LVL463:
 4881 0092 84B2     		uxth	r4, r0
 4882              	.LVL464:
 4883 0094 D4E7     		b	.L866
 4884              	.L886:
 4885 0096 C046     		.align	2
 4886              	.L885:
 4887 0098 00400640 		.word	1074151424
 4888              		.cfi_endproc
 4889              	.LFE12:
 4891              		.section	.text.fbe_fei,"ax",%progbits
 4892              		.align	2
 4893              		.global	fbe_fei
 4894              		.code	16
 4895              		.thumb_func
 4897              	fbe_fei:
 4898              	.LFB10:
 659:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 4899              		.loc 1 659 0
 4900              		.cfi_startproc
 4901              	.LVL465:
 4902 0000 38B5     		push	{r3, r4, r5, lr}
 4903              	.LCFI28:
 4904              		.cfi_def_cfa_offset 16
 4905              		.cfi_offset 3, -16
 4906              		.cfi_offset 4, -12
 4907              		.cfi_offset 5, -8
 4908              		.cfi_offset 14, -4
 665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4909              		.loc 1 665 0
 4910 0002 2A4C     		ldr	r4, .L916
 670:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x4;                                                       // return error code
 4911              		.loc 1 670 0
 4912 0004 0422     		mov	r2, #4
 665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4913              		.loc 1 665 0
 4914 0006 A379     		ldrb	r3, [r4, #6]
 4915 0008 1907     		lsl	r1, r3, #28
 4916 000a 8B0F     		lsr	r3, r1, #30
 4917 000c 022B     		cmp	r3, #2
 4918 000e 01D0     		beq	.L912
 4919              	.LVL466:
 4920              	.L888:
 708:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // fbe_fei
 4921              		.loc 1 708 0
 4922 0010 101C     		mov	r0, r2
 4923              		@ sp needed for prologue
 4924 0012 38BD     		pop	{r3, r4, r5, pc}
 4925              	.LVL467:
 4926              	.L912:
 666:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4927              		.loc 1 666 0
 4928 0014 A579     		ldrb	r5, [r4, #6]
 665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4929              		.loc 1 665 0
 4930 0016 ED06     		lsl	r5, r5, #27
 4931 0018 FAD4     		bmi	.L888
 667:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selecte
 4932              		.loc 1 667 0
 4933 001a A179     		ldrb	r1, [r4, #6]
 4934 001c 2025     		mov	r5, #32
 666:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external 
 4935              		.loc 1 666 0
 4936 001e 0D42     		tst	r5, r1
 4937 0020 F6D1     		bne	.L888
 668:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is no
 4938              		.loc 1 668 0
 4939 0022 6178     		ldrb	r1, [r4, #1]
 665:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted
 4940              		.loc 1 665 0
 4941 0024 0B42     		tst	r3, r1
 4942 0026 F3D1     		bne	.L888
 674:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4943              		.loc 1 674 0
 4944 0028 214A     		ldr	r2, .L916+4
 4945 002a 224B     		ldr	r3, .L916+8
 4946 002c 8118     		add	r1, r0, r2
 676:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0x31;
 4947              		.loc 1 676 0
 4948 002e 3122     		mov	r2, #49
 674:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
 4949              		.loc 1 674 0
 4950 0030 9942     		cmp	r1, r3
 4951 0032 EDD8     		bhi	.L888
 680:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_out = fll_freq(slow_irc_freq); 
 4952              		.loc 1 680 0
 4953 0034 FFF7FEFF 		bl	fll_freq
 4954              	.LVL468:
 4955 0038 021E     		sub	r2, r0, #0
 4956              	.LVL469:
 681:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling funct
 4957              		.loc 1 681 0
 4958 003a 3B2A     		cmp	r2, #59
 4959 003c E8DD     		ble	.L888
 684:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 4960              		.loc 1 684 0
 4961 003e 6079     		ldrb	r0, [r4, #5]
 4962              	.LVL470:
 688:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 4963              		.loc 1 688 0
 4964 0040 3F23     		mov	r3, #63
 684:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
 4965              		.loc 1 684 0
 4966 0042 A843     		bic	r0, r5
 4967 0044 6071     		strb	r0, [r4, #5]
 687:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = MCG_C1;
 4968              		.loc 1 687 0
 4969 0046 2578     		ldrb	r5, [r4]
 4970              	.LVL471:
 689:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 4971              		.loc 1 689 0
 4972 0048 0421     		mov	r1, #4
 688:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
 4973              		.loc 1 688 0
 4974 004a 2B40     		and	r3, r5
 4975              	.LVL472:
 689:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
 4976              		.loc 1 689 0
 4977 004c 0B43     		orr	r3, r1
 4978              	.LVL473:
 690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 4979              		.loc 1 690 0
 4980 004e FA20     		mov	r0, #250
 4981 0050 2370     		strb	r3, [r4]
 4982              	.LVL474:
 695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4983              		.loc 1 695 0
 4984 0052 1025     		mov	r5, #16
 690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_C1 = temp_reg; // update MCG_C1 
 4985              		.loc 1 690 0
 4986 0054 C300     		lsl	r3, r0, #3
 4987              	.LVL475:
 4988 0056 08E0     		b	.L890
 4989              	.LVL476:
 4990              	.L913:
 695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 4991              		.loc 1 695 0
 4992 0058 A079     		ldrb	r0, [r4, #6]
 4993 005a 013B     		sub	r3, r3, #1
 4994 005c 9BB2     		uxth	r3, r3
 4995 005e 0542     		tst	r5, r0
 4996 0060 06D1     		bne	.L889
 4997 0062 013B     		sub	r3, r3, #1
 4998 0064 9BB2     		uxth	r3, r3
 693:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 4999              		.loc 1 693 0
 5000 0066 002B     		cmp	r3, #0
 5001 0068 02D0     		beq	.L889
 5002              	.L890:
 695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
 5003              		.loc 1 695 0
 5004 006a A179     		ldrb	r1, [r4, #6]
 5005 006c 0D42     		tst	r5, r1
 5006 006e F3D0     		beq	.L913
 5007              	.L889:
 697:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error i
 5008              		.loc 1 697 0
 5009 0070 0E48     		ldr	r0, .L916
 5010 0072 8479     		ldrb	r4, [r0, #6]
 5011 0074 E506     		lsl	r5, r4, #27
 5012 0076 01D4     		bmi	.L914
 5013 0078 1222     		mov	r2, #18
 5014              	.LVL477:
 5015 007a C9E7     		b	.L888
 5016              	.LVL478:
 5017              	.L914:
 5018 007c FA25     		mov	r5, #250
 5019 007e EB00     		lsl	r3, r5, #3
 702:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 5020              		.loc 1 702 0
 5021 0080 0C21     		mov	r1, #12
 5022 0082 08E0     		b	.L892
 5023              	.L915:
 5024 0084 8579     		ldrb	r5, [r0, #6]
 5025 0086 013B     		sub	r3, r3, #1
 5026 0088 9BB2     		uxth	r3, r3
 5027 008a 2942     		tst	r1, r5
 5028 008c 06D0     		beq	.L891
 5029 008e 013B     		sub	r3, r3, #1
 5030 0090 9BB2     		uxth	r3, r3
 700:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 2000 ; i++)
 5031              		.loc 1 700 0
 5032 0092 002B     		cmp	r3, #0
 5033 0094 02D0     		beq	.L891
 5034              	.L892:
 702:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST
 5035              		.loc 1 702 0
 5036 0096 8479     		ldrb	r4, [r0, #6]
 5037 0098 2142     		tst	r1, r4
 5038 009a F3D1     		bne	.L915
 5039              	.L891:
 704:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is re
 5040              		.loc 1 704 0
 5041 009c 0348     		ldr	r0, .L916
 5042 009e 8179     		ldrb	r1, [r0, #6]
 5043 00a0 0C07     		lsl	r4, r1, #28
 5044 00a2 A50F     		lsr	r5, r4, #30
 5045 00a4 B4D0     		beq	.L888
 5046 00a6 1822     		mov	r2, #24
 5047              	.LVL479:
 5048 00a8 B2E7     		b	.L888
 5049              	.L917:
 5050 00aa C046     		.align	2
 5051              	.L916:
 5052 00ac 00400640 		.word	1074151424
 5053 00b0 EE85FFFF 		.word	-31250
 5054 00b4 851E0000 		.word	7813
 5055              		.cfi_endproc
 5056              	.LFE10:
 5058              		.section	.text.what_mcg_mode,"ax",%progbits
 5059              		.align	2
 5060              		.global	what_mcg_mode
 5061              		.code	16
 5062              		.thumb_func
 5064              	what_mcg_mode:
 5065              	.LFB26:
1850:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1851:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1852:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** unsigned char what_mcg_mode(void)
1853:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 5066              		.loc 1 1853 0
 5067              		.cfi_startproc
 5068 0000 00B5     		push	{lr}
 5069              	.LCFI29:
 5070              		.cfi_def_cfa_offset 4
 5071              		.cfi_offset 14, -4
1854:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check if in FEI mode
1855:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 5072              		.loc 1 1855 0
 5073 0002 3E4B     		ldr	r3, .L960
 5074 0004 9A79     		ldrb	r2, [r3, #6]
 5075 0006 1007     		lsl	r0, r2, #28
 5076 0008 810F     		lsr	r1, r0, #30
 5077 000a 02D1     		bne	.L919
1856:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 5078              		.loc 1 1856 0
 5079 000c 9A79     		ldrb	r2, [r3, #6]
1855:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selc
 5080              		.loc 1 1855 0
 5081 000e D006     		lsl	r0, r2, #27
 5082 0010 33D4     		bmi	.L953
 5083              	.L919:
1857:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has sele
1858:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1859:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FEI;                                                          // return FEI code
1860:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1861:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in PEE mode
1862:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 5084              		.loc 1 1862 0
 5085 0012 3A49     		ldr	r1, .L960
 5086 0014 8879     		ldrb	r0, [r1, #6]
 5087 0016 0207     		lsl	r2, r0, #28
 5088 0018 930F     		lsr	r3, r2, #30
 5089 001a 032B     		cmp	r3, #3
 5090 001c 32D0     		beq	.L954
 5091              	.L921:
1863:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1864:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has sele
1865:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1866:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return PEE;                                                          // return PEE code
1867:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1868:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in PBE mode
1869:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5092              		.loc 1 1869 0
 5093 001e 374B     		ldr	r3, .L960
 5094 0020 9A79     		ldrb	r2, [r3, #6]
 5095 0022 1007     		lsl	r0, r2, #28
 5096 0024 820F     		lsr	r2, r0, #30
 5097 0026 022A     		cmp	r2, #2
 5098 0028 34D0     		beq	.L955
 5099              	.L922:
1870:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1871:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
1872:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
1873:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1874:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return PBE;                                                          // return PBE code
1875:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1876:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in FBE mode
1877:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5100              		.loc 1 1877 0
 5101 002a 344B     		ldr	r3, .L960
 5102 002c 9A79     		ldrb	r2, [r3, #6]
 5103 002e 1107     		lsl	r1, r2, #28
 5104 0030 8A0F     		lsr	r2, r1, #30
 5105 0032 022A     		cmp	r2, #2
 5106 0034 39D0     		beq	.L956
 5107              	.L923:
1878:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1879:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
1880:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
1881:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1882:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FBE;                                                          // return FBE code
1883:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1884:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in BLPE mode
1885:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5108              		.loc 1 1885 0
 5109 0036 314B     		ldr	r3, .L960
 5110 0038 9A79     		ldrb	r2, [r3, #6]
 5111 003a 1007     		lsl	r0, r2, #28
 5112 003c 820F     		lsr	r2, r0, #30
 5113 003e 022A     		cmp	r2, #2
 5114 0040 3ED0     		beq	.L957
 5115              	.L924:
1886:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1887:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is
1888:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1889:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return BLPE;                                                         // return BLPE code
1890:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1891:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check if in BLPI mode
1892:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 5116              		.loc 1 1892 0
 5117 0042 2E4B     		ldr	r3, .L960
 5118 0044 9879     		ldrb	r0, [r3, #6]
 5119 0046 0207     		lsl	r2, r0, #28
 5120 0048 910F     		lsr	r1, r2, #30
 5121 004a 0129     		cmp	r1, #1
 5122 004c 40D0     		beq	.L958
 5123              	.L925:
1893:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
1894:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
1895:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
1896:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1897:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return BLPI;                                                         // return BLPI code
1898:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1899:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // check if in FBI mode
1900:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 5124              		.loc 1 1900 0
 5125 004e 2B4B     		ldr	r3, .L960
 5126 0050 9979     		ldrb	r1, [r3, #6]
 5127 0052 0807     		lsl	r0, r1, #28
 5128 0054 820F     		lsr	r2, r0, #30
 5129 0056 012A     		cmp	r2, #1
 5130 0058 45D0     		beq	.L959
 5131              	.L926:
1901:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
1902:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
1903:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
1904:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {  
1905:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FBI;                                                          // return FBI code 
1906:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1907:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check MCG is in FEE mode
1908:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 5132              		.loc 1 1908 0
 5133 005a 284B     		ldr	r3, .L960
1909:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
1910:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has sele
1911:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1912:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FEE;                                                          // return FEE code
1913:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1914:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1915:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1916:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0;                                                            // error condition
 5134              		.loc 1 1916 0
 5135 005c 0020     		mov	r0, #0
1908:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 5136              		.loc 1 1908 0
 5137 005e 9A79     		ldrb	r2, [r3, #6]
 5138 0060 1107     		lsl	r1, r2, #28
 5139 0062 8A0F     		lsr	r2, r1, #30
 5140 0064 08D1     		bne	.L920
1909:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5141              		.loc 1 1909 0
 5142 0066 9979     		ldrb	r1, [r3, #6]
1908:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selc
 5143              		.loc 1 1908 0
 5144 0068 C906     		lsl	r1, r1, #27
 5145 006a 05D4     		bmi	.L920
1910:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has sele
 5146              		.loc 1 1910 0
 5147 006c 9B79     		ldrb	r3, [r3, #6]
1909:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5148              		.loc 1 1909 0
 5149 006e 2020     		mov	r0, #32
 5150 0070 1840     		and	r0, r3
1912:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FEE;                                                          // return FEE code
 5151              		.loc 1 1912 0
 5152 0072 4342     		neg	r3, r0
 5153 0074 5841     		adc	r0, r0, r3
 5154 0076 8000     		lsl	r0, r0, #2
 5155              	.L920:
1917:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1918:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // what_mcg_mode
 5156              		.loc 1 1918 0
 5157              		@ sp needed for prologue
 5158 0078 00BD     		pop	{pc}
 5159              	.L953:
1857:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has sele
 5160              		.loc 1 1857 0
 5161 007a 9B79     		ldrb	r3, [r3, #6]
1859:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FEI;                                                          // return FEI code
 5162              		.loc 1 1859 0
 5163 007c 0320     		mov	r0, #3
1856:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is intern
 5164              		.loc 1 1856 0
 5165 007e 9906     		lsl	r1, r3, #26
 5166 0080 FAD5     		bpl	.L920
 5167 0082 C6E7     		b	.L919
 5168              	.L954:
1863:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5169              		.loc 1 1863 0
 5170 0084 8879     		ldrb	r0, [r1, #6]
1862:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selc
 5171              		.loc 1 1862 0
 5172 0086 C006     		lsl	r0, r0, #27
 5173 0088 C9D4     		bmi	.L921
1864:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has sele
 5174              		.loc 1 1864 0
 5175 008a 8979     		ldrb	r1, [r1, #6]
1866:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return PEE;                                                          // return PEE code
 5176              		.loc 1 1866 0
 5177 008c 0820     		mov	r0, #8
1863:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5178              		.loc 1 1863 0
 5179 008e 8906     		lsl	r1, r1, #26
 5180 0090 F2D4     		bmi	.L920
 5181 0092 C4E7     		b	.L921
 5182              	.L955:
1870:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5183              		.loc 1 1870 0
 5184 0094 9979     		ldrb	r1, [r3, #6]
1869:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5185              		.loc 1 1869 0
 5186 0096 C806     		lsl	r0, r1, #27
 5187 0098 C7D4     		bmi	.L922
1871:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 5188              		.loc 1 1871 0
 5189 009a 9879     		ldrb	r0, [r3, #6]
1870:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5190              		.loc 1 1870 0
 5191 009c 8006     		lsl	r0, r0, #26
 5192 009e C4D5     		bpl	.L922
1872:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 5193              		.loc 1 1872 0
 5194 00a0 5B78     		ldrb	r3, [r3, #1]
1874:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return PBE;                                                          // return PBE code
 5195              		.loc 1 1874 0
 5196 00a2 0720     		mov	r0, #7
1871:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has sele
 5197              		.loc 1 1871 0
 5198 00a4 1A42     		tst	r2, r3
 5199 00a6 E7D0     		beq	.L920
 5200 00a8 BFE7     		b	.L922
 5201              	.L956:
1878:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5202              		.loc 1 1878 0
 5203 00aa 9879     		ldrb	r0, [r3, #6]
1877:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5204              		.loc 1 1877 0
 5205 00ac C006     		lsl	r0, r0, #27
 5206 00ae C2D4     		bmi	.L923
1879:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5207              		.loc 1 1879 0
 5208 00b0 9979     		ldrb	r1, [r3, #6]
1878:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5209              		.loc 1 1878 0
 5210 00b2 8806     		lsl	r0, r1, #26
 5211 00b4 BFD4     		bmi	.L923
1880:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is
 5212              		.loc 1 1880 0
 5213 00b6 5B78     		ldrb	r3, [r3, #1]
1882:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FBE;                                                          // return FBE code
 5214              		.loc 1 1882 0
 5215 00b8 0520     		mov	r0, #5
1879:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5216              		.loc 1 1879 0
 5217 00ba 1A42     		tst	r2, r3
 5218 00bc DCD0     		beq	.L920
 5219 00be BAE7     		b	.L923
 5220              	.L957:
1886:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5221              		.loc 1 1886 0
 5222 00c0 9979     		ldrb	r1, [r3, #6]
1885:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selc
 5223              		.loc 1 1885 0
 5224 00c2 C806     		lsl	r0, r1, #27
 5225 00c4 BDD4     		bmi	.L924
1887:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is
 5226              		.loc 1 1887 0
 5227 00c6 5B78     		ldrb	r3, [r3, #1]
1889:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return BLPE;                                                         // return BLPE code
 5228              		.loc 1 1889 0
 5229 00c8 0620     		mov	r0, #6
1886:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is extern
 5230              		.loc 1 1886 0
 5231 00ca 1A42     		tst	r2, r3
 5232 00cc D4D1     		bne	.L920
 5233 00ce B8E7     		b	.L924
 5234              	.L958:
1893:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5235              		.loc 1 1893 0
 5236 00d0 9879     		ldrb	r0, [r3, #6]
1892:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 5237              		.loc 1 1892 0
 5238 00d2 C106     		lsl	r1, r0, #27
 5239 00d4 BBD5     		bpl	.L925
1894:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5240              		.loc 1 1894 0
 5241 00d6 9A79     		ldrb	r2, [r3, #6]
1893:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5242              		.loc 1 1893 0
 5243 00d8 9006     		lsl	r0, r2, #26
 5244 00da B8D4     		bmi	.L925
1895:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
 5245              		.loc 1 1895 0
 5246 00dc 5B78     		ldrb	r3, [r3, #1]
1897:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return BLPI;                                                         // return BLPI code
 5247              		.loc 1 1897 0
 5248 00de 0120     		mov	r0, #1
1894:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5249              		.loc 1 1894 0
 5250 00e0 9907     		lsl	r1, r3, #30
 5251 00e2 B4D5     		bpl	.L925
 5252 00e4 C8E7     		b	.L920
 5253              	.L959:
1901:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5254              		.loc 1 1901 0
 5255 00e6 9979     		ldrb	r1, [r3, #6]
1900:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selc
 5256              		.loc 1 1900 0
 5257 00e8 C806     		lsl	r0, r1, #27
 5258 00ea B6D5     		bpl	.L926
1902:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5259              		.loc 1 1902 0
 5260 00ec 9879     		ldrb	r0, [r3, #6]
1901:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is intern
 5261              		.loc 1 1901 0
 5262 00ee 8106     		lsl	r1, r0, #26
 5263 00f0 B3D4     		bmi	.L926
1903:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
 5264              		.loc 1 1903 0
 5265 00f2 5B78     		ldrb	r3, [r3, #1]
1905:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return FBI;                                                          // return FBI code 
 5266              		.loc 1 1905 0
 5267 00f4 0220     		mov	r0, #2
1902:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has sele
 5268              		.loc 1 1902 0
 5269 00f6 9A07     		lsl	r2, r3, #30
 5270 00f8 BED5     		bpl	.L920
 5271 00fa AEE7     		b	.L926
 5272              	.L961:
 5273              		.align	2
 5274              	.L960:
 5275 00fc 00400640 		.word	1074151424
 5276              		.cfi_endproc
 5277              	.LFE26:
 5279              		.global	__aeabi_uidiv
 5280              		.global	__aeabi_i2f
 5281              		.global	__aeabi_fdiv
 5282              		.global	__aeabi_fmul
 5283              		.global	__aeabi_f2uiz
 5284              		.section	.text.atc,"ax",%progbits
 5285              		.align	2
 5286              		.global	atc
 5287              		.code	16
 5288              		.thumb_func
 5290              	atc:
 5291              	.LFB24:
1676:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 5292              		.loc 1 1676 0
 5293              		.cfi_startproc
 5294              	.LVL480:
 5295 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 5296              	.LCFI30:
 5297              		.cfi_def_cfa_offset 20
 5298              		.cfi_offset 4, -20
 5299              		.cfi_offset 5, -16
 5300              		.cfi_offset 6, -12
 5301              		.cfi_offset 7, -8
 5302              		.cfi_offset 14, -4
 5303 0002 5746     		mov	r7, sl
 5304 0004 4E46     		mov	r6, r9
 5305 0006 4546     		mov	r5, r8
 5306 0008 E0B4     		push	{r5, r6, r7}
 5307              	.LCFI31:
 5308              		.cfi_def_cfa_offset 32
 5309              		.cfi_offset 8, -32
 5310              		.cfi_offset 9, -28
 5311              		.cfi_offset 10, -24
1676:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 5312              		.loc 1 1676 0
 5313 000a 8046     		mov	r8, r0
 5314              	.LVL481:
 5315 000c 161C     		mov	r6, r2
 5316 000e 0F1C     		mov	r7, r1
1689:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
 5317              		.loc 1 1689 0
 5318 0010 FFF7FEFF 		bl	what_mcg_mode
 5319              	.LVL482:
1690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5320              		.loc 1 1690 0
 5321 0014 C21F     		sub	r2, r0, #7
1689:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   mcg_mode = what_mcg_mode(); // get present MCG mode
 5322              		.loc 1 1689 0
 5323 0016 031C     		mov	r3, r0
 5324              	.LVL483:
1690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5325              		.loc 1 1690 0
 5326 0018 D0B2     		uxtb	r0, r2
 5327              	.LVL484:
 5328 001a 0128     		cmp	r0, #1
 5329 001c 07D9     		bls	.L963
1692:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 1; // return error code if not in PEE, PBE or FBE modes
 5330              		.loc 1 1692 0
 5331 001e 0120     		mov	r0, #1
1690:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
 5332              		.loc 1 1690 0
 5333 0020 052B     		cmp	r3, #5
 5334 0022 04D0     		beq	.L963
 5335              	.LVL485:
 5336              	.L964:
1781:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** }// atc
 5337              		.loc 1 1781 0
 5338              		@ sp needed for prologue
 5339              	.LVL486:
 5340 0024 1CBC     		pop	{r2, r3, r4}
 5341 0026 9046     		mov	r8, r2
 5342 0028 9946     		mov	r9, r3
 5343 002a A246     		mov	sl, r4
 5344 002c F0BD     		pop	{r4, r5, r6, r7, pc}
 5345              	.LVL487:
 5346              	.L963:
1695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 5347              		.loc 1 1695 0
 5348 002e 534D     		ldr	r5, .L986
 5349 0030 534C     		ldr	r4, .L986+4
1697:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 5350              		.loc 1 1697 0
 5351 0032 301C     		mov	r0, r6
1695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 5352              		.loc 1 1695 0
 5353 0034 2959     		ldr	r1, [r5, r4]
1698:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = SIM_CLKDIV1;
 5354              		.loc 1 1698 0
 5355 0036 2B59     		ldr	r3, [r5, r4]
 5356              	.LVL488:
1695:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   orig_div = SIM_CLKDIV1; //store present clock divider values
 5357              		.loc 1 1695 0
 5358 0038 8A46     		mov	sl, r1
 5359              	.LVL489:
1697:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 5360              		.loc 1 1697 0
 5361 003a 5249     		ldr	r1, .L986+8
 5362              	.LVL490:
1698:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = SIM_CLKDIV1;
 5363              		.loc 1 1698 0
 5364 003c 9946     		mov	r9, r3
 5365              	.LVL491:
1697:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest all
 5366              		.loc 1 1697 0
 5367 003e FFF7FEFF 		bl	__aeabi_idiv
 5368              	.LVL492:
1699:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
 5369              		.loc 1 1699 0
 5370 0042 514B     		ldr	r3, .L986+12
1701:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 5371              		.loc 1 1701 0
 5372 0044 0204     		lsl	r2, r0, #16
 5373 0046 E020     		mov	r0, #224
 5374 0048 C102     		lsl	r1, r0, #11
1699:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
 5375              		.loc 1 1699 0
 5376 004a 4846     		mov	r0, r9
 5377 004c 0340     		and	r3, r0
 5378              	.LVL493:
1701:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
 5379              		.loc 1 1701 0
 5380 004e 0A40     		and	r2, r1
 5381 0050 1A43     		orr	r2, r3
 5382              	.LVL494:
1702:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   SIM_CLKDIV1 = temp_reg; // set actual dividers
 5383              		.loc 1 1702 0
 5384 0052 2A51     		str	r2, [r5, r4]
1704:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same
 5385              		.loc 1 1704 0
 5386 0054 2A59     		ldr	r2, [r5, r4]
 5387              	.LVL495:
 5388 0056 301C     		mov	r0, r6
 5389 0058 110C     		lsr	r1, r2, #16
 5390 005a 0131     		add	r1, r1, #1
 5391 005c FFF7FEFF 		bl	__aeabi_uidiv
 5392              	.LVL496:
1705:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
 5393              		.loc 1 1705 0
 5394 0060 4A4E     		ldr	r6, .L986+16
 5395              	.LVL497:
 5396 0062 4B4B     		ldr	r3, .L986+20
 5397 0064 8119     		add	r1, r0, r6
 5398 0066 9942     		cmp	r1, r3
 5399 0068 03D9     		bls	.L965
1707:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5400              		.loc 1 1707 0
 5401 006a 5346     		mov	r3, sl
 5402 006c 2B51     		str	r3, [r5, r4]
1708:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 3; // error, bus clock frequency is not within 8MHz to 16MHz
 5403              		.loc 1 1708 0
 5404 006e 0320     		mov	r0, #3
 5405              	.LVL498:
 5406 0070 D8E7     		b	.L964
 5407              	.LVL499:
 5408              	.L965:
1684:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (irc_select > 0) // force irc to 1 if greater than 0
 5409              		.loc 1 1684 0
 5410 0072 4646     		mov	r6, r8
 5411 0074 731E     		sub	r3, r6, #1
 5412 0076 9E41     		sbc	r6, r6, r3
1711:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if(!irc_select) //determine if slow or fast IRC to be trimmed
 5413              		.loc 1 1711 0
 5414 0078 002E     		cmp	r6, #0
 5415 007a 06D1     		bne	.L966
1713:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq < 31250) // check frequency is above min spec.
 5416              		.loc 1 1713 0
 5417 007c 454A     		ldr	r2, .L986+24
 5418 007e 9742     		cmp	r7, r2
 5419 0080 0ADC     		bgt	.L967
1715:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5420              		.loc 1 1715 0
 5421 0082 5046     		mov	r0, sl
 5422              	.LVL500:
 5423 0084 2851     		str	r0, [r5, r4]
1716:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 4;
 5424              		.loc 1 1716 0
 5425 0086 0420     		mov	r0, #4
 5426 0088 CCE7     		b	.L964
 5427              	.LVL501:
 5428              	.L966:
1726:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq < 3000000) // check frequency is above min spec.
 5429              		.loc 1 1726 0
 5430 008a 434A     		ldr	r2, .L986+28
 5431 008c 9742     		cmp	r7, r2
 5432 008e 0ADC     		bgt	.L969
1728:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5433              		.loc 1 1728 0
 5434 0090 5346     		mov	r3, sl
 5435 0092 2B51     		str	r3, [r5, r4]
1729:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 6;
 5436              		.loc 1 1729 0
 5437 0094 0620     		mov	r0, #6
 5438              	.LVL502:
 5439 0096 C5E7     		b	.L964
 5440              	.LVL503:
 5441              	.L967:
1718:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq > 39062) // check frequency is below max spec.
 5442              		.loc 1 1718 0
 5443 0098 4049     		ldr	r1, .L986+32
 5444 009a 8F42     		cmp	r7, r1
 5445 009c 0ADD     		ble	.L968
1720:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5446              		.loc 1 1720 0
 5447 009e 5746     		mov	r7, sl
 5448              	.LVL504:
 5449 00a0 2F51     		str	r7, [r5, r4]
1721:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 5;
 5450              		.loc 1 1721 0
 5451 00a2 0520     		mov	r0, #5
 5452              	.LVL505:
 5453 00a4 BEE7     		b	.L964
 5454              	.LVL506:
 5455              	.L969:
1731:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (irc_freq > 5000000) // check frequency is below max spec.
 5456              		.loc 1 1731 0
 5457 00a6 3E49     		ldr	r1, .L986+36
 5458 00a8 8F42     		cmp	r7, r1
 5459 00aa 30DD     		ble	.L970
1733:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5460              		.loc 1 1733 0
 5461 00ac 5046     		mov	r0, sl
 5462              	.LVL507:
 5463 00ae 2851     		str	r0, [r5, r4]
1734:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       return 7;
 5464              		.loc 1 1734 0
 5465 00b0 0720     		mov	r0, #7
 5466 00b2 B7E7     		b	.L964
 5467              	.LVL508:
 5468              	.L968:
1742:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
 5469              		.loc 1 1742 0
 5470 00b4 FFF7FEFF 		bl	__aeabi_i2f
 5471              	.LVL509:
 5472 00b8 041C     		add	r4, r0, #0
 5473 00ba 381C     		mov	r0, r7
 5474 00bc FFF7FEFF 		bl	__aeabi_i2f
 5475              	.LVL510:
 5476 00c0 011C     		add	r1, r0, #0
 5477 00c2 201C     		add	r0, r4, #0
 5478 00c4 FFF7FEFF 		bl	__aeabi_fdiv
 5479              	.LVL511:
 5480 00c8 3649     		ldr	r1, .L986+40
 5481 00ca FFF7FEFF 		bl	__aeabi_fmul
 5482              	.LVL512:
 5483 00ce FFF7FEFF 		bl	__aeabi_f2uiz
 5484              	.LVL513:
 5485 00d2 85B2     		uxth	r5, r0
 5486              	.LVL514:
 5487              	.L971:
1744:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
 5488              		.loc 1 1744 0
 5489 00d4 3449     		ldr	r1, .L986+44
 5490 00d6 EFB2     		uxtb	r7, r5
1745:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 5491              		.loc 1 1745 0
 5492 00d8 280A     		lsr	r0, r5, #8
1744:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
 5493              		.loc 1 1744 0
 5494 00da CF72     		strb	r7, [r1, #11]
1745:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
 5495              		.loc 1 1745 0
 5496 00dc 8872     		strb	r0, [r1, #10]
1748:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
 5497              		.loc 1 1748 0
 5498 00de 0B7A     		ldrb	r3, [r1, #8]
 5499 00e0 1F22     		mov	r2, #31
 5500 00e2 1340     		and	r3, r2
 5501 00e4 0B72     		strb	r3, [r1, #8]
1750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_SC |= temp_reg;
 5502              		.loc 1 1750 0
 5503 00e6 0C7A     		ldrb	r4, [r1, #8]
1749:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enabl
 5504              		.loc 1 1749 0
 5505 00e8 B501     		lsl	r5, r6, #6
 5506              	.LVL515:
 5507 00ea 8027     		mov	r7, #128
 5508 00ec 2F43     		orr	r7, r5
1750:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   MCG_SC |= temp_reg;
 5509              		.loc 1 1750 0
 5510 00ee 2743     		orr	r7, r4
 5511 00f0 0F72     		strb	r7, [r1, #8]
 5512              	.L972:
1752:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
 5513              		.loc 1 1752 0
 5514 00f2 0B7A     		ldrb	r3, [r1, #8]
 5515 00f4 2C48     		ldr	r0, .L986+44
 5516 00f6 5AB2     		sxtb	r2, r3
 5517 00f8 002A     		cmp	r2, #0
 5518 00fa FADB     		blt	.L972
1754:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
 5519              		.loc 1 1754 0
 5520 00fc 017A     		ldrb	r1, [r0, #8]
 5521 00fe 8906     		lsl	r1, r1, #26
 5522 0100 1AD5     		bpl	.L973
1756:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5523              		.loc 1 1756 0
 5524 0102 1F4E     		ldr	r6, .L986+4
 5525 0104 1D4A     		ldr	r2, .L986
 5526 0106 5146     		mov	r1, sl
 5527 0108 9151     		str	r1, [r2, r6]
1757:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 8;
 5528              		.loc 1 1757 0
 5529 010a 0820     		mov	r0, #8
 5530 010c 8AE7     		b	.L964
 5531              	.LVL516:
 5532              	.L970:
1740:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
 5533              		.loc 1 1740 0
 5534 010e FFF7FEFF 		bl	__aeabi_i2f
 5535              	.LVL517:
 5536 0112 051C     		add	r5, r0, #0
 5537 0114 381C     		mov	r0, r7
 5538 0116 FFF7FEFF 		bl	__aeabi_i2f
 5539              	.LVL518:
 5540 011a 011C     		add	r1, r0, #0
 5541 011c 281C     		add	r0, r5, #0
 5542 011e FFF7FEFF 		bl	__aeabi_fdiv
 5543              	.LVL519:
 5544 0122 8627     		mov	r7, #134
 5545              	.LVL520:
 5546 0124 1F49     		ldr	r1, .L986+40
 5547 0126 FFF7FEFF 		bl	__aeabi_fmul
 5548              	.LVL521:
 5549 012a F905     		lsl	r1, r7, #23
 5550 012c FFF7FEFF 		bl	__aeabi_fmul
 5551              	.LVL522:
 5552 0130 FFF7FEFF 		bl	__aeabi_f2uiz
 5553              	.LVL523:
 5554 0134 85B2     		uxth	r5, r0
 5555              	.LVL524:
 5556 0136 CDE7     		b	.L971
 5557              	.LVL525:
 5558              	.L973:
1761:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     if (!irc_select)
 5559              		.loc 1 1761 0
 5560 0138 002E     		cmp	r6, #0
 5561 013a 0BD1     		bne	.L974
1763:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 5562              		.loc 1 1763 0
 5563 013c 8278     		ldrb	r2, [r0, #2]
 5564 013e FF2A     		cmp	r2, #255
 5565 0140 02D0     		beq	.L975
1763:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
 5566              		.loc 1 1763 0 is_stmt 0
 5567 0142 8178     		ldrb	r1, [r0, #2]
 5568 0144 0029     		cmp	r1, #0
 5569 0146 13D1     		bne	.L976
 5570              	.L975:
1765:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5571              		.loc 1 1765 0 is_stmt 1
 5572 0148 0C48     		ldr	r0, .L986
 5573 014a 0D4F     		ldr	r7, .L986+4
 5574 014c 5346     		mov	r3, sl
 5575 014e C351     		str	r3, [r0, r7]
1766:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         return 9;
 5576              		.loc 1 1766 0
 5577 0150 0920     		mov	r0, #9
 5578 0152 67E7     		b	.L964
 5579              	.L974:
1771:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 5580              		.loc 1 1771 0
 5581 0154 C678     		ldrb	r6, [r0, #3]
 5582 0156 1E24     		mov	r4, #30
 5583 0158 2640     		and	r6, r4
 5584 015a 1E2E     		cmp	r6, #30
 5585 015c 02D0     		beq	.L977
1772:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****           (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
 5586              		.loc 1 1772 0
 5587 015e C578     		ldrb	r5, [r0, #3]
1771:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****       if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
 5588              		.loc 1 1771 0
 5589 0160 2C42     		tst	r4, r5
 5590 0162 05D1     		bne	.L976
 5591              	.L977:
1774:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5592              		.loc 1 1774 0
 5593 0164 0548     		ldr	r0, .L986
 5594 0166 064F     		ldr	r7, .L986+4
 5595 0168 5346     		mov	r3, sl
 5596 016a C351     		str	r3, [r0, r7]
1775:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****         return 10;
 5597              		.loc 1 1775 0
 5598 016c 0A20     		mov	r0, #10
 5599 016e 59E7     		b	.L964
 5600              	.L976:
1779:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
 5601              		.loc 1 1779 0
 5602 0170 034E     		ldr	r6, .L986+4
 5603 0172 024C     		ldr	r4, .L986
 5604 0174 5546     		mov	r5, sl
 5605 0176 A551     		str	r5, [r4, r6]
1780:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   return 0;
 5606              		.loc 1 1780 0
 5607 0178 0020     		mov	r0, #0
 5608 017a 53E7     		b	.L964
 5609              	.L987:
 5610              		.align	2
 5611              	.L986:
 5612 017c 00700440 		.word	1074032640
 5613 0180 44100000 		.word	4164
 5614 0184 0024F400 		.word	16000000
 5615 0188 FFFFF8FF 		.word	-458753
 5616 018c 00EE85FF 		.word	-8000000
 5617 0190 00127A00 		.word	8000000
 5618 0194 117A0000 		.word	31249
 5619 0198 BFC62D00 		.word	2999999
 5620 019c 96980000 		.word	39062
 5621 01a0 404B4C00 		.word	5000000
 5622 01a4 0000A841 		.word	1101529088
 5623 01a8 00400640 		.word	1074151424
 5624              		.cfi_endproc
 5625              	.LFE24:
 5627              		.section	.text.clk_monitor_0,"ax",%progbits
 5628              		.align	2
 5629              		.global	clk_monitor_0
 5630              		.code	16
 5631              		.thumb_func
 5633              	clk_monitor_0:
 5634              	.LFB27:
1919:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1920:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1921:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
1922:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : clk_monitor_0
1923:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1924:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function simply enables or disables the OSC 0 clock monitor. This is
1925:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
1926:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
1927:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * It MUST be disabled in all other modes or a reset may be generated. It must
1928:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * also be disabled if it is desired to enter VLPR from BLPE mode.
1929:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1930:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
1931:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1932:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * Return value : none
1933:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
1934:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** void clk_monitor_0(unsigned char en_dis)
1935:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {         
 5635              		.loc 1 1935 0
 5636              		.cfi_startproc
 5637              	.LVL526:
 5638 0000 00B5     		push	{lr}
 5639              	.LCFI32:
 5640              		.cfi_def_cfa_offset 4
 5641              		.cfi_offset 14, -4
1936:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (en_dis)
1937:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1938:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;   
 5642              		.loc 1 1938 0
 5643 0002 064B     		ldr	r3, .L992
1936:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (en_dis)
 5644              		.loc 1 1936 0
 5645 0004 0028     		cmp	r0, #0
 5646 0006 04D1     		bne	.L991
1939:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1940:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
1941:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1942:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C6 &= ~MCG_C6_CME0_MASK;
 5647              		.loc 1 1942 0
 5648 0008 5A79     		ldrb	r2, [r3, #5]
 5649 000a 2021     		mov	r1, #32
 5650 000c 8A43     		bic	r2, r1
 5651 000e 5A71     		strb	r2, [r3, #5]
 5652              	.LVL527:
 5653              	.L988:
1943:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1944:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** }    // end clk_monitor_0
 5654              		.loc 1 1944 0
 5655              		@ sp needed for prologue
 5656 0010 00BD     		pop	{pc}
 5657              	.LVL528:
 5658              	.L991:
1938:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     MCG_C6 |= MCG_C6_CME0_MASK;   
 5659              		.loc 1 1938 0
 5660 0012 5879     		ldrb	r0, [r3, #5]
 5661              	.LVL529:
 5662 0014 2022     		mov	r2, #32
 5663 0016 0243     		orr	r2, r0
 5664 0018 5A71     		strb	r2, [r3, #5]
 5665 001a F9E7     		b	.L988
 5666              	.L993:
 5667              		.align	2
 5668              	.L992:
 5669 001c 00400640 		.word	1074151424
 5670              		.cfi_endproc
 5671              	.LFE27:
 5673              		.section	.text.chk_for_resistor,"ax",%progbits
 5674              		.align	2
 5675              		.global	chk_for_resistor
 5676              		.code	16
 5677              		.thumb_func
 5679              	chk_for_resistor:
 5680              	.LFB28:
1945:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1946:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
1947:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /********************************************************************/
1948:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** /* Functon name : chk_for_resistor
1949:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1950:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This function is specifically for the Freescale Tower and Freedom boards.
1951:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * It performs a simple check to determine if there is an 1M ohm external 
1952:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * feedback resistor connected between extal and xtal. It returns a 1 if the
1953:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * resistor is detected or a 0 if the resistor is not detected. This can be used
1954:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * by the calling routine to compare the test result with the value for HGO that
1955:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * is being used to configure the oscillator. This helps ensure the correct
1956:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * configuration is used.
1957:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1958:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * This check is used just to test for the presence of a 1M resistor, it MUST
1959:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * NOT be used in user code to automatically configure the oscillator HGO value.
1960:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  *
1961:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * It simply configures the crystal pins as GPIO outputs, sets them both low,
1962:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * configures one as high and then configures the other as an input (no pull
1963:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * up). If the resistor is present then the input will be pulled high. This
1964:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * process is repeated for the pin functions reversed. Both conditions have 
1965:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * to result in the input being pulled high for the resistor to be identifiedas
1966:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  * being present.
1967:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****  */
1968:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** unsigned char chk_for_resistor(void)
1969:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 5681              		.loc 1 1969 0
 5682              		.cfi_startproc
 5683              	.LVL530:
1970:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char extal_high = 0;
1971:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   unsigned char xtal_high = 0;
1972:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   short i;
1973:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   
1974:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure EXTAL (PTA18) and XTAL PTA(19) as GPIO driving Low, no pull enabled
1975:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 output data
 5684              		.loc 1 1975 0
 5685 0000 1A4B     		ldr	r3, .L1003
 5686 0002 C022     		mov	r2, #192
 5687 0004 1203     		lsl	r2, r2, #12
1969:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** {
 5688              		.loc 1 1969 0
 5689 0006 F0B5     		push	{r4, r5, r6, r7, lr}
 5690              	.LCFI33:
 5691              		.cfi_def_cfa_offset 20
 5692              		.cfi_offset 4, -20
 5693              		.cfi_offset 5, -16
 5694              		.cfi_offset 6, -12
 5695              		.cfi_offset 7, -8
 5696              		.cfi_offset 14, -4
 5697              		.loc 1 1975 0
 5698 0008 9A60     		str	r2, [r3, #8]
1976:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 5699              		.loc 1 1976 0
 5700 000a 5969     		ldr	r1, [r3, #20]
1977:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   PORTA_GPCHR = (0xC0000 | PORT_PCR_MUX(1)); // configure the pin muxes for GPIO
 5701              		.loc 1 1977 0
 5702 000c 184C     		ldr	r4, .L1003+4
1976:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 5703              		.loc 1 1976 0
 5704 000e 1143     		orr	r1, r2
 5705              		.loc 1 1977 0
 5706 0010 1848     		ldr	r0, .L1003+8
1976:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 5707              		.loc 1 1976 0
 5708 0012 5961     		str	r1, [r3, #20]
1978:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Drive EXTAL high
1979:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PSOR = 0x40000; // set PTA18 data out high
 5709              		.loc 1 1979 0
 5710 0014 8025     		mov	r5, #128
1977:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   PORTA_GPCHR = (0xC0000 | PORT_PCR_MUX(1)); // configure the pin muxes for GPIO
 5711              		.loc 1 1977 0
 5712 0016 8421     		mov	r1, #132
 5713 0018 4450     		str	r4, [r0, r1]
 5714              		.loc 1 1979 0
 5715 001a EC02     		lsl	r4, r5, #11
 5716 001c 5C60     		str	r4, [r3, #4]
1980:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure XTAL as an Input, no pull up 
1981:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR &= ~(0x80000); // clear PTA19 data direction to make it an input 
 5717              		.loc 1 1981 0
 5718 001e 5E69     		ldr	r6, [r3, #20]
 5719 0020 154F     		ldr	r7, .L1003+12
 5720 0022 3740     		and	r7, r6
 5721 0024 5F61     		str	r7, [r3, #20]
 5722              	.LVL531:
1982:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for ~2 time constants
1983:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 300 ; i++) {} 
1984:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check if XTAL was pulled high
1985:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (FGPIOA_PDIR & 0x80000)
 5723              		.loc 1 1985 0
 5724 0026 1D69     		ldr	r5, [r3, #16]
1986:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
1987:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     xtal_high = 1;
1988:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
1989:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure EXTAL and XTAL as GPIO driving low
1990:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 data output
 5725              		.loc 1 1990 0
 5726 0028 9A60     		str	r2, [r3, #8]
1991:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 5727              		.loc 1 1991 0
 5728 002a 5E69     		ldr	r6, [r3, #20]
1992:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Drive XTAL high
1993:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PSOR = 0x80000; // set PTA19 data out high
 5729              		.loc 1 1993 0
 5730 002c 8027     		mov	r7, #128
1991:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 5731              		.loc 1 1991 0
 5732 002e 1643     		orr	r6, r2
1985:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (FGPIOA_PDIR & 0x80000)
 5733              		.loc 1 1985 0
 5734 0030 AC46     		mov	ip, r5
 5735              	.LVL532:
 5736              		.loc 1 1993 0
 5737 0032 3D03     		lsl	r5, r7, #12
 5738              	.LVL533:
1991:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
 5739              		.loc 1 1991 0
 5740 0034 5E61     		str	r6, [r3, #20]
 5741              		.loc 1 1993 0
 5742 0036 5D60     		str	r5, [r3, #4]
1994:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Configure EXTAL as Input, no pull up
1995:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR &= ~(0x40000); // clear PTA18 data direction to make it an input
 5743              		.loc 1 1995 0
 5744 0038 5F69     		ldr	r7, [r3, #20]
 5745 003a 104E     		ldr	r6, .L1003+16
 5746 003c 3E40     		and	r6, r7
 5747 003e 5E61     		str	r6, [r3, #20]
1996:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Wait for ~2 time constants
1997:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   for (i = 0 ; i < 300 ; i++) {} 
1998:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Check if EXTAL was pulled high
1999:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (FGPIOA_PDIR & 0x40000)
 5748              		.loc 1 1999 0
 5749 0040 1F69     		ldr	r7, [r3, #16]
 5750 0042 2742     		tst	r7, r4
 5751 0044 0BD0     		beq	.L1002
 5752              	.LVL534:
2000:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
2001:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     extal_high = 1;
2002:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
2003:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
2004:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // Now configure both pins back to their default state
2005:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   PORTA_GPCHR = 0x000C0000; // clear pta18 and 19 mux values to default
 5753              		.loc 1 2005 0
 5754 0046 4250     		str	r2, [r0, r1]
2006:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR &= ~(0xC0000);    // set PTA18 and 19 as inputs
 5755              		.loc 1 2006 0
 5756 0048 5C69     		ldr	r4, [r3, #20]
 5757 004a 0D4E     		ldr	r6, .L1003+20
2007:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PCOR = 0xC0000;        // clear PTA18 and 19 output data
2008:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** 
2009:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   // If both rising and falling are true return 1, else return 0
2010:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (extal_high && xtal_high)
2011:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
2012:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 1;
 5758              		.loc 1 2012 0
 5759 004c 0120     		mov	r0, #1
2006:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR &= ~(0xC0000);    // set PTA18 and 19 as inputs
 5760              		.loc 1 2006 0
 5761 004e 2640     		and	r6, r4
 5762 0050 5E61     		str	r6, [r3, #20]
2007:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PCOR = 0xC0000;        // clear PTA18 and 19 output data
 5763              		.loc 1 2007 0
 5764 0052 9A60     		str	r2, [r3, #8]
2010:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   if (extal_high && xtal_high)
 5765              		.loc 1 2010 0
 5766 0054 6346     		mov	r3, ip
 5767 0056 2B42     		tst	r3, r5
 5768 0058 00D1     		bne	.L1000
 5769              	.LVL535:
 5770              	.L998:
2013:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }
2014:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   else
2015:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   {
2016:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****     return 0;
 5771              		.loc 1 2016 0
 5772 005a 0020     		mov	r0, #0
 5773              	.L1000:
2017:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   }       
2018:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c **** } // chk_for_resistor
 5774              		.loc 1 2018 0
 5775              		@ sp needed for prologue
 5776 005c F0BD     		pop	{r4, r5, r6, r7, pc}
 5777              	.LVL536:
 5778              	.L1002:
2005:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   PORTA_GPCHR = 0x000C0000; // clear pta18 and 19 mux values to default
 5779              		.loc 1 2005 0
 5780 005e 4250     		str	r2, [r0, r1]
2006:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PDDR &= ~(0xC0000);    // set PTA18 and 19 as inputs
 5781              		.loc 1 2006 0
 5782 0060 5869     		ldr	r0, [r3, #20]
 5783 0062 0749     		ldr	r1, .L1003+20
 5784 0064 0140     		and	r1, r0
 5785 0066 5961     		str	r1, [r3, #20]
2007:D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-sc-baremetal/src/drivers/mcg\mcg.c ****   FGPIOA_PCOR = 0xC0000;        // clear PTA18 and 19 output data
 5786              		.loc 1 2007 0
 5787 0068 9A60     		str	r2, [r3, #8]
 5788 006a F6E7     		b	.L998
 5789              	.L1004:
 5790              		.align	2
 5791              	.L1003:
 5792 006c 00F00FF8 		.word	-133173248
 5793 0070 00010C00 		.word	786688
 5794 0074 00900440 		.word	1074040832
 5795 0078 FFFFF7FF 		.word	-524289
 5796 007c FFFFFBFF 		.word	-262145
 5797 0080 FFFFF3FF 		.word	-786433
 5798              		.cfi_endproc
 5799              	.LFE28:
 5801              		.comm	dmx32_val,1,1
 5802              		.comm	drs_val,1,1
 5803              		.text
 5804              	.Letext0:
 5805              		.file 2 "E:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 5806              		.file 3 "D:/kuaipan/SEMG/MEMS_SEMG_KL25/KL25 Sample Code_I2c/KL25 Sample Code/kl25_sc_rev10/klxx-s
DEFINED SYMBOLS
                            *ABS*:00000000 mcg.c
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:19     .text.pll_init:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:24     .text.pll_init:00000000 pll_init
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:519    .text.pll_init:00000254 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:539    .text.new_pll_freq:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:544    .text.new_pll_freq:00000000 new_pll_freq
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:821    .text.new_pll_freq:00000144 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:830    .text.pee_pbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:835    .text.pee_pbe:00000000 pee_pbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:916    .text.pee_pbe:0000005c $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:921    .text.pbe_pee:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:926    .text.pbe_pee:00000000 pbe_pee
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1066   .text.pbe_pee:000000a8 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1071   .text.pbe_fbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1076   .text.pbe_fbe:00000000 pbe_fbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1160   .text.pbe_fbe:00000058 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1165   .text.fbe_pbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1170   .text.fbe_pbe:00000000 fbe_pbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1373   .text.fbe_pbe:000000dc $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1382   .text.pbe_blpe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1387   .text.pbe_blpe:00000000 pbe_blpe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1439   .text.pbe_blpe:00000030 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1444   .text.blpe_pbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1449   .text.blpe_pbe:00000000 blpe_pbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1638   .text.blpe_pbe:000000d0 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1645   .text.blpe_fbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1650   .text.blpe_fbe:00000000 blpe_fbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1731   .text.blpe_fbe:00000058 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1736   .text.fbe_blpe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1741   .text.fbe_blpe:00000000 fbe_blpe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1793   .text.fbe_blpe:00000030 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1798   .text.fei_fbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:1803   .text.fei_fbe:00000000 fei_fbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2123   .text.fei_fbe:00000174 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2142   .text.fee_fbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2147   .text.fee_fbe:00000000 fee_fbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2227   .text.fee_fbe:00000058 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2232   .text.fbe_fbi:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2237   .text.fbe_fbi:00000000 fbe_fbi
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2514   .text.fbe_fbi:0000014c $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2523   .text.fbi_fbe:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2528   .text.fbi_fbe:00000000 fbi_fbe
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2849   .text.fbi_fbe:00000178 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2868   .text.fbi_blpi:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2873   .text.fbi_blpi:00000000 fbi_blpi
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2942   .text.fbi_blpi:00000044 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2947   .text.blpi_fbi:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:2952   .text.blpi_fbi:00000000 blpi_fbi
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3020   .text.blpi_fbi:00000044 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3025   .text.fee_fbi:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3030   .text.fee_fbi:00000000 fee_fbi
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3282   .text.fee_fbi:0000013c $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3291   .text.fei_fbi:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3296   .text.fei_fbi:00000000 fei_fbi
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3526   .text.fei_fbi:00000108 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3535   .text.fll_freq:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3540   .text.fll_freq:00000000 fll_freq
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3748   .text.fll_freq:000000cc $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3765   .text.fee_fei:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3770   .text.fee_fei:00000000 fee_fei
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3876   .text.fee_fei:00000070 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3883   .text.fei_fee:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:3888   .text.fei_fee:00000000 fei_fee
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4213   .text.fei_fee:00000170 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4231   .text.fbi_fei:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4236   .text.fbi_fei:00000000 fbi_fei
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4380   .text.fbi_fei:000000a4 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4387   .text.fbi_fee:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4392   .text.fbi_fee:00000000 fbi_fee
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4734   .text.fbi_fee:00000198 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4753   .text.fbe_fee:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4758   .text.fbe_fee:00000000 fbe_fee
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4887   .text.fbe_fee:00000098 $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4892   .text.fbe_fei:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:4897   .text.fbe_fei:00000000 fbe_fei
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5052   .text.fbe_fei:000000ac $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5059   .text.what_mcg_mode:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5064   .text.what_mcg_mode:00000000 what_mcg_mode
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5275   .text.what_mcg_mode:000000fc $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5285   .text.atc:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5290   .text.atc:00000000 atc
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5612   .text.atc:0000017c $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5628   .text.clk_monitor_0:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5633   .text.clk_monitor_0:00000000 clk_monitor_0
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5669   .text.clk_monitor_0:0000001c $d
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5674   .text.chk_for_resistor:00000000 $t
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5679   .text.chk_for_resistor:00000000 chk_for_resistor
C:\Users\lab\AppData\Local\Temp\ccUAWipc.s:5792   .text.chk_for_resistor:0000006c $d
                            *COM*:00000001 dmx32_val
                            *COM*:00000001 drs_val
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_idiv
__aeabi_uidiv
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2uiz

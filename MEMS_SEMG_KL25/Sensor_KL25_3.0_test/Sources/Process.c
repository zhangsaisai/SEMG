/*
 * Process.c
 *
 *  Created on: May 4, 2015
 *      Author: lab
 */
/* ###################################################################
 **     THIS COMPONENT MODULE IS GENERATED BY USER
 **     Filename    : Process.h
 **     Project     : semg_mkl15z128vlh4
 **     Processor   : MKL25Z128VLH4
 **     Component   :
 **     Version     :
 **     Datasheet   :
 **     Compiler    : GNU C Compiler
 **     Date/Time   : 2013-Aug 5, 2013, 8:54:36 PM, # CodeGen: 1
 **     Author      : Dong
 **     Abstract    :
 **         This file contains functions for kinds of data processing.
 **     Settings    :
 **
 **     Contents    :
 **                 MainLoop    - void MainLoop(void)
 **
 **     Mail        : zhangsaisai0814@163.com
 **
 **     Revision    : No.  Name        Data/Time        Content
 ** ###################################################################*/
/*!
 * @file Process.h
 * @version 01.00
 * @brief
 *      This file contains functions for kinds of data processing.
 */
/*!
 *  @addtogroup Proc Process module documentation
 *      This module contains functions for kinds of data processing.
 *  @{
 */

/* Module Process */

/* {Default RTOS Adapter} No RTOS includes */
#include "PE_Error.h"
#include "PE_Types.h"
#include "string.h"
#include "Macros.h"
#include "Globals.h"
#include "types.h"
#include "PTD0_50HZ.h"


extern TSENSORPtr tSENSORPtr;
extern TMCUPtr tMCUPtr;
extern TARMPtr tARMPtr;
extern uint16  S_FrameNumber;
extern short init_Mx,init_My,init_Mz;//全局磁传感器变量

void Process(void);
void TransmitMCUData(void);
void CopyADCDataToMCUData(void);
void PackData(void);
void SwapARMDataBuffer(void);
void ReadData(void);

/*
 * ===================================================================
 * Global Variables
 * ===================================================================
 */
static int chDataCnt = 0;
static uint16 readCnt = 0;
static uint16 packCnt = 0;
uint16 intCnt = 0;

static uint8 overflowCnt = 0;
const uint8 DATA_FRAME_HEAD_SIZE = 11u;                                     /*!< The size of the head of data frame. */
const uint8 DATA_FRAME_TAIL_SIZE = 1u;                                     /*!< The size of the tail of data frame. */
/*
 * ===================================================================
 *     Method      : ReadData(Module Process)
 */
/*!
 *     @brief
 *          This method reads sensor's data when sensor's is ready to be read.
 *          This method is called in function
 *          EINT_SENSOR_NOT_DRDY0_OnInterrupt,
 *          file Events.c
 *     @param
 *          void
 *     @return
 *          void
 */
/* ===================================================================*/
void ReadData(void)
{
	short Ax,Ay,Az,Mx,My,Mz,Gx,Gy,Gz;
	uint32 i;
	//extern TSENSORPtr tSENSORPtr;
		
    if(tSENSORPtr->sensorStatus.isDataReady == TRUE)
    {
    	get_mag(&Mx,&My,&Mz);
    	get_gyro(&Gx,&Gy,&Gz);
    	get_acc(&Ax,&Ay,&Az);
    	
    	tSENSORPtr->sensorData.rawData[0]= Mx;//磁传感器变量;
    	tSENSORPtr->sensorData.rawData[1]= My;
    	tSENSORPtr->sensorData.rawData[2]= Mz;
    	tSENSORPtr->sensorData.rawData[3]= Gx;
    	tSENSORPtr->sensorData.rawData[4]= Gy;
    	tSENSORPtr->sensorData.rawData[5]= Gz;
    	tSENSORPtr->sensorData.rawData[6]= Ax;
    	tSENSORPtr->sensorData.rawData[7]= Ay;
    	tSENSORPtr->sensorData.rawData[8]= Az;   	
    	
        tSENSORPtr->sensorStatus.transmitionContent = eData;
        tSENSORPtr->sensorStatus.isDataReady = FALSE;
        tSENSORPtr->sensorStatus.sensorDataStatus = eReceived;
    	
        //printf("Mx=%d,My=%d,Mz=%d\n",Mx,My,Mz);     
        
    	//test the sample fre of read_data
    	PTD0_50HZ_ClrVal(NULL);
    	for(i=0;i<100;i++);
    	PTD0_50HZ_SetVal(NULL);
     
    }

}


/*
 * ===================================================================
 *     Method      : TransmitADCData(Module Process)
 */
/*!
 *     @brief
 *          This method transmit MCU's data to ARM when is required.
 *     @param
 *          void
 *     @return
 *          void
 */
/* ===================================================================*/
void TransmitMCUData(void)
{
    //extern TMCUPtr tMCUPtr;
    //extern TARMPtr tARMPtr;
	uint_8 status;
	
    tARMPtr->armStatus.isRequiringData = FALSE;
    //IOUploadReadySetVal();
        
    status = USB_Class_Mems_Send_Data(0, 1, (LDD_DMA_TAddress)tARMPtr->foreBuffer,DATA_FRAME_LENGTH) ;
        
    //IOUploadReadyClrVal();
    tARMPtr->armStatus.transmitionContent = eData;
    tARMPtr->armStatus.foreBufferStatus = eRead;
    tARMPtr->armStatus.isUploadReady = FALSE;

}


/*
 * ===================================================================
 *     Method      : CopySensorDataToMCUData(Module Process)
 */
/*!
 *     @brief
 *          This method copies Sensor data from Sensor structure to MCU structure.
 *          The format of data in MCU structure
       @verbatim
       --------------------------------------
        (axis)  | 1ms 2ms 3ms ... 99ms |
       --------------------------------------
        (axis1) | [0] [1] [2] ... [99] |
        (axis2) | [0] [1] [2] ... [99] |
        (axis3) | [0] [1] [2] ... [99] |
        (axis4) | [0] [1] [2] ... [99] |
        (axis5) | [0] [1] [2] ... [99] |
        (axis6) | [0] [1] [2] ... [99] |
        (axis7) | [0] [1] [2] ... [99] |
        (axis8) | [0] [1] [2] ... [99] |
        (axis9) | [0] [1] [2] ... [99] |
       @endverbatim
 *     @param
 *          void
 *     @return
 *          void
 */
/* ===================================================================*/
void CopySensorDataToMCUData(void)
{
    //extern TMCUPtr tMCUPtr;
    //extern TSENSORPtr tSensorPtr;
    
    tMCUPtr->mcuData.axisData[0][chDataCnt] = tSENSORPtr->sensorData.rawData[0];
    tMCUPtr->mcuData.axisData[1][chDataCnt] = tSENSORPtr->sensorData.rawData[1];
    tMCUPtr->mcuData.axisData[2][chDataCnt] = tSENSORPtr->sensorData.rawData[2];
    tMCUPtr->mcuData.axisData[3][chDataCnt] = tSENSORPtr->sensorData.rawData[3];
    tMCUPtr->mcuData.axisData[4][chDataCnt] = tSENSORPtr->sensorData.rawData[4];
    tMCUPtr->mcuData.axisData[5][chDataCnt] = tSENSORPtr->sensorData.rawData[5];
    tMCUPtr->mcuData.axisData[6][chDataCnt] = tSENSORPtr->sensorData.rawData[6];
    tMCUPtr->mcuData.axisData[7][chDataCnt] = tSENSORPtr->sensorData.rawData[7];
    tMCUPtr->mcuData.axisData[8][chDataCnt] = tSENSORPtr->sensorData.rawData[8];
}




/*
 * ===================================================================
 *     Method      : PackData (Module Process)
 */
/*!
 *     @brief
 *         	This method is called to pack filtered data adapting to the
 *         	format according to the protocol between MCU and ARM.
 *     @param
 *         	void
 *     @return
 *         	void
 */
/* ===================================================================*/
void PackData(void)
{
	//extern TMCUPtr tMCUPtr;
    //extern TARMPtr tARMPtr;
    int axisNum,axisNum_off,offset,i;

    if(eFull == tARMPtr->armStatus.backBufferStatus || eOverflow == tARMPtr->armStatus.backBufferStatus)
    {
        tARMPtr->armStatus.backBufferStatus = eOverflow;
        overflowCnt++;
        return;
    }

    for(axisNum = 0;  axisNum < 9 ; axisNum++)// 9 axis,18 byte
    {
         offset = DATA_FRAME_HEAD_SIZE /* Head Bits in a pack, eg. 0xB8, data length,time stamp,status. etc. */
                            + SENSOR_DATA_COUNT * chDataCnt;/* every time sensor data is 18 bytes. */
         //chDataCnt:add from 0 to 5,when acquire the data every 100ms
         axisNum_off = axisNum * 2;
         tARMPtr->backBuffer[offset + axisNum_off] = tMCUPtr->mcuData.axisData[axisNum][chDataCnt] >> 8 & 0xFFU;
         tARMPtr->backBuffer[offset + axisNum_off +1] = tMCUPtr->mcuData.axisData[axisNum][chDataCnt] & 0xFFU;
    }
    //test the data of buffer
    if(chDataCnt==1)
    	i++;
    
    chDataCnt++;
    chDataCnt %= CHANNEL_DATA_COUNT;
    if( !chDataCnt )
    {
        tARMPtr->armStatus.backBufferStatus = eFull;
    }
    else
    {
        tARMPtr->armStatus.backBufferStatus = eWrite;
    }
    
}




/*
 * ===================================================================
 *     Method      : Process(Module Process)
 */
/*!
 *     @brief
 *         	The primary routine of processing the data.
 *     @param
 *          void
 *     @return
 *          void
 */
/* ===================================================================*/
void Process(void)
{
    //extern TSENSORPtr tSENSORPtr;
    if( tSENSORPtr->sensorStatus.sensorDataStatus == eReceived )
    {
    	tSENSORPtr->sensorStatus.sensorDataStatus = eIdle;
    	packCnt++;
    	packCnt %= 65535;
    	CopySensorDataToMCUData();
        PackData();
        
    }
}





/*
 * ===================================================================
 *     Method      : SwapARMDataBuffer (Module Process)
 */
/*!
 *     @brief
 *          This method is called to swap the arm's data. Decide either the
 *          armLeftData or armRightData is the foreground buffer or background
 *          buffer.
 *     @param
 *          void
 *     @return
 *          void
 */
/* ===================================================================*/
void SwapARMDataBuffer(void)
{
	int i , j;
	//extern TARMPtr tARMPtr;
	//foreBufferStatus & backBufferStatus is FULL just in init state
    if(eNull == tARMPtr->armStatus.foreBufferStatus && eNull == tARMPtr->armStatus.backBufferStatus)//first swap data
    {
        tARMPtr->foreBuffer = tARMPtr->armDataRight.dataFrame;
        tARMPtr->backBuffer = tARMPtr->armDataLeft.dataFrame;
        tARMPtr->armStatus.foreBufferStatus = eEmpty;
        tARMPtr->armStatus.backBufferStatus = eEmpty;
        tARMPtr->armStatus.isUploadReady = FALSE;

        tARMPtr->foreBuffer[7] = (tARMPtr->foreBuffer[7] & 0x01U)
                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);

        tARMPtr->foreBuffer[8] = 0x0U;
    }
    else// not first swap data
    {
        byte* temp;
        temp = tARMPtr->foreBuffer;
        tARMPtr->foreBuffer = tARMPtr->backBuffer;
        tARMPtr->backBuffer = temp;
        tARMPtr->armStatus.foreBufferStatus = tARMPtr->armStatus.backBufferStatus;
        tARMPtr->armStatus.backBufferStatus = eEmpty;
        tARMPtr->armStatus.isUploadReady = FALSE;

        tARMPtr->foreBuffer[7] = (tARMPtr->foreBuffer[7] & 0x01U)
                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);     
        switch(tARMPtr->armStatus.foreBufferStatus)
        {
        case eOverflow:
            tARMPtr->foreBuffer[8] = overflowCnt;
            break;
        case eFull:
            tARMPtr->foreBuffer[8] = 0x00U;
            break;
        case eWrite:
        {
            int remainNum;
            remainNum = CHANNEL_DATA_COUNT - chDataCnt;
        	tARMPtr->foreBuffer[8] = remainNum;
        	
            //Fill the remaining position as the last value in the array.
            int offset;
            for( i = 0; i < remainNum; i++)
            {
                for( j = 0; j < SENSOR_DATA_COUNT; j++)
                {
                	offset = DATA_FRAME_HEAD_SIZE /* Head Bits in a pack, eg. 0xB7, data length,time stamp,status. etc. */
                			+ (chDataCnt + i) * SENSOR_DATA_COUNT;//acquired data in now
                    tARMPtr->backBuffer[offset + j] = tARMPtr->backBuffer[offset  - SENSOR_DATA_COUNT + j];//fill the blank in the last sensor data
                }
            }         
            break;
        }
        case eRead:
            break;
        case eEmpty:
        case eIdle:
            tARMPtr->foreBuffer[8] = CHANNEL_DATA_COUNT;
            break;
        }
        
        tARMPtr->foreBuffer[4] = (unsigned char)(S_FrameNumber >> 8);
        tARMPtr->foreBuffer[5] = (unsigned char)S_FrameNumber;
    }
    chDataCnt = 0;   
    overflowCnt = 0;
}

    /* End Process */

/*!
 * @}
 */
/*
 ** ###################################################################
 **
 **     This file was created by Dong
 **     for the Freescale Kinetis series of microcontrollers.
 **
 ** ###################################################################
 */






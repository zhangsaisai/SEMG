Sources\Process.o:     file format elf32-littlearmSources\Process.oarchitecture: arm, flags 0x00000011:HAS_RELOC, HAS_SYMSstart address 0x00000000private flags = 5000000: [Version5 EABI]Sections:Idx Name          Size      VMA       LMA       File off  Algn  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC  3 .bss.chDataCnt 00000004  00000000  00000000  00000034  2**2                  ALLOC  4 .bss.overflowCnt 00000001  00000000  00000000  00000034  2**0                  ALLOC  5 .text.MainLoop 0000008c  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  6 .text.ReadADCData 000000e0  00000000  00000000  000000c0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  7 .text.Process 00000044  00000000  00000000  000001a0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  8 .text.TransmitMCUData 00000078  00000000  00000000  000001e4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  9 .text.SplitRawData 000001b8  00000000  00000000  0000025c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.CopyADCDataToMCUData 000001d0  00000000  00000000  00000414  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.PackData 00000158  00000000  00000000  000005e4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 12 .text.SwapARMDataBuffer 00000244  00000000  00000000  0000073c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 13 .rodata.SwapARMDataBuffer 00000018  00000000  00000000  00000980  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 14 .debug_info   00000d16  00000000  00000000  00000998  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 15 .debug_abbrev 000001de  00000000  00000000  000016ae  2**0                  CONTENTS, READONLY, DEBUGGING 16 .debug_loc    00000184  00000000  00000000  0000188c  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 17 .debug_aranges 00000058  00000000  00000000  00001a10  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 18 .debug_macinfo 000450c4  00000000  00000000  00001a68  2**0                  CONTENTS, READONLY, DEBUGGING 19 .debug_line   00000643  00000000  00000000  00046b2c  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 20 .debug_str    00000858  00000000  00000000  0004716f  2**0                  CONTENTS, READONLY, DEBUGGING 21 .comment      0000007a  00000000  00000000  000479c7  2**0                  CONTENTS, READONLY 22 .ARM.attributes 00000031  00000000  00000000  00047a41  2**0                  CONTENTS, READONLY 23 .debug_frame  00000100  00000000  00000000  00047a74  2**2                  CONTENTS, RELOC, READONLY, DEBUGGINGSYMBOL TABLE:00000000 l    df *ABS*	00000000 Process.c00000000 l    d  .text	00000000 .text00000000 l    d  .data	00000000 .data00000000 l    d  .bss	00000000 .bss00000000 l    d  .bss.chDataCnt	00000000 .bss.chDataCnt00000000 l     O .bss.chDataCnt	00000004 chDataCnt00000000 l    d  .bss.overflowCnt	00000000 .bss.overflowCnt00000000 l     O .bss.overflowCnt	00000001 overflowCnt00000000 l    d  .text.MainLoop	00000000 .text.MainLoop00000000 l     F .text.ReadADCData	000000e0 ReadADCData00000000 l     F .text.Process	00000044 Process00000000 l    d  .text.ReadADCData	00000000 .text.ReadADCData00000000 l    d  .text.Process	00000000 .text.Process00000000 l     F .text.SplitRawData	000001b8 SplitRawData00000000 l     F .text.CopyADCDataToMCUData	000001d0 CopyADCDataToMCUData00000000 l     F .text.PackData	00000158 PackData00000000 l    d  .text.TransmitMCUData	00000000 .text.TransmitMCUData00000000 l    d  .text.SplitRawData	00000000 .text.SplitRawData00000000 l    d  .text.CopyADCDataToMCUData	00000000 .text.CopyADCDataToMCUData00000000 l    d  .text.PackData	00000000 .text.PackData00000000 l    d  .text.SwapARMDataBuffer	00000000 .text.SwapARMDataBuffer00000000 l    d  .rodata.SwapARMDataBuffer	00000000 .rodata.SwapARMDataBuffer00000000 l    d  .debug_info	00000000 .debug_info00000000 l    d  .debug_abbrev	00000000 .debug_abbrev00000000 l    d  .debug_loc	00000000 .debug_loc00000000 l    d  .debug_aranges	00000000 .debug_aranges00000000 l    d  .debug_macinfo	00000000 .debug_macinfo00000000 l    d  .debug_line	00000000 .debug_line00000000 l    d  .debug_str	00000000 .debug_str00000000 l    d  .debug_frame	00000000 .debug_frame00000000 l    d  .comment	00000000 .comment00000000 l    d  .ARM.attributes	00000000 .ARM.attributes00000068       O *COM*	00000004 tADC00000008       O *COM*	00000004 tADCPtr000011a2       O *COM*	00000004 tMCU00000004       O *COM*	00000004 tMCUPtr00001980       O *COM*	00000004 tARM00000004       O *COM*	00000004 tARMPtr00000004       O *COM*	00000004 masterSPI0DevData00000004       O *COM*	00000004 slaveSPI1DevData00000004       O *COM*	00000004 masterSPIRxDMADevData00000004       O *COM*	00000004 masterSPITxDMADevData00000004       O *COM*	00000004 slaveSPIRxDMADevData00000004       O *COM*	00000004 slaveSPITxDMADevData00000004       O *COM*	00000004 dmaControllerDevData00000004       O *COM*	00000004 portA1DevData00000004       O *COM*	00000004 portB2DevData00000004       O *COM*	00000004 portC4DevData00000004       O *COM*	00000004 portE0DevData00000004       O *COM*	00000004 portA5DevData00000004       O *COM*	00000004 portB1DevData00000004       O *COM*	00000004 portC8DevData00000004       O *COM*	00000004 portE1DevData00000004       O *COM*	00000004 portA2DevData00000004       O *COM*	00000004 portE29DevData00000000 g     F .text.MainLoop	0000008c MainLoop00000000         *UND*	00000000 EINT_AD_NOT_DRDY0_Enable00000000         *UND*	00000000 EINT_SYNC_INT_Enable00000000         *UND*	00000000 isStart00000000         *UND*	00000000 EnableADCSPI00000000         *UND*	00000000 ADCReadContinuousData00000000         *UND*	00000000 DisableADCSPI00000000 g     F .text.TransmitMCUData	00000078 TransmitMCUData00000000         *UND*	00000000 BitIO_UPRDY_SetVal00000000         *UND*	00000000 SPI1SendData00000000         *UND*	00000000 BitIO_UPRDY_ClrVal00000000         *UND*	00000000 RAW_DATA_HEAD00000000         *UND*	00000000 BYTE_COUNT_PER_CHANNEL00000000         *UND*	00000000 __aeabi_uidivmod00000000 g     F .text.SwapARMDataBuffer	00000244 SwapARMDataBufferDisassembly of section .text.MainLoop:00000000 <MainLoop>: *     @return *          void *//* ===================================================================*/void MainLoop(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;    extern volatile bool isStart;    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = TRUE;   4:	4b1b      	ldr	r3, [pc, #108]	; (74 <MainLoop+0x74>)   6:	681b      	ldr	r3, [r3, #0]   8:	785a      	ldrb	r2, [r3, #1]   a:	2110      	movs	r1, #16   c:	430a      	orrs	r2, r1   e:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = TRUE;  10:	4b18      	ldr	r3, [pc, #96]	; (74 <MainLoop+0x74>)  12:	681b      	ldr	r3, [r3, #0]  14:	785a      	ldrb	r2, [r3, #1]  16:	2108      	movs	r1, #8  18:	430a      	orrs	r2, r1  1a:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI1RxDMATransCompleted = TRUE;  1c:	4b15      	ldr	r3, [pc, #84]	; (74 <MainLoop+0x74>)  1e:	681b      	ldr	r3, [r3, #0]  20:	785a      	ldrb	r2, [r3, #1]  22:	2140      	movs	r1, #64	; 0x40  24:	430a      	orrs	r2, r1  26:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted = TRUE;  28:	4b12      	ldr	r3, [pc, #72]	; (74 <MainLoop+0x74>)  2a:	681b      	ldr	r3, [r3, #0]  2c:	785a      	ldrb	r2, [r3, #1]  2e:	2120      	movs	r1, #32  30:	430a      	orrs	r2, r1  32:	705a      	strb	r2, [r3, #1]//    SPI0_BR = (SPI_BR_SPPR(0x02) | SPI_BR_SPR(0x02));   /* Set baud rage register, 1M */    SPI0_BR = (SPI_BR_SPPR(0x01) | SPI_BR_SPR(0x00)); /* Set baud rate register,6M */  34:	4b10      	ldr	r3, [pc, #64]	; (78 <MainLoop+0x78>)  36:	2210      	movs	r2, #16  38:	709a      	strb	r2, [r3, #2]//    SPI0_BR = (SPI_BR_SPPR(0x00) | SPI_BR_SPR(0x00)); /* Set baud rate register,12M */    /* Enable PortA's interrupt. */    EIntADNotReady0Enable(EINT_AD_NOT_DRDY0);  3a:	4b10      	ldr	r3, [pc, #64]	; (7c <MainLoop+0x7c>)  3c:	681b      	ldr	r3, [r3, #0]  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <EINT_AD_NOT_DRDY0_Enable>			40: R_ARM_THM_CALL	EINT_AD_NOT_DRDY0_Enable//    EIntADNotReady1Enable(EINT_AD_NOT_DRDY1);    EIntSyncInterruptEnable(EINT_SYNC_INT);  44:	4b0e      	ldr	r3, [pc, #56]	; (80 <MainLoop+0x80>)  46:	681b      	ldr	r3, [r3, #0]  48:	1c18      	adds	r0, r3, #0  4a:	f7ff fffe 	bl	0 <EINT_SYNC_INT_Enable>			4a: R_ARM_THM_CALL	EINT_SYNC_INT_Enable    NVIC_ISER |= NVIC_ISER_SETENA(0x40000000);      /* Enable PortA's hardware interrupt */  4e:	4b0d      	ldr	r3, [pc, #52]	; (84 <MainLoop+0x84>)  50:	4a0c      	ldr	r2, [pc, #48]	; (84 <MainLoop+0x84>)  52:	6812      	ldr	r2, [r2, #0]  54:	2180      	movs	r1, #128	; 0x80  56:	05c9      	lsls	r1, r1, #23  58:	430a      	orrs	r2, r1  5a:	601a      	str	r2, [r3, #0]    //ADCStartConvertByCommand(eADC0);    //ADCStartConvertByCommand(eADC1);    /* Start ADC's conversion at the same time by Pull the start pin high. *///    tARMPtr->backBuffer = tARMPtr->armDataLeft.dataFrame;//    GPIOB_PDOR |= 0x06U;    /* B1, B2 */    while(!isStart);  5c:	46c0      	nop			; (mov r8, r8)  5e:	4b0a      	ldr	r3, [pc, #40]	; (88 <MainLoop+0x88>)  60:	781b      	ldrb	r3, [r3, #0]  62:	b2db      	uxtb	r3, r3  64:	2b00      	cmp	r3, #0  66:	d0fa      	beq.n	5e <MainLoop+0x5e>    for(;;)    {//        SwapARMDataBuffer();    /* Swap the data buffer if needed. */        /* If data of ADC is ready, read it. */        ReadADCData();  68:	f7ff fffe 	bl	0 <MainLoop>			68: R_ARM_THM_CALL	ReadADCData        /* Processing the Data. */        Process();  6c:	f7ff fffe 	bl	0 <MainLoop>			6c: R_ARM_THM_CALL	Process        //Process(eADC1);        /*  If the ARM requires data, transmit. */        //TransmitMCUData();    }  70:	e7fa      	b.n	68 <MainLoop+0x68>  72:	46c0      	nop			; (mov r8, r8)  74:	00000000 	.word	0x00000000			74: R_ARM_ABS32	tMCUPtr  78:	40076000 	.word	0x40076000	...			7c: R_ARM_ABS32	portA1DevData			80: R_ARM_ABS32	portA2DevData  84:	e000e100 	.word	0xe000e100  88:	00000000 	.word	0x00000000			88: R_ARM_ABS32	isStartDisassembly of section .text.ReadADCData:00000000 <ReadADCData>: *     @return *          void *//* ===================================================================*/static void ReadADCData(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TADCPtr tADCPtr[USING_ADC_COUNT];    //EADCFlag adcFlag;    if(tADCPtr[eADC0]->adcStatus.isDataReady)// && tADCPtr[eADC1]->adcStatus.isDataReady)   4:	4b34      	ldr	r3, [pc, #208]	; (d8 <ReadADCData+0xd8>)   6:	681b      	ldr	r3, [r3, #0]   8:	781b      	ldrb	r3, [r3, #0]   a:	b2da      	uxtb	r2, r3   c:	2301      	movs	r3, #1   e:	4013      	ands	r3, r2  10:	b2db      	uxtb	r3, r3  12:	2b00      	cmp	r3, #0  14:	d05d      	beq.n	d2 <ReadADCData+0xd2>    {        EnableADCSPI(eADC0);  16:	2000      	movs	r0, #0  18:	f7ff fffe 	bl	0 <EnableADCSPI>			18: R_ARM_THM_CALL	EnableADCSPI        ADCReadContinuousData(tADCPtr[eADC0]->adcData.rawData, RAW_DATA_SIZE);  1c:	4b2e      	ldr	r3, [pc, #184]	; (d8 <ReadADCData+0xd8>)  1e:	681b      	ldr	r3, [r3, #0]  20:	3310      	adds	r3, #16  22:	1c18      	adds	r0, r3, #0  24:	2113      	movs	r1, #19  26:	f7ff fffe 	bl	0 <ADCReadContinuousData>			26: R_ARM_THM_CALL	ADCReadContinuousData        tMCUPtr->mcuStatus.isReceivingADCData = TRUE;  2a:	4b2c      	ldr	r3, [pc, #176]	; (dc <ReadADCData+0xdc>)  2c:	681b      	ldr	r3, [r3, #0]  2e:	781a      	ldrb	r2, [r3, #0]  30:	2101      	movs	r1, #1  32:	430a      	orrs	r2, r1  34:	701a      	strb	r2, [r3, #0]//        tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;//        tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;        tADCPtr[eADC0]->adcStatus.adcDataStatus = eReceiving;  36:	4b28      	ldr	r3, [pc, #160]	; (d8 <ReadADCData+0xd8>)  38:	681b      	ldr	r3, [r3, #0]  3a:	2200      	movs	r2, #0  3c:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC0]->adcStatus.transmitionContent = eData;  3e:	4b26      	ldr	r3, [pc, #152]	; (d8 <ReadADCData+0xd8>)  40:	681b      	ldr	r3, [r3, #0]  42:	2201      	movs	r2, #1  44:	705a      	strb	r2, [r3, #1]//        while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);        DisableADCSPI(eADC0);  46:	2000      	movs	r0, #0  48:	f7ff fffe 	bl	0 <DisableADCSPI>			48: R_ARM_THM_CALL	DisableADCSPI        tMCUPtr->mcuStatus.isReceivingADCData = FALSE;  4c:	4b23      	ldr	r3, [pc, #140]	; (dc <ReadADCData+0xdc>)  4e:	681b      	ldr	r3, [r3, #0]  50:	781a      	ldrb	r2, [r3, #0]  52:	2101      	movs	r1, #1  54:	438a      	bics	r2, r1  56:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC0]->adcStatus.isDataReady = FALSE;  58:	4b1f      	ldr	r3, [pc, #124]	; (d8 <ReadADCData+0xd8>)  5a:	681b      	ldr	r3, [r3, #0]  5c:	781a      	ldrb	r2, [r3, #0]  5e:	2101      	movs	r1, #1  60:	438a      	bics	r2, r1  62:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC0]->adcStatus.adcDataStatus = eReceived;  64:	4b1c      	ldr	r3, [pc, #112]	; (d8 <ReadADCData+0xd8>)  66:	681b      	ldr	r3, [r3, #0]  68:	2201      	movs	r2, #1  6a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC0]->adcStatus.transmitionContent = eNothing;  6c:	4b1a      	ldr	r3, [pc, #104]	; (d8 <ReadADCData+0xd8>)  6e:	681b      	ldr	r3, [r3, #0]  70:	22ff      	movs	r2, #255	; 0xff  72:	705a      	strb	r2, [r3, #1]        //Process(eADC0);        EnableADCSPI(eADC1);  74:	2001      	movs	r0, #1  76:	f7ff fffe 	bl	0 <EnableADCSPI>			76: R_ARM_THM_CALL	EnableADCSPI        ADCReadContinuousData(tADCPtr[eADC1]->adcData.rawData, RAW_DATA_SIZE);  7a:	4b17      	ldr	r3, [pc, #92]	; (d8 <ReadADCData+0xd8>)  7c:	685b      	ldr	r3, [r3, #4]  7e:	3310      	adds	r3, #16  80:	1c18      	adds	r0, r3, #0  82:	2113      	movs	r1, #19  84:	f7ff fffe 	bl	0 <ADCReadContinuousData>			84: R_ARM_THM_CALL	ADCReadContinuousData        tMCUPtr->mcuStatus.isReceivingADCData = TRUE;  88:	4b14      	ldr	r3, [pc, #80]	; (dc <ReadADCData+0xdc>)  8a:	681b      	ldr	r3, [r3, #0]  8c:	781a      	ldrb	r2, [r3, #0]  8e:	2101      	movs	r1, #1  90:	430a      	orrs	r2, r1  92:	701a      	strb	r2, [r3, #0]//        tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;//        tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;        tADCPtr[eADC1]->adcStatus.adcDataStatus = eReceiving;  94:	4b10      	ldr	r3, [pc, #64]	; (d8 <ReadADCData+0xd8>)  96:	685b      	ldr	r3, [r3, #4]  98:	2200      	movs	r2, #0  9a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.transmitionContent = eData;  9c:	4b0e      	ldr	r3, [pc, #56]	; (d8 <ReadADCData+0xd8>)  9e:	685b      	ldr	r3, [r3, #4]  a0:	2201      	movs	r2, #1  a2:	705a      	strb	r2, [r3, #1]//        while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);        DisableADCSPI(eADC1);  a4:	2001      	movs	r0, #1  a6:	f7ff fffe 	bl	0 <DisableADCSPI>			a6: R_ARM_THM_CALL	DisableADCSPI        tMCUPtr->mcuStatus.isReceivingADCData = FALSE;  aa:	4b0c      	ldr	r3, [pc, #48]	; (dc <ReadADCData+0xdc>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	781a      	ldrb	r2, [r3, #0]  b0:	2101      	movs	r1, #1  b2:	438a      	bics	r2, r1  b4:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC1]->adcStatus.isDataReady = FALSE;  b6:	4b08      	ldr	r3, [pc, #32]	; (d8 <ReadADCData+0xd8>)  b8:	685b      	ldr	r3, [r3, #4]  ba:	781a      	ldrb	r2, [r3, #0]  bc:	2101      	movs	r1, #1  be:	438a      	bics	r2, r1  c0:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC1]->adcStatus.adcDataStatus = eReceived;  c2:	4b05      	ldr	r3, [pc, #20]	; (d8 <ReadADCData+0xd8>)  c4:	685b      	ldr	r3, [r3, #4]  c6:	2201      	movs	r2, #1  c8:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.transmitionContent = eNothing;  ca:	4b03      	ldr	r3, [pc, #12]	; (d8 <ReadADCData+0xd8>)  cc:	685b      	ldr	r3, [r3, #4]  ce:	22ff      	movs	r2, #255	; 0xff  d0:	705a      	strb	r2, [r3, #1]//        tADCPtr[adcFlag]->adcStatus.adcDataStatus = eReceived;//        tADCPtr[adcFlag]->adcStatus.transmitionContent = eNothing;////        Process(adcFlag);//    }}  d2:	46bd      	mov	sp, r7  d4:	bd80      	pop	{r7, pc}  d6:	46c0      	nop			; (mov r8, r8)	...			d8: R_ARM_ABS32	tADCPtr			dc: R_ARM_ABS32	tMCUPtrDisassembly of section .text.Process:00000000 <Process>: *     @return *          void *//* ===================================================================*/static void Process(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TADCPtr tADCPtr[USING_ADC_COUNT];    if(eReceived == tADCPtr[eADC0]->adcStatus.adcDataStatus   4:	4b0e      	ldr	r3, [pc, #56]	; (40 <Process+0x40>)   6:	681b      	ldr	r3, [r3, #0]   8:	789b      	ldrb	r3, [r3, #2]   a:	b2db      	uxtb	r3, r3   c:	b25b      	sxtb	r3, r3   e:	2b01      	cmp	r3, #1  10:	d114      	bne.n	3c <Process+0x3c>            && eReceived == tADCPtr[eADC0]->adcStatus.adcDataStatus)  12:	4b0b      	ldr	r3, [pc, #44]	; (40 <Process+0x40>)  14:	681b      	ldr	r3, [r3, #0]  16:	789b      	ldrb	r3, [r3, #2]  18:	b2db      	uxtb	r3, r3  1a:	b25b      	sxtb	r3, r3  1c:	2b01      	cmp	r3, #1  1e:	d10d      	bne.n	3c <Process+0x3c>    {        SplitRawData();  20:	f7ff fffe 	bl	0 <Process>			20: R_ARM_THM_CALL	SplitRawData        tADCPtr[eADC0]->adcStatus.adcDataStatus = eIdle;  24:	4b06      	ldr	r3, [pc, #24]	; (40 <Process+0x40>)  26:	681b      	ldr	r3, [r3, #0]  28:	22ff      	movs	r2, #255	; 0xff  2a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.adcDataStatus = eIdle;  2c:	4b04      	ldr	r3, [pc, #16]	; (40 <Process+0x40>)  2e:	685b      	ldr	r3, [r3, #4]  30:	22ff      	movs	r2, #255	; 0xff  32:	709a      	strb	r2, [r3, #2]        CopyADCDataToMCUData();  34:	f7ff fffe 	bl	0 <Process>			34: R_ARM_THM_CALL	CopyADCDataToMCUData        PackData();  38:	f7ff fffe 	bl	0 <Process>			38: R_ARM_THM_CALL	PackData    }}  3c:	46bd      	mov	sp, r7  3e:	bd80      	pop	{r7, pc}  40:	00000000 	.word	0x00000000			40: R_ARM_ABS32	tADCPtrDisassembly of section .text.TransmitMCUData:00000000 <TransmitMCUData>: *     @return *          void *//* ===================================================================*/void TransmitMCUData(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    //if(//tARMPtr->armStatus.isRequiringData &&            //tARMPtr->armStatus.isUploadReady &&                //tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted)    //{        tARMPtr->armStatus.isRequiringData = FALSE;   4:	4b17      	ldr	r3, [pc, #92]	; (64 <TransmitMCUData+0x64>)   6:	681b      	ldr	r3, [r3, #0]   8:	781a      	ldrb	r2, [r3, #0]   a:	2101      	movs	r1, #1   c:	438a      	bics	r2, r1   e:	701a      	strb	r2, [r3, #0]        tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted = FALSE;  10:	4b15      	ldr	r3, [pc, #84]	; (68 <TransmitMCUData+0x68>)  12:	681b      	ldr	r3, [r3, #0]  14:	785a      	ldrb	r2, [r3, #1]  16:	2120      	movs	r1, #32  18:	438a      	bics	r2, r1  1a:	705a      	strb	r2, [r3, #1]        IOUploadReadySetVal();  1c:	4b13      	ldr	r3, [pc, #76]	; (6c <TransmitMCUData+0x6c>)  1e:	681b      	ldr	r3, [r3, #0]  20:	1c18      	adds	r0, r3, #0  22:	f7ff fffe 	bl	0 <BitIO_UPRDY_SetVal>			22: R_ARM_THM_CALL	BitIO_UPRDY_SetVal        SPI1SendData((LDD_DMA_TAddress)tARMPtr->foreBuffer, DATA_FRAME_LENGTH + 1);  26:	4b0f      	ldr	r3, [pc, #60]	; (64 <TransmitMCUData+0x64>)  28:	681a      	ldr	r2, [r3, #0]  2a:	4b11      	ldr	r3, [pc, #68]	; (70 <TransmitMCUData+0x70>)  2c:	58d3      	ldr	r3, [r2, r3]  2e:	1c1a      	adds	r2, r3, #0  30:	4b10      	ldr	r3, [pc, #64]	; (74 <TransmitMCUData+0x74>)  32:	1c10      	adds	r0, r2, #0  34:	1c19      	adds	r1, r3, #0  36:	f7ff fffe 	bl	0 <SPI1SendData>			36: R_ARM_THM_CALL	SPI1SendData        IOUploadReadyClrVal();  3a:	4b0c      	ldr	r3, [pc, #48]	; (6c <TransmitMCUData+0x6c>)  3c:	681b      	ldr	r3, [r3, #0]  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <BitIO_UPRDY_ClrVal>			40: R_ARM_THM_CALL	BitIO_UPRDY_ClrVal        //tARMPtr->armStatus.isTransmittingData = TRUE;        tARMPtr->armStatus.transmitionContent = eData;  44:	4b07      	ldr	r3, [pc, #28]	; (64 <TransmitMCUData+0x64>)  46:	681b      	ldr	r3, [r3, #0]  48:	2201      	movs	r2, #1  4a:	705a      	strb	r2, [r3, #1]//        tARMPtr->armStatus.isForeBufferEmpty = FALSE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eRead;  4c:	4b05      	ldr	r3, [pc, #20]	; (64 <TransmitMCUData+0x64>)  4e:	681b      	ldr	r3, [r3, #0]  50:	2201      	movs	r2, #1  52:	709a      	strb	r2, [r3, #2]        tARMPtr->armStatus.isUploadReady = FALSE;  54:	4b03      	ldr	r3, [pc, #12]	; (64 <TransmitMCUData+0x64>)  56:	681b      	ldr	r3, [r3, #0]  58:	781a      	ldrb	r2, [r3, #0]  5a:	2102      	movs	r1, #2  5c:	438a      	bics	r2, r1  5e:	701a      	strb	r2, [r3, #0]    //}}  60:	46bd      	mov	sp, r7  62:	bd80      	pop	{r7, pc}	...			64: R_ARM_ABS32	tARMPtr			68: R_ARM_ABS32	tMCUPtr			6c: R_ARM_ABS32	portE29DevData  70:	00001978 	.word	0x00001978  74:	00000cba 	.word	0x00000cbaDisassembly of section .text.SplitRawData:00000000 <SplitRawData>: *         	                                  so the data is invalid. *         	                - ERR_OK: Succeeded to split. *//* ===================================================================*/static LDD_TError SplitRawData(void){   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0    byte loffStatP;    byte loffStatN;    byte regGPIOData;    int16 channelData;    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)   6:	2300      	movs	r3, #0   8:	617b      	str	r3, [r7, #20]   a:	e0c5      	b.n	198 <SplitRawData+0x198>    {        head = ((tADCPtr[adcNum]->adcData.rawData[0] & 0xF0) >> 4) & 0x0F;       /* Split head byte from raw data. */   c:	4b67      	ldr	r3, [pc, #412]	; (1ac <SplitRawData+0x1ac>)   e:	697a      	ldr	r2, [r7, #20]  10:	0092      	lsls	r2, r2, #2  12:	58d3      	ldr	r3, [r2, r3]  14:	7c1a      	ldrb	r2, [r3, #16]  16:	1c3b      	adds	r3, r7, #0  18:	330f      	adds	r3, #15  1a:	0912      	lsrs	r2, r2, #4  1c:	701a      	strb	r2, [r3, #0]        if(head != RAW_DATA_HEAD)                                   /* If the head byte is not right(0x0C), return with error. */  1e:	4b64      	ldr	r3, [pc, #400]	; (1b0 <SplitRawData+0x1b0>)  20:	781b      	ldrb	r3, [r3, #0]  22:	1c3a      	adds	r2, r7, #0  24:	320f      	adds	r2, #15  26:	7812      	ldrb	r2, [r2, #0]  28:	429a      	cmp	r2, r3  2a:	d007      	beq.n	3c <SplitRawData+0x3c>        {            err = ERR_PARAM_DATA;  2c:	1c3b      	adds	r3, r7, #0  2e:	330c      	adds	r3, #12  30:	2283      	movs	r2, #131	; 0x83  32:	801a      	strh	r2, [r3, #0]    #if DEBUG            PrintErrorMessage(err);            printf("%#x\n", head);    #endif            return err;  34:	1c3b      	adds	r3, r7, #0  36:	330c      	adds	r3, #12  38:	881b      	ldrh	r3, [r3, #0]  3a:	e0b2      	b.n	1a2 <SplitRawData+0x1a2>        }        loffStatP  = ((byte)(tADCPtr[adcNum]->adcData.rawData[0] & 0x0F) << 4) & 0xF0;  3c:	4b5b      	ldr	r3, [pc, #364]	; (1ac <SplitRawData+0x1ac>)  3e:	697a      	ldr	r2, [r7, #20]  40:	0092      	lsls	r2, r2, #2  42:	58d3      	ldr	r3, [r2, r3]  44:	7c1b      	ldrb	r3, [r3, #16]  46:	011a      	lsls	r2, r3, #4  48:	1c3b      	adds	r3, r7, #0  4a:	330b      	adds	r3, #11  4c:	701a      	strb	r2, [r3, #0]        loffStatP |= ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0xF0) >> 4) & 0x0F;  4e:	4b57      	ldr	r3, [pc, #348]	; (1ac <SplitRawData+0x1ac>)  50:	697a      	ldr	r2, [r7, #20]  52:	0092      	lsls	r2, r2, #2  54:	58d3      	ldr	r3, [r2, r3]  56:	7c5b      	ldrb	r3, [r3, #17]  58:	091b      	lsrs	r3, r3, #4  5a:	b2db      	uxtb	r3, r3  5c:	b2da      	uxtb	r2, r3  5e:	1c3b      	adds	r3, r7, #0  60:	330b      	adds	r3, #11  62:	781b      	ldrb	r3, [r3, #0]  64:	4313      	orrs	r3, r2  66:	b2da      	uxtb	r2, r3  68:	1c3b      	adds	r3, r7, #0  6a:	330b      	adds	r3, #11  6c:	701a      	strb	r2, [r3, #0]        loffStatN  = ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0x0F) << 4) & 0xF0;  6e:	4b4f      	ldr	r3, [pc, #316]	; (1ac <SplitRawData+0x1ac>)  70:	697a      	ldr	r2, [r7, #20]  72:	0092      	lsls	r2, r2, #2  74:	58d3      	ldr	r3, [r2, r3]  76:	7c5b      	ldrb	r3, [r3, #17]  78:	011a      	lsls	r2, r3, #4  7a:	1c3b      	adds	r3, r7, #0  7c:	330a      	adds	r3, #10  7e:	701a      	strb	r2, [r3, #0]        loffStatN |= ((byte)(tADCPtr[adcNum]->adcData.rawData[2] & 0xF0) >> 4) & 0x0F;  80:	4b4a      	ldr	r3, [pc, #296]	; (1ac <SplitRawData+0x1ac>)  82:	697a      	ldr	r2, [r7, #20]  84:	0092      	lsls	r2, r2, #2  86:	58d3      	ldr	r3, [r2, r3]  88:	7c9b      	ldrb	r3, [r3, #18]  8a:	091b      	lsrs	r3, r3, #4  8c:	b2db      	uxtb	r3, r3  8e:	b2da      	uxtb	r2, r3  90:	1c3b      	adds	r3, r7, #0  92:	330a      	adds	r3, #10  94:	781b      	ldrb	r3, [r3, #0]  96:	4313      	orrs	r3, r2  98:	b2da      	uxtb	r2, r3  9a:	1c3b      	adds	r3, r7, #0  9c:	330a      	adds	r3, #10  9e:	701a      	strb	r2, [r3, #0]        regGPIOData =  (byte)tADCPtr[adcNum]->adcData.rawData[2] & 0x0F;  a0:	4b42      	ldr	r3, [pc, #264]	; (1ac <SplitRawData+0x1ac>)  a2:	697a      	ldr	r2, [r7, #20]  a4:	0092      	lsls	r2, r2, #2  a6:	58d3      	ldr	r3, [r2, r3]  a8:	7c99      	ldrb	r1, [r3, #18]  aa:	1c3b      	adds	r3, r7, #0  ac:	3309      	adds	r3, #9  ae:	220f      	movs	r2, #15  b0:	400a      	ands	r2, r1  b2:	701a      	strb	r2, [r3, #0]        for(int i = 0; i < USING_CHANNEL_COUNT * BYTE_COUNT_PER_CHANNEL; i += 2)    /* Every channel's data is 2 Bytes. */  b4:	2300      	movs	r3, #0  b6:	613b      	str	r3, [r7, #16]  b8:	e045      	b.n	146 <SplitRawData+0x146>        {            channelData = ((int16)tADCPtr[adcNum]->adcData.rawData[RAW_DATA_HEAD_SIZE + i] << 8) & 0xFF00;  ba:	4b3c      	ldr	r3, [pc, #240]	; (1ac <SplitRawData+0x1ac>)  bc:	697a      	ldr	r2, [r7, #20]  be:	0092      	lsls	r2, r2, #2  c0:	58d1      	ldr	r1, [r2, r3]  c2:	693b      	ldr	r3, [r7, #16]  c4:	1cda      	adds	r2, r3, #3  c6:	2308      	movs	r3, #8  c8:	188a      	adds	r2, r1, r2  ca:	18d3      	adds	r3, r2, r3  cc:	7a1b      	ldrb	r3, [r3, #8]  ce:	021a      	lsls	r2, r3, #8  d0:	1dbb      	adds	r3, r7, #6  d2:	801a      	strh	r2, [r3, #0]            channelData |= (int16)tADCPtr[adcNum]->adcData.rawData[RAW_DATA_HEAD_SIZE + i + 1] & 0x00FF;  d4:	4b35      	ldr	r3, [pc, #212]	; (1ac <SplitRawData+0x1ac>)  d6:	697a      	ldr	r2, [r7, #20]  d8:	0092      	lsls	r2, r2, #2  da:	58d1      	ldr	r1, [r2, r3]  dc:	693b      	ldr	r3, [r7, #16]  de:	1d1a      	adds	r2, r3, #4  e0:	2308      	movs	r3, #8  e2:	188a      	adds	r2, r1, r2  e4:	18d3      	adds	r3, r2, r3  e6:	7a1b      	ldrb	r3, [r3, #8]  e8:	1c19      	adds	r1, r3, #0  ea:	1dbb      	adds	r3, r7, #6  ec:	1dba      	adds	r2, r7, #6  ee:	8812      	ldrh	r2, [r2, #0]  f0:	430a      	orrs	r2, r1  f2:	801a      	strh	r2, [r3, #0]            if(eADC0 == adcNum)  f4:	697b      	ldr	r3, [r7, #20]  f6:	2b00      	cmp	r3, #0  f8:	d112      	bne.n	120 <SplitRawData+0x120>            {                //According to the hardware, the data from the 1st ADC should be reversed.                tADCPtr[adcNum]->adcData.channelData[USING_CHANNEL_COUNT - (i >> 1) - 1] = (channelData == 0x8000) ? 0x7FFF : (int16)(-channelData);  fa:	4b2c      	ldr	r3, [pc, #176]	; (1ac <SplitRawData+0x1ac>)  fc:	697a      	ldr	r2, [r7, #20]  fe:	0092      	lsls	r2, r2, #2 100:	58d1      	ldr	r1, [r2, r3] 102:	693b      	ldr	r3, [r7, #16] 104:	105b      	asrs	r3, r3, #1 106:	2207      	movs	r2, #7 108:	1ad3      	subs	r3, r2, r3 10a:	1dba      	adds	r2, r7, #6 10c:	8812      	ldrh	r2, [r2, #0] 10e:	4252      	negs	r2, r2 110:	b292      	uxth	r2, r2 112:	b292      	uxth	r2, r2 114:	3310      	adds	r3, #16 116:	005b      	lsls	r3, r3, #1 118:	18cb      	adds	r3, r1, r3 11a:	3304      	adds	r3, #4 11c:	801a      	strh	r2, [r3, #0] 11e:	e00f      	b.n	140 <SplitRawData+0x140>            }            else if(eADC1 == adcNum) 120:	697b      	ldr	r3, [r7, #20] 122:	2b01      	cmp	r3, #1 124:	d10c      	bne.n	140 <SplitRawData+0x140>            {                tADCPtr[adcNum]->adcData.channelData[i >> 1] = (int16)channelData; 126:	4b21      	ldr	r3, [pc, #132]	; (1ac <SplitRawData+0x1ac>) 128:	697a      	ldr	r2, [r7, #20] 12a:	0092      	lsls	r2, r2, #2 12c:	58d2      	ldr	r2, [r2, r3] 12e:	693b      	ldr	r3, [r7, #16] 130:	105b      	asrs	r3, r3, #1 132:	3310      	adds	r3, #16 134:	005b      	lsls	r3, r3, #1 136:	18d3      	adds	r3, r2, r3 138:	3304      	adds	r3, #4 13a:	1dba      	adds	r2, r7, #6 13c:	8812      	ldrh	r2, [r2, #0] 13e:	801a      	strh	r2, [r3, #0]        loffStatN  = ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0x0F) << 4) & 0xF0;        loffStatN |= ((byte)(tADCPtr[adcNum]->adcData.rawData[2] & 0xF0) >> 4) & 0x0F;        regGPIOData =  (byte)tADCPtr[adcNum]->adcData.rawData[2] & 0x0F;        for(int i = 0; i < USING_CHANNEL_COUNT * BYTE_COUNT_PER_CHANNEL; i += 2)    /* Every channel's data is 2 Bytes. */ 140:	693b      	ldr	r3, [r7, #16] 142:	3302      	adds	r3, #2 144:	613b      	str	r3, [r7, #16] 146:	693a      	ldr	r2, [r7, #16] 148:	4b1a      	ldr	r3, [pc, #104]	; (1b4 <SplitRawData+0x1b4>) 14a:	781b      	ldrb	r3, [r3, #0] 14c:	00db      	lsls	r3, r3, #3 14e:	429a      	cmp	r2, r3 150:	d3b3      	bcc.n	ba <SplitRawData+0xba>            {                tADCPtr[adcNum]->adcData.channelData[i >> 1] = (int16)channelData;            }        }        tADCPtr[adcNum]->adcData.head = (byte)head; 152:	4b16      	ldr	r3, [pc, #88]	; (1ac <SplitRawData+0x1ac>) 154:	697a      	ldr	r2, [r7, #20] 156:	0092      	lsls	r2, r2, #2 158:	58d3      	ldr	r3, [r2, r3] 15a:	1c3a      	adds	r2, r7, #0 15c:	320f      	adds	r2, #15 15e:	7812      	ldrb	r2, [r2, #0] 160:	731a      	strb	r2, [r3, #12]        tADCPtr[adcNum]->adcData.loffStatP = (byte)loffStatP; 162:	4b12      	ldr	r3, [pc, #72]	; (1ac <SplitRawData+0x1ac>) 164:	697a      	ldr	r2, [r7, #20] 166:	0092      	lsls	r2, r2, #2 168:	58d3      	ldr	r3, [r2, r3] 16a:	1c3a      	adds	r2, r7, #0 16c:	320b      	adds	r2, #11 16e:	7812      	ldrb	r2, [r2, #0] 170:	735a      	strb	r2, [r3, #13]        tADCPtr[adcNum]->adcData.loffStatN = (byte)loffStatN; 172:	4b0e      	ldr	r3, [pc, #56]	; (1ac <SplitRawData+0x1ac>) 174:	697a      	ldr	r2, [r7, #20] 176:	0092      	lsls	r2, r2, #2 178:	58d3      	ldr	r3, [r2, r3] 17a:	1c3a      	adds	r2, r7, #0 17c:	320a      	adds	r2, #10 17e:	7812      	ldrb	r2, [r2, #0] 180:	739a      	strb	r2, [r3, #14]        tADCPtr[adcNum]->adcData.regGPIOData = (byte)regGPIOData; 182:	4b0a      	ldr	r3, [pc, #40]	; (1ac <SplitRawData+0x1ac>) 184:	697a      	ldr	r2, [r7, #20] 186:	0092      	lsls	r2, r2, #2 188:	58d3      	ldr	r3, [r2, r3] 18a:	1c3a      	adds	r2, r7, #0 18c:	3209      	adds	r2, #9 18e:	7812      	ldrb	r2, [r2, #0] 190:	73da      	strb	r2, [r3, #15]    byte loffStatP;    byte loffStatN;    byte regGPIOData;    int16 channelData;    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++) 192:	697b      	ldr	r3, [r7, #20] 194:	3301      	adds	r3, #1 196:	617b      	str	r3, [r7, #20] 198:	697b      	ldr	r3, [r7, #20] 19a:	2b01      	cmp	r3, #1 19c:	d800      	bhi.n	1a0 <SplitRawData+0x1a0> 19e:	e735      	b.n	c <SplitRawData+0xc>        tADCPtr[adcNum]->adcData.loffStatP = (byte)loffStatP;        tADCPtr[adcNum]->adcData.loffStatN = (byte)loffStatN;        tADCPtr[adcNum]->adcData.regGPIOData = (byte)regGPIOData;    }    return ERR_OK; 1a0:	2300      	movs	r3, #0} 1a2:	1c18      	adds	r0, r3, #0 1a4:	46bd      	mov	sp, r7 1a6:	b006      	add	sp, #24 1a8:	bd80      	pop	{r7, pc} 1aa:	46c0      	nop			; (mov r8, r8)	...			1ac: R_ARM_ABS32	tADCPtr			1b0: R_ARM_ABS32	RAW_DATA_HEAD			1b4: R_ARM_ABS32	BYTE_COUNT_PER_CHANNELDisassembly of section .text.CopyADCDataToMCUData:00000000 <CopyADCDataToMCUData>: *     @return *          void *//* ===================================================================*/static void CopyADCDataToMCUData(void){   0:	b590      	push	{r4, r7, lr}   2:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;//    static uint8 chDataCnt[USING_ADC_COUNT] = {0};    tMCUPtr->mcuData.channelData[0][0][chDataCnt] = tADCPtr[0]->adcData.channelData[0];   4:	4b6c      	ldr	r3, [pc, #432]	; (1b8 <CopyADCDataToMCUData+0x1b8>)   6:	6819      	ldr	r1, [r3, #0]   8:	4b6c      	ldr	r3, [pc, #432]	; (1bc <CopyADCDataToMCUData+0x1bc>)   a:	6818      	ldr	r0, [r3, #0]   c:	4b6c      	ldr	r3, [pc, #432]	; (1c0 <CopyADCDataToMCUData+0x1c0>)   e:	681b      	ldr	r3, [r3, #0]  10:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  12:	0043      	lsls	r3, r0, #1  14:	18cb      	adds	r3, r1, r3  16:	3302      	adds	r3, #2  18:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][1][chDataCnt] = tADCPtr[0]->adcData.channelData[1];  1a:	4b67      	ldr	r3, [pc, #412]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  1c:	6819      	ldr	r1, [r3, #0]  1e:	4b67      	ldr	r3, [pc, #412]	; (1bc <CopyADCDataToMCUData+0x1bc>)  20:	6818      	ldr	r0, [r3, #0]  22:	4b67      	ldr	r3, [pc, #412]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  24:	681b      	ldr	r3, [r3, #0]  26:	8cda      	ldrh	r2, [r3, #38]	; 0x26  28:	1c03      	adds	r3, r0, #0  2a:	3364      	adds	r3, #100	; 0x64  2c:	005b      	lsls	r3, r3, #1  2e:	18cb      	adds	r3, r1, r3  30:	3302      	adds	r3, #2  32:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][2][chDataCnt] = tADCPtr[0]->adcData.channelData[2];  34:	4b60      	ldr	r3, [pc, #384]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  36:	6819      	ldr	r1, [r3, #0]  38:	4b60      	ldr	r3, [pc, #384]	; (1bc <CopyADCDataToMCUData+0x1bc>)  3a:	6818      	ldr	r0, [r3, #0]  3c:	4b60      	ldr	r3, [pc, #384]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  3e:	681b      	ldr	r3, [r3, #0]  40:	8d1a      	ldrh	r2, [r3, #40]	; 0x28  42:	1c03      	adds	r3, r0, #0  44:	33c8      	adds	r3, #200	; 0xc8  46:	005b      	lsls	r3, r3, #1  48:	18cb      	adds	r3, r1, r3  4a:	3302      	adds	r3, #2  4c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][3][chDataCnt] = tADCPtr[0]->adcData.channelData[3];  4e:	4b5a      	ldr	r3, [pc, #360]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  50:	6819      	ldr	r1, [r3, #0]  52:	4b5a      	ldr	r3, [pc, #360]	; (1bc <CopyADCDataToMCUData+0x1bc>)  54:	6818      	ldr	r0, [r3, #0]  56:	4b5a      	ldr	r3, [pc, #360]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  58:	681b      	ldr	r3, [r3, #0]  5a:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a  5c:	2496      	movs	r4, #150	; 0x96  5e:	0064      	lsls	r4, r4, #1  60:	1903      	adds	r3, r0, r4  62:	005b      	lsls	r3, r3, #1  64:	18cb      	adds	r3, r1, r3  66:	3302      	adds	r3, #2  68:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][4][chDataCnt] = tADCPtr[0]->adcData.channelData[4];  6a:	4b53      	ldr	r3, [pc, #332]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  6c:	6819      	ldr	r1, [r3, #0]  6e:	4b53      	ldr	r3, [pc, #332]	; (1bc <CopyADCDataToMCUData+0x1bc>)  70:	6818      	ldr	r0, [r3, #0]  72:	4b53      	ldr	r3, [pc, #332]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  74:	681b      	ldr	r3, [r3, #0]  76:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c  78:	24c8      	movs	r4, #200	; 0xc8  7a:	0064      	lsls	r4, r4, #1  7c:	1903      	adds	r3, r0, r4  7e:	005b      	lsls	r3, r3, #1  80:	18cb      	adds	r3, r1, r3  82:	3302      	adds	r3, #2  84:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][5][chDataCnt] = tADCPtr[0]->adcData.channelData[5];  86:	4b4c      	ldr	r3, [pc, #304]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  88:	6819      	ldr	r1, [r3, #0]  8a:	4b4c      	ldr	r3, [pc, #304]	; (1bc <CopyADCDataToMCUData+0x1bc>)  8c:	6818      	ldr	r0, [r3, #0]  8e:	4b4c      	ldr	r3, [pc, #304]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  90:	681b      	ldr	r3, [r3, #0]  92:	8dda      	ldrh	r2, [r3, #46]	; 0x2e  94:	24fa      	movs	r4, #250	; 0xfa  96:	0064      	lsls	r4, r4, #1  98:	1903      	adds	r3, r0, r4  9a:	005b      	lsls	r3, r3, #1  9c:	18cb      	adds	r3, r1, r3  9e:	3302      	adds	r3, #2  a0:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][6][chDataCnt] = tADCPtr[0]->adcData.channelData[6];  a2:	4b45      	ldr	r3, [pc, #276]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  a4:	6819      	ldr	r1, [r3, #0]  a6:	4b45      	ldr	r3, [pc, #276]	; (1bc <CopyADCDataToMCUData+0x1bc>)  a8:	6818      	ldr	r0, [r3, #0]  aa:	4b45      	ldr	r3, [pc, #276]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	8e1a      	ldrh	r2, [r3, #48]	; 0x30  b0:	2496      	movs	r4, #150	; 0x96  b2:	00a4      	lsls	r4, r4, #2  b4:	1903      	adds	r3, r0, r4  b6:	005b      	lsls	r3, r3, #1  b8:	18cb      	adds	r3, r1, r3  ba:	3302      	adds	r3, #2  bc:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][7][chDataCnt] = tADCPtr[0]->adcData.channelData[7];  be:	4b3e      	ldr	r3, [pc, #248]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  c0:	6819      	ldr	r1, [r3, #0]  c2:	4b3e      	ldr	r3, [pc, #248]	; (1bc <CopyADCDataToMCUData+0x1bc>)  c4:	6818      	ldr	r0, [r3, #0]  c6:	4b3e      	ldr	r3, [pc, #248]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  c8:	681b      	ldr	r3, [r3, #0]  ca:	8e5a      	ldrh	r2, [r3, #50]	; 0x32  cc:	24af      	movs	r4, #175	; 0xaf  ce:	00a4      	lsls	r4, r4, #2  d0:	1903      	adds	r3, r0, r4  d2:	005b      	lsls	r3, r3, #1  d4:	18cb      	adds	r3, r1, r3  d6:	3302      	adds	r3, #2  d8:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][0][chDataCnt] = tADCPtr[1]->adcData.channelData[0];  da:	4b37      	ldr	r3, [pc, #220]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  dc:	6819      	ldr	r1, [r3, #0]  de:	4b37      	ldr	r3, [pc, #220]	; (1bc <CopyADCDataToMCUData+0x1bc>)  e0:	6818      	ldr	r0, [r3, #0]  e2:	4b37      	ldr	r3, [pc, #220]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  e4:	685b      	ldr	r3, [r3, #4]  e6:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  e8:	24c8      	movs	r4, #200	; 0xc8  ea:	00a4      	lsls	r4, r4, #2  ec:	1903      	adds	r3, r0, r4  ee:	005b      	lsls	r3, r3, #1  f0:	18cb      	adds	r3, r1, r3  f2:	3302      	adds	r3, #2  f4:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][1][chDataCnt] = tADCPtr[1]->adcData.channelData[1];  f6:	4b30      	ldr	r3, [pc, #192]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  f8:	6819      	ldr	r1, [r3, #0]  fa:	4b30      	ldr	r3, [pc, #192]	; (1bc <CopyADCDataToMCUData+0x1bc>)  fc:	6818      	ldr	r0, [r3, #0]  fe:	4b30      	ldr	r3, [pc, #192]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 100:	685b      	ldr	r3, [r3, #4] 102:	8cda      	ldrh	r2, [r3, #38]	; 0x26 104:	24e1      	movs	r4, #225	; 0xe1 106:	00a4      	lsls	r4, r4, #2 108:	1903      	adds	r3, r0, r4 10a:	005b      	lsls	r3, r3, #1 10c:	18cb      	adds	r3, r1, r3 10e:	3302      	adds	r3, #2 110:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][2][chDataCnt] = tADCPtr[1]->adcData.channelData[2]; 112:	4b29      	ldr	r3, [pc, #164]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 114:	6819      	ldr	r1, [r3, #0] 116:	4b29      	ldr	r3, [pc, #164]	; (1bc <CopyADCDataToMCUData+0x1bc>) 118:	6818      	ldr	r0, [r3, #0] 11a:	4b29      	ldr	r3, [pc, #164]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 11c:	685b      	ldr	r3, [r3, #4] 11e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28 120:	24fa      	movs	r4, #250	; 0xfa 122:	00a4      	lsls	r4, r4, #2 124:	1903      	adds	r3, r0, r4 126:	005b      	lsls	r3, r3, #1 128:	18cb      	adds	r3, r1, r3 12a:	3302      	adds	r3, #2 12c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][3][chDataCnt] = tADCPtr[1]->adcData.channelData[3]; 12e:	4b22      	ldr	r3, [pc, #136]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 130:	6819      	ldr	r1, [r3, #0] 132:	4b22      	ldr	r3, [pc, #136]	; (1bc <CopyADCDataToMCUData+0x1bc>) 134:	6818      	ldr	r0, [r3, #0] 136:	4b22      	ldr	r3, [pc, #136]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 138:	685b      	ldr	r3, [r3, #4] 13a:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a 13c:	4c21      	ldr	r4, [pc, #132]	; (1c4 <CopyADCDataToMCUData+0x1c4>) 13e:	1903      	adds	r3, r0, r4 140:	005b      	lsls	r3, r3, #1 142:	18cb      	adds	r3, r1, r3 144:	3302      	adds	r3, #2 146:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][4][chDataCnt] = tADCPtr[1]->adcData.channelData[4]; 148:	4b1b      	ldr	r3, [pc, #108]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 14a:	6819      	ldr	r1, [r3, #0] 14c:	4b1b      	ldr	r3, [pc, #108]	; (1bc <CopyADCDataToMCUData+0x1bc>) 14e:	6818      	ldr	r0, [r3, #0] 150:	4b1b      	ldr	r3, [pc, #108]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 152:	685b      	ldr	r3, [r3, #4] 154:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c 156:	2496      	movs	r4, #150	; 0x96 158:	00e4      	lsls	r4, r4, #3 15a:	1903      	adds	r3, r0, r4 15c:	005b      	lsls	r3, r3, #1 15e:	18cb      	adds	r3, r1, r3 160:	3302      	adds	r3, #2 162:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][5][chDataCnt] = tADCPtr[1]->adcData.channelData[5]; 164:	4b14      	ldr	r3, [pc, #80]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 166:	6819      	ldr	r1, [r3, #0] 168:	4b14      	ldr	r3, [pc, #80]	; (1bc <CopyADCDataToMCUData+0x1bc>) 16a:	6818      	ldr	r0, [r3, #0] 16c:	4b14      	ldr	r3, [pc, #80]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 16e:	685b      	ldr	r3, [r3, #4] 170:	8dda      	ldrh	r2, [r3, #46]	; 0x2e 172:	4c15      	ldr	r4, [pc, #84]	; (1c8 <CopyADCDataToMCUData+0x1c8>) 174:	1903      	adds	r3, r0, r4 176:	005b      	lsls	r3, r3, #1 178:	18cb      	adds	r3, r1, r3 17a:	3302      	adds	r3, #2 17c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][6][chDataCnt] = tADCPtr[1]->adcData.channelData[6]; 17e:	4b0e      	ldr	r3, [pc, #56]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 180:	6819      	ldr	r1, [r3, #0] 182:	4b0e      	ldr	r3, [pc, #56]	; (1bc <CopyADCDataToMCUData+0x1bc>) 184:	6818      	ldr	r0, [r3, #0] 186:	4b0e      	ldr	r3, [pc, #56]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 188:	685b      	ldr	r3, [r3, #4] 18a:	8e1a      	ldrh	r2, [r3, #48]	; 0x30 18c:	24af      	movs	r4, #175	; 0xaf 18e:	00e4      	lsls	r4, r4, #3 190:	1903      	adds	r3, r0, r4 192:	005b      	lsls	r3, r3, #1 194:	18cb      	adds	r3, r1, r3 196:	3302      	adds	r3, #2 198:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][7][chDataCnt] = tADCPtr[1]->adcData.channelData[7]; 19a:	4b07      	ldr	r3, [pc, #28]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 19c:	6819      	ldr	r1, [r3, #0] 19e:	4b07      	ldr	r3, [pc, #28]	; (1bc <CopyADCDataToMCUData+0x1bc>) 1a0:	6818      	ldr	r0, [r3, #0] 1a2:	4b07      	ldr	r3, [pc, #28]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 1a4:	685b      	ldr	r3, [r3, #4] 1a6:	8e5a      	ldrh	r2, [r3, #50]	; 0x32 1a8:	4c08      	ldr	r4, [pc, #32]	; (1cc <CopyADCDataToMCUData+0x1cc>) 1aa:	1903      	adds	r3, r0, r4 1ac:	005b      	lsls	r3, r3, #1 1ae:	18cb      	adds	r3, r1, r3 1b0:	3302      	adds	r3, #2 1b2:	801a      	strh	r2, [r3, #0]//    chDataCnt[adcFlag]++;//    chDataCnt[adcFlag] %= CHANNEL_DATA_COUNT;} 1b4:	46bd      	mov	sp, r7 1b6:	bd90      	pop	{r4, r7, pc}	...			1b8: R_ARM_ABS32	tMCUPtr			1bc: R_ARM_ABS32	.bss.chDataCnt			1c0: R_ARM_ABS32	tADCPtr 1c4:	0000044c 	.word	0x0000044c 1c8:	00000514 	.word	0x00000514 1cc:	000005dc 	.word	0x000005dcDisassembly of section .text.PackData:00000000 <PackData>: *     @return *         	void *//* ===================================================================*/static void PackData(void){   0:	b084b5b0 	.word	0xb084b5b0   4:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;    extern TARMPtr tARMPtr;//    static int chDataCnt[USING_ADC_COUNT] = {0};    int off;    if(eFull == tARMPtr->armStatus.backBufferStatus || eOverflow == tARMPtr->armStatus.backBufferStatus)   6:	4b4f      	ldr	r3, [pc, #316]	; (144 <PackData+0x144>)   8:	681b      	ldr	r3, [r3, #0]   a:	78db      	ldrb	r3, [r3, #3]   c:	b2db      	uxtb	r3, r3   e:	b25b      	sxtb	r3, r3  10:	2b03      	cmp	r3, #3  12:	d006      	beq.n	22 <PackData+0x22>  14:	4b4b      	ldr	r3, [pc, #300]	; (144 <PackData+0x144>)  16:	681b      	ldr	r3, [r3, #0]  18:	78db      	ldrb	r3, [r3, #3]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	2b04      	cmp	r3, #4  20:	d10a      	bne.n	38 <PackData+0x38>    {        tARMPtr->armStatus.backBufferStatus = eOverflow;  22:	4b48      	ldr	r3, [pc, #288]	; (144 <PackData+0x144>)  24:	681b      	ldr	r3, [r3, #0]  26:	2204      	movs	r2, #4  28:	70da      	strb	r2, [r3, #3]        overflowCnt++;  2a:	4b47      	ldr	r3, [pc, #284]	; (148 <PackData+0x148>)  2c:	781b      	ldrb	r3, [r3, #0]  2e:	3301      	adds	r3, #1  30:	b2da      	uxtb	r2, r3  32:	4b45      	ldr	r3, [pc, #276]	; (148 <PackData+0x148>)  34:	701a      	strb	r2, [r3, #0]        return;  36:	e081      	b.n	13c <PackData+0x13c>    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)  38:	2300      	movs	r3, #0  3a:	60fb      	str	r3, [r7, #12]  3c:	e05f      	b.n	fe <PackData+0xfe>    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)  3e:	2300      	movs	r3, #0  40:	60bb      	str	r3, [r7, #8]  42:	e056      	b.n	f2 <PackData+0xf2>            off = 1624 * adcNum                    + 203 * channelNum                    + (chDataCnt << 1)                    + 11;            */            off = (adcNum << 10) + (adcNum << 9) + (adcNum << 6) + (adcNum << 4) + (adcNum << 3)  44:	68fb      	ldr	r3, [r7, #12]  46:	029a      	lsls	r2, r3, #10  48:	68fb      	ldr	r3, [r7, #12]  4a:	025b      	lsls	r3, r3, #9  4c:	18d2      	adds	r2, r2, r3  4e:	68fb      	ldr	r3, [r7, #12]  50:	019b      	lsls	r3, r3, #6  52:	18d2      	adds	r2, r2, r3  54:	68fb      	ldr	r3, [r7, #12]  56:	011b      	lsls	r3, r3, #4  58:	18d2      	adds	r2, r2, r3  5a:	68fb      	ldr	r3, [r7, #12]  5c:	00db      	lsls	r3, r3, #3  5e:	18d2      	adds	r2, r2, r3                    + (channelNum << 7) + (channelNum << 6) + (channelNum << 3) + (channelNum << 1) + channelNum  60:	68bb      	ldr	r3, [r7, #8]  62:	01db      	lsls	r3, r3, #7  64:	18d2      	adds	r2, r2, r3  66:	68bb      	ldr	r3, [r7, #8]  68:	019b      	lsls	r3, r3, #6  6a:	18d2      	adds	r2, r2, r3  6c:	68bb      	ldr	r3, [r7, #8]  6e:	00db      	lsls	r3, r3, #3  70:	18d2      	adds	r2, r2, r3  72:	68bb      	ldr	r3, [r7, #8]  74:	005b      	lsls	r3, r3, #1  76:	18d2      	adds	r2, r2, r3  78:	68bb      	ldr	r3, [r7, #8]  7a:	18d3      	adds	r3, r2, r3            off = 1624 * adcNum                    + 203 * channelNum                    + (chDataCnt << 1)                    + 11;            */            off = (adcNum << 10) + (adcNum << 9) + (adcNum << 6) + (adcNum << 4) + (adcNum << 3)  7c:	330b      	adds	r3, #11  7e:	607b      	str	r3, [r7, #4]                    + (channelNum << 7) + (channelNum << 6) + (channelNum << 3) + (channelNum << 1) + channelNum                    + 11;            tARMPtr->backBuffer[off] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] >> 8 & 0xFFU;  80:	4b30      	ldr	r3, [pc, #192]	; (144 <PackData+0x144>)  82:	681a      	ldr	r2, [r3, #0]  84:	4b31      	ldr	r3, [pc, #196]	; (14c <PackData+0x14c>)  86:	58d2      	ldr	r2, [r2, r3]  88:	687b      	ldr	r3, [r7, #4]  8a:	18d2      	adds	r2, r2, r3  8c:	4b30      	ldr	r3, [pc, #192]	; (150 <PackData+0x150>)  8e:	6819      	ldr	r1, [r3, #0]  90:	4b30      	ldr	r3, [pc, #192]	; (154 <PackData+0x154>)  92:	681b      	ldr	r3, [r3, #0]  94:	68bc      	ldr	r4, [r7, #8]  96:	68f8      	ldr	r0, [r7, #12]  98:	2564      	movs	r5, #100	; 0x64  9a:	436c      	muls	r4, r5  9c:	25c8      	movs	r5, #200	; 0xc8  9e:	00ad      	lsls	r5, r5, #2  a0:	4368      	muls	r0, r5  a2:	1820      	adds	r0, r4, r0  a4:	18c3      	adds	r3, r0, r3  a6:	005b      	lsls	r3, r3, #1  a8:	18cb      	adds	r3, r1, r3  aa:	3302      	adds	r3, #2  ac:	881b      	ldrh	r3, [r3, #0]  ae:	b21b      	sxth	r3, r3  b0:	121b      	asrs	r3, r3, #8  b2:	b29b      	uxth	r3, r3  b4:	b2db      	uxtb	r3, r3  b6:	7013      	strb	r3, [r2, #0]            tARMPtr->backBuffer[off + 1] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] & 0xFFU;  b8:	4b22      	ldr	r3, [pc, #136]	; (144 <PackData+0x144>)  ba:	681a      	ldr	r2, [r3, #0]  bc:	4b23      	ldr	r3, [pc, #140]	; (14c <PackData+0x14c>)  be:	58d2      	ldr	r2, [r2, r3]  c0:	687b      	ldr	r3, [r7, #4]  c2:	3301      	adds	r3, #1  c4:	18d2      	adds	r2, r2, r3  c6:	4b22      	ldr	r3, [pc, #136]	; (150 <PackData+0x150>)  c8:	6819      	ldr	r1, [r3, #0]  ca:	4b22      	ldr	r3, [pc, #136]	; (154 <PackData+0x154>)  cc:	681b      	ldr	r3, [r3, #0]  ce:	68bc      	ldr	r4, [r7, #8]  d0:	68f8      	ldr	r0, [r7, #12]  d2:	2564      	movs	r5, #100	; 0x64  d4:	436c      	muls	r4, r5  d6:	25c8      	movs	r5, #200	; 0xc8  d8:	00ad      	lsls	r5, r5, #2  da:	4368      	muls	r0, r5  dc:	1820      	adds	r0, r4, r0  de:	18c3      	adds	r3, r0, r3  e0:	005b      	lsls	r3, r3, #1  e2:	18cb      	adds	r3, r1, r3  e4:	3302      	adds	r3, #2  e6:	881b      	ldrh	r3, [r3, #0]  e8:	b2db      	uxtb	r3, r3  ea:	7013      	strb	r3, [r2, #0]        return;    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)  ec:	68bb      	ldr	r3, [r7, #8]  ee:	3301      	adds	r3, #1  f0:	60bb      	str	r3, [r7, #8]  f2:	68bb      	ldr	r3, [r7, #8]  f4:	2b07      	cmp	r3, #7  f6:	d9a5      	bls.n	44 <PackData+0x44>        tARMPtr->armStatus.backBufferStatus = eOverflow;        overflowCnt++;        return;    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)  f8:	68fb      	ldr	r3, [r7, #12]  fa:	3301      	adds	r3, #1  fc:	60fb      	str	r3, [r7, #12]  fe:	68fb      	ldr	r3, [r7, #12] 100:	2b01      	cmp	r3, #1 102:	d99c      	bls.n	3e <PackData+0x3e>            tARMPtr->backBuffer[off] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] >> 8 & 0xFFU;            tARMPtr->backBuffer[off + 1] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] & 0xFFU;        }    }    chDataCnt++; 104:	4b13      	ldr	r3, [pc, #76]	; (154 <PackData+0x154>) 106:	681b      	ldr	r3, [r3, #0] 108:	1c5a      	adds	r2, r3, #1 10a:	4b12      	ldr	r3, [pc, #72]	; (154 <PackData+0x154>) 10c:	601a      	str	r2, [r3, #0]    chDataCnt %= CHANNEL_DATA_COUNT; 10e:	4b11      	ldr	r3, [pc, #68]	; (154 <PackData+0x154>) 110:	681b      	ldr	r3, [r3, #0] 112:	1c18      	adds	r0, r3, #0 114:	2164      	movs	r1, #100	; 0x64 116:	f7ff fffe 	bl	0 <__aeabi_uidivmod>			116: R_ARM_THM_CALL	__aeabi_uidivmod 11a:	1c0b      	adds	r3, r1, #0 11c:	1c1a      	adds	r2, r3, #0 11e:	4b0d      	ldr	r3, [pc, #52]	; (154 <PackData+0x154>) 120:	601a      	str	r2, [r3, #0]    if(!chDataCnt) 122:	4b0c      	ldr	r3, [pc, #48]	; (154 <PackData+0x154>) 124:	681b      	ldr	r3, [r3, #0] 126:	2b00      	cmp	r3, #0 128:	d104      	bne.n	134 <PackData+0x134>    {//        tARMPtr->armStatus.isBackBufferEmpty = FALSE;//        tARMPtr->armStatus.isBackBufferFull = TRUE;        tARMPtr->armStatus.backBufferStatus = eFull; 12a:	4b06      	ldr	r3, [pc, #24]	; (144 <PackData+0x144>) 12c:	681b      	ldr	r3, [r3, #0] 12e:	2203      	movs	r2, #3 130:	70da      	strb	r2, [r3, #3] 132:	e003      	b.n	13c <PackData+0x13c>    else    {//        tARMPtr->armStatus.isBackBufferEmpty = FALSE;//        tARMPtr->armStatus.isBackBufferFull = FALSE;        tARMPtr->armStatus.backBufferStatus = eWrite; 134:	4b03      	ldr	r3, [pc, #12]	; (144 <PackData+0x144>) 136:	681b      	ldr	r3, [r3, #0] 138:	2202      	movs	r2, #2 13a:	70da      	strb	r2, [r3, #3]    }} 13c:	46bd      	mov	sp, r7 13e:	b004      	add	sp, #16 140:	bdb0      	pop	{r4, r5, r7, pc} 142:	46c0      	nop			; (mov r8, r8)	...			144: R_ARM_ABS32	tARMPtr			148: R_ARM_ABS32	.bss.overflowCnt 14c:	0000197c 	.word	0x0000197c	...			150: R_ARM_ABS32	tMCUPtr			154: R_ARM_ABS32	.bss.chDataCntDisassembly of section .text.SwapARMDataBuffer:00000000 <SwapARMDataBuffer>: *     @return *          void *//* ===================================================================*/void SwapARMDataBuffer(void){   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0    if(eNull == tARMPtr->armStatus.foreBufferStatus && eNull == tARMPtr->armStatus.backBufferStatus)   6:	4b88      	ldr	r3, [pc, #544]	; (228 <SwapARMDataBuffer+0x228>)   8:	681b      	ldr	r3, [r3, #0]   a:	789b      	ldrb	r3, [r3, #2]   c:	b2db      	uxtb	r3, r3   e:	b25b      	sxtb	r3, r3  10:	3301      	adds	r3, #1  12:	d146      	bne.n	a2 <SwapARMDataBuffer+0xa2>  14:	4b84      	ldr	r3, [pc, #528]	; (228 <SwapARMDataBuffer+0x228>)  16:	681b      	ldr	r3, [r3, #0]  18:	78db      	ldrb	r3, [r3, #3]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	3301      	adds	r3, #1  20:	d13f      	bne.n	a2 <SwapARMDataBuffer+0xa2>    {        tARMPtr->foreBuffer = tARMPtr->armDataRight.dataFrame;  22:	4b81      	ldr	r3, [pc, #516]	; (228 <SwapARMDataBuffer+0x228>)  24:	681a      	ldr	r2, [r3, #0]  26:	4b80      	ldr	r3, [pc, #512]	; (228 <SwapARMDataBuffer+0x228>)  28:	681b      	ldr	r3, [r3, #0]  2a:	4880      	ldr	r0, [pc, #512]	; (22c <SwapARMDataBuffer+0x22c>)  2c:	1819      	adds	r1, r3, r0  2e:	4b80      	ldr	r3, [pc, #512]	; (230 <SwapARMDataBuffer+0x230>)  30:	50d1      	str	r1, [r2, r3]        tARMPtr->backBuffer = tARMPtr->armDataLeft.dataFrame;  32:	4b7d      	ldr	r3, [pc, #500]	; (228 <SwapARMDataBuffer+0x228>)  34:	681a      	ldr	r2, [r3, #0]  36:	4b7c      	ldr	r3, [pc, #496]	; (228 <SwapARMDataBuffer+0x228>)  38:	681b      	ldr	r3, [r3, #0]  3a:	1d19      	adds	r1, r3, #4  3c:	4b7d      	ldr	r3, [pc, #500]	; (234 <SwapARMDataBuffer+0x234>)  3e:	50d1      	str	r1, [r2, r3]//        tARMPtr->armStatus.isForeBufferEmpty = FALSE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;//        tARMPtr->armStatus.isBackBufferEmpty = TRUE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eEmpty;  40:	4b79      	ldr	r3, [pc, #484]	; (228 <SwapARMDataBuffer+0x228>)  42:	681b      	ldr	r3, [r3, #0]  44:	2200      	movs	r2, #0  46:	709a      	strb	r2, [r3, #2]        tARMPtr->armStatus.backBufferStatus = eEmpty;  48:	4b77      	ldr	r3, [pc, #476]	; (228 <SwapARMDataBuffer+0x228>)  4a:	681b      	ldr	r3, [r3, #0]  4c:	2200      	movs	r2, #0  4e:	70da      	strb	r2, [r3, #3]        tARMPtr->armStatus.isUploadReady = FALSE;  50:	4b75      	ldr	r3, [pc, #468]	; (228 <SwapARMDataBuffer+0x228>)  52:	681b      	ldr	r3, [r3, #0]  54:	781a      	ldrb	r2, [r3, #0]  56:	2102      	movs	r1, #2  58:	438a      	bics	r2, r1  5a:	701a      	strb	r2, [r3, #0]        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  5c:	4b72      	ldr	r3, [pc, #456]	; (228 <SwapARMDataBuffer+0x228>)  5e:	681a      	ldr	r2, [r3, #0]  60:	4b73      	ldr	r3, [pc, #460]	; (230 <SwapARMDataBuffer+0x230>)  62:	58d3      	ldr	r3, [r2, r3]  64:	1d9a      	adds	r2, r3, #6  66:	4b70      	ldr	r3, [pc, #448]	; (228 <SwapARMDataBuffer+0x228>)  68:	6819      	ldr	r1, [r3, #0]  6a:	4b71      	ldr	r3, [pc, #452]	; (230 <SwapARMDataBuffer+0x230>)  6c:	58cb      	ldr	r3, [r1, r3]  6e:	3306      	adds	r3, #6  70:	7819      	ldrb	r1, [r3, #0]  72:	2301      	movs	r3, #1  74:	400b      	ands	r3, r1  76:	b2d9      	uxtb	r1, r3                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);  78:	4b6b      	ldr	r3, [pc, #428]	; (228 <SwapARMDataBuffer+0x228>)  7a:	681b      	ldr	r3, [r3, #0]  7c:	789b      	ldrb	r3, [r3, #2]  7e:	b2db      	uxtb	r3, r3//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eEmpty;        tARMPtr->armStatus.backBufferStatus = eEmpty;        tARMPtr->armStatus.isUploadReady = FALSE;        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  80:	b2db      	uxtb	r3, r3  82:	005b      	lsls	r3, r3, #1  84:	b2d8      	uxtb	r0, r3  86:	230e      	movs	r3, #14  88:	4003      	ands	r3, r0  8a:	b2db      	uxtb	r3, r3  8c:	430b      	orrs	r3, r1  8e:	b2db      	uxtb	r3, r3  90:	7013      	strb	r3, [r2, #0]                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        tARMPtr->foreBuffer[7] = 0x0U;  92:	4b65      	ldr	r3, [pc, #404]	; (228 <SwapARMDataBuffer+0x228>)  94:	681a      	ldr	r2, [r3, #0]  96:	4b66      	ldr	r3, [pc, #408]	; (230 <SwapARMDataBuffer+0x230>)  98:	58d3      	ldr	r3, [r2, r3]  9a:	3307      	adds	r3, #7  9c:	2200      	movs	r2, #0  9e:	701a      	strb	r2, [r3, #0]  a0:	e0b8      	b.n	214 <SwapARMDataBuffer+0x214>    else    {        //tARMPtr->backBuffer[7] = tARMPtr->armStatus.backBufferStatus;        byte* temp;        temp = tARMPtr->foreBuffer;  a2:	4b61      	ldr	r3, [pc, #388]	; (228 <SwapARMDataBuffer+0x228>)  a4:	681a      	ldr	r2, [r3, #0]  a6:	4b62      	ldr	r3, [pc, #392]	; (230 <SwapARMDataBuffer+0x230>)  a8:	58d3      	ldr	r3, [r2, r3]  aa:	60fb      	str	r3, [r7, #12]        tARMPtr->foreBuffer = tARMPtr->backBuffer;  ac:	4b5e      	ldr	r3, [pc, #376]	; (228 <SwapARMDataBuffer+0x228>)  ae:	681a      	ldr	r2, [r3, #0]  b0:	4b5d      	ldr	r3, [pc, #372]	; (228 <SwapARMDataBuffer+0x228>)  b2:	6819      	ldr	r1, [r3, #0]  b4:	4b5f      	ldr	r3, [pc, #380]	; (234 <SwapARMDataBuffer+0x234>)  b6:	58c9      	ldr	r1, [r1, r3]  b8:	4b5d      	ldr	r3, [pc, #372]	; (230 <SwapARMDataBuffer+0x230>)  ba:	50d1      	str	r1, [r2, r3]        tARMPtr->backBuffer = temp;  bc:	4b5a      	ldr	r3, [pc, #360]	; (228 <SwapARMDataBuffer+0x228>)  be:	681a      	ldr	r2, [r3, #0]  c0:	4b5c      	ldr	r3, [pc, #368]	; (234 <SwapARMDataBuffer+0x234>)  c2:	68f9      	ldr	r1, [r7, #12]  c4:	50d1      	str	r1, [r2, r3]        tARMPtr->armStatus.foreBufferStatus = tARMPtr->armStatus.backBufferStatus;  c6:	4b58      	ldr	r3, [pc, #352]	; (228 <SwapARMDataBuffer+0x228>)  c8:	681a      	ldr	r2, [r3, #0]  ca:	4b57      	ldr	r3, [pc, #348]	; (228 <SwapARMDataBuffer+0x228>)  cc:	681b      	ldr	r3, [r3, #0]  ce:	78db      	ldrb	r3, [r3, #3]  d0:	b2db      	uxtb	r3, r3  d2:	7093      	strb	r3, [r2, #2]        tARMPtr->armStatus.backBufferStatus = eEmpty;  d4:	4b54      	ldr	r3, [pc, #336]	; (228 <SwapARMDataBuffer+0x228>)  d6:	681b      	ldr	r3, [r3, #0]  d8:	2200      	movs	r2, #0  da:	70da      	strb	r2, [r3, #3]        tARMPtr->armStatus.isUploadReady = FALSE;  dc:	4b52      	ldr	r3, [pc, #328]	; (228 <SwapARMDataBuffer+0x228>)  de:	681b      	ldr	r3, [r3, #0]  e0:	781a      	ldrb	r2, [r3, #0]  e2:	2102      	movs	r1, #2  e4:	438a      	bics	r2, r1  e6:	701a      	strb	r2, [r3, #0]        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  e8:	4b4f      	ldr	r3, [pc, #316]	; (228 <SwapARMDataBuffer+0x228>)  ea:	681a      	ldr	r2, [r3, #0]  ec:	4b50      	ldr	r3, [pc, #320]	; (230 <SwapARMDataBuffer+0x230>)  ee:	58d3      	ldr	r3, [r2, r3]  f0:	1d9a      	adds	r2, r3, #6  f2:	4b4d      	ldr	r3, [pc, #308]	; (228 <SwapARMDataBuffer+0x228>)  f4:	6819      	ldr	r1, [r3, #0]  f6:	4b4e      	ldr	r3, [pc, #312]	; (230 <SwapARMDataBuffer+0x230>)  f8:	58cb      	ldr	r3, [r1, r3]  fa:	3306      	adds	r3, #6  fc:	7819      	ldrb	r1, [r3, #0]  fe:	2301      	movs	r3, #1 100:	400b      	ands	r3, r1 102:	b2d9      	uxtb	r1, r3                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU); 104:	4b48      	ldr	r3, [pc, #288]	; (228 <SwapARMDataBuffer+0x228>) 106:	681b      	ldr	r3, [r3, #0] 108:	789b      	ldrb	r3, [r3, #2] 10a:	b2db      	uxtb	r3, r3        tARMPtr->backBuffer = temp;        tARMPtr->armStatus.foreBufferStatus = tARMPtr->armStatus.backBufferStatus;        tARMPtr->armStatus.backBufferStatus = eEmpty;        tARMPtr->armStatus.isUploadReady = FALSE;        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U) 10c:	b2db      	uxtb	r3, r3 10e:	005b      	lsls	r3, r3, #1 110:	b2d8      	uxtb	r0, r3 112:	230e      	movs	r3, #14 114:	4003      	ands	r3, r0 116:	b2db      	uxtb	r3, r3 118:	430b      	orrs	r3, r1 11a:	b2db      	uxtb	r3, r3 11c:	7013      	strb	r3, [r2, #0]                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        switch(tARMPtr->armStatus.foreBufferStatus) 11e:	4b42      	ldr	r3, [pc, #264]	; (228 <SwapARMDataBuffer+0x228>) 120:	681b      	ldr	r3, [r3, #0] 122:	789b      	ldrb	r3, [r3, #2] 124:	b2db      	uxtb	r3, r3 126:	b25b      	sxtb	r3, r3 128:	3301      	adds	r3, #1 12a:	2b05      	cmp	r3, #5 12c:	d872      	bhi.n	214 <SwapARMDataBuffer+0x214> 12e:	009a      	lsls	r2, r3, #2 130:	4b41      	ldr	r3, [pc, #260]	; (238 <SwapARMDataBuffer+0x238>) 132:	18d3      	adds	r3, r2, r3 134:	681b      	ldr	r3, [r3, #0] 136:	469f      	mov	pc, r3        {        case eOverflow:            tARMPtr->foreBuffer[7] = overflowCnt; 138:	4b3b      	ldr	r3, [pc, #236]	; (228 <SwapARMDataBuffer+0x228>) 13a:	681a      	ldr	r2, [r3, #0] 13c:	4b3c      	ldr	r3, [pc, #240]	; (230 <SwapARMDataBuffer+0x230>) 13e:	58d3      	ldr	r3, [r2, r3] 140:	3307      	adds	r3, #7 142:	4a3e      	ldr	r2, [pc, #248]	; (23c <SwapARMDataBuffer+0x23c>) 144:	7812      	ldrb	r2, [r2, #0] 146:	701a      	strb	r2, [r3, #0]            break; 148:	e064      	b.n	214 <SwapARMDataBuffer+0x214>        case eFull:            tARMPtr->foreBuffer[7] = 0x00U; 14a:	4b37      	ldr	r3, [pc, #220]	; (228 <SwapARMDataBuffer+0x228>) 14c:	681a      	ldr	r2, [r3, #0] 14e:	4b38      	ldr	r3, [pc, #224]	; (230 <SwapARMDataBuffer+0x230>) 150:	58d3      	ldr	r3, [r2, r3] 152:	3307      	adds	r3, #7 154:	2200      	movs	r2, #0 156:	701a      	strb	r2, [r3, #0]            break; 158:	e05c      	b.n	214 <SwapARMDataBuffer+0x214>        case eWrite:        {            int remainNum;            remainNum = CHANNEL_DATA_COUNT - chDataCnt; 15a:	4b39      	ldr	r3, [pc, #228]	; (240 <SwapARMDataBuffer+0x240>) 15c:	681b      	ldr	r3, [r3, #0] 15e:	2264      	movs	r2, #100	; 0x64 160:	1ad3      	subs	r3, r2, r3 162:	60bb      	str	r3, [r7, #8]            tARMPtr->foreBuffer[7] = remainNum; 164:	4b30      	ldr	r3, [pc, #192]	; (228 <SwapARMDataBuffer+0x228>) 166:	681a      	ldr	r2, [r3, #0] 168:	4b31      	ldr	r3, [pc, #196]	; (230 <SwapARMDataBuffer+0x230>) 16a:	58d3      	ldr	r3, [r2, r3] 16c:	3307      	adds	r3, #7 16e:	68ba      	ldr	r2, [r7, #8] 170:	b2d2      	uxtb	r2, r2 172:	701a      	strb	r2, [r3, #0]            //Fill the remaining position as the last value in the array.            int off;            for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++) 174:	2300      	movs	r3, #0 176:	617b      	str	r3, [r7, #20] 178:	e03f      	b.n	1fa <SwapARMDataBuffer+0x1fa>            {                for(int j = 0; j < remainNum; j++) 17a:	2300      	movs	r3, #0 17c:	613b      	str	r3, [r7, #16] 17e:	e035      	b.n	1ec <SwapARMDataBuffer+0x1ec>                {                    //off = 210 + 203 * i - ((remainNum - j) << 1);                    off = (i << 7) + (i << 6) + (i << 3) + (i << 1) + i 180:	697b      	ldr	r3, [r7, #20] 182:	01da      	lsls	r2, r3, #7 184:	697b      	ldr	r3, [r7, #20] 186:	019b      	lsls	r3, r3, #6 188:	18d2      	adds	r2, r2, r3 18a:	697b      	ldr	r3, [r7, #20] 18c:	00db      	lsls	r3, r3, #3 18e:	18d2      	adds	r2, r2, r3 190:	697b      	ldr	r3, [r7, #20] 192:	005b      	lsls	r3, r3, #1 194:	18d2      	adds	r2, r2, r3 196:	697b      	ldr	r3, [r7, #20] 198:	18d2      	adds	r2, r2, r3                            - ((remainNum - j) << 1) 19a:	68b9      	ldr	r1, [r7, #8] 19c:	693b      	ldr	r3, [r7, #16] 19e:	1acb      	subs	r3, r1, r3 1a0:	005b      	lsls	r3, r3, #1 1a2:	1ad3      	subs	r3, r2, r3            for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++)            {                for(int j = 0; j < remainNum; j++)                {                    //off = 210 + 203 * i - ((remainNum - j) << 1);                    off = (i << 7) + (i << 6) + (i << 3) + (i << 1) + i 1a4:	33d2      	adds	r3, #210	; 0xd2 1a6:	607b      	str	r3, [r7, #4]                            - ((remainNum - j) << 1)                            + 210;                    tARMPtr->backBuffer[off] = tARMPtr->backBuffer[off - 2]; 1a8:	4b1f      	ldr	r3, [pc, #124]	; (228 <SwapARMDataBuffer+0x228>) 1aa:	681a      	ldr	r2, [r3, #0] 1ac:	4b21      	ldr	r3, [pc, #132]	; (234 <SwapARMDataBuffer+0x234>) 1ae:	58d2      	ldr	r2, [r2, r3] 1b0:	687b      	ldr	r3, [r7, #4] 1b2:	18d2      	adds	r2, r2, r3 1b4:	4b1c      	ldr	r3, [pc, #112]	; (228 <SwapARMDataBuffer+0x228>) 1b6:	6819      	ldr	r1, [r3, #0] 1b8:	4b1e      	ldr	r3, [pc, #120]	; (234 <SwapARMDataBuffer+0x234>) 1ba:	58c9      	ldr	r1, [r1, r3] 1bc:	687b      	ldr	r3, [r7, #4] 1be:	3b02      	subs	r3, #2 1c0:	18cb      	adds	r3, r1, r3 1c2:	781b      	ldrb	r3, [r3, #0] 1c4:	7013      	strb	r3, [r2, #0]                    tARMPtr->backBuffer[off + 1] = tARMPtr->backBuffer[off - 1]; 1c6:	4b18      	ldr	r3, [pc, #96]	; (228 <SwapARMDataBuffer+0x228>) 1c8:	681a      	ldr	r2, [r3, #0] 1ca:	4b1a      	ldr	r3, [pc, #104]	; (234 <SwapARMDataBuffer+0x234>) 1cc:	58d2      	ldr	r2, [r2, r3] 1ce:	687b      	ldr	r3, [r7, #4] 1d0:	3301      	adds	r3, #1 1d2:	18d2      	adds	r2, r2, r3 1d4:	4b14      	ldr	r3, [pc, #80]	; (228 <SwapARMDataBuffer+0x228>) 1d6:	6819      	ldr	r1, [r3, #0] 1d8:	4b16      	ldr	r3, [pc, #88]	; (234 <SwapARMDataBuffer+0x234>) 1da:	58c9      	ldr	r1, [r1, r3] 1dc:	687b      	ldr	r3, [r7, #4] 1de:	3b01      	subs	r3, #1 1e0:	18cb      	adds	r3, r1, r3 1e2:	781b      	ldrb	r3, [r3, #0] 1e4:	7013      	strb	r3, [r2, #0]            tARMPtr->foreBuffer[7] = remainNum;            //Fill the remaining position as the last value in the array.            int off;            for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++)            {                for(int j = 0; j < remainNum; j++) 1e6:	693b      	ldr	r3, [r7, #16] 1e8:	3301      	adds	r3, #1 1ea:	613b      	str	r3, [r7, #16] 1ec:	693a      	ldr	r2, [r7, #16] 1ee:	68bb      	ldr	r3, [r7, #8] 1f0:	429a      	cmp	r2, r3 1f2:	dbc5      	blt.n	180 <SwapARMDataBuffer+0x180>            int remainNum;            remainNum = CHANNEL_DATA_COUNT - chDataCnt;            tARMPtr->foreBuffer[7] = remainNum;            //Fill the remaining position as the last value in the array.            int off;            for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++) 1f4:	697b      	ldr	r3, [r7, #20] 1f6:	3301      	adds	r3, #1 1f8:	617b      	str	r3, [r7, #20] 1fa:	697b      	ldr	r3, [r7, #20] 1fc:	2b0f      	cmp	r3, #15 1fe:	d9bc      	bls.n	17a <SwapARMDataBuffer+0x17a>//                            tARMPtr->backBuffer[off + 1] = tARMPtr->backBuffer[off - 1];//                        }//                    }//                }//            }            break; 200:	e008      	b.n	214 <SwapARMDataBuffer+0x214>        }        case eRead:            break;        case eEmpty:        case eIdle:            tARMPtr->foreBuffer[7] = CHANNEL_DATA_COUNT; 202:	4b09      	ldr	r3, [pc, #36]	; (228 <SwapARMDataBuffer+0x228>) 204:	681a      	ldr	r2, [r3, #0] 206:	4b0a      	ldr	r3, [pc, #40]	; (230 <SwapARMDataBuffer+0x230>) 208:	58d3      	ldr	r3, [r2, r3] 20a:	3307      	adds	r3, #7 20c:	2264      	movs	r2, #100	; 0x64 20e:	701a      	strb	r2, [r3, #0]            break; 210:	e000      	b.n	214 <SwapARMDataBuffer+0x214>//                }//            }            break;        }        case eRead:            break; 212:	46c0      	nop			; (mov r8, r8)            tARMPtr->foreBuffer[7] = CHANNEL_DATA_COUNT;            break;        }    }    chDataCnt = 0; 214:	4b0a      	ldr	r3, [pc, #40]	; (240 <SwapARMDataBuffer+0x240>) 216:	2200      	movs	r2, #0 218:	601a      	str	r2, [r3, #0]    overflowCnt = 0; 21a:	4b08      	ldr	r3, [pc, #32]	; (23c <SwapARMDataBuffer+0x23c>) 21c:	2200      	movs	r2, #0 21e:	701a      	strb	r2, [r3, #0]} 220:	46bd      	mov	sp, r7 222:	b006      	add	sp, #24 224:	bd80      	pop	{r7, pc} 226:	46c0      	nop			; (mov r8, r8) 228:	00000000 	.word	0x00000000			228: R_ARM_ABS32	tARMPtr 22c:	00000cbd 	.word	0x00000cbd 230:	00001978 	.word	0x00001978 234:	0000197c 	.word	0x0000197c	...			238: R_ARM_ABS32	.rodata.SwapARMDataBuffer			23c: R_ARM_ABS32	.bss.overflowCnt			240: R_ARM_ABS32	.bss.chDataCnt
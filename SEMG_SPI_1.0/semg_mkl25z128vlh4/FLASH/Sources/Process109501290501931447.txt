Sources\Process.o:     file format elf32-littlearmSources\Process.oarchitecture: arm, flags 0x00000011:HAS_RELOC, HAS_SYMSstart address 0x00000000private flags = 5000000: [Version5 EABI]Sections:Idx Name          Size      VMA       LMA       File off  Algn  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC  3 .bss.chDataCnt 00000004  00000000  00000000  00000034  2**2                  ALLOC  4 .bss.overflowCnt 00000001  00000000  00000000  00000034  2**0                  ALLOC  5 .text.MainLoop 0000008c  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  6 .text.ReadADCData 000000e0  00000000  00000000  000000c0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  7 .text.Process 000003a8  00000000  00000000  000001a0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  8 .text.TransmitMCUData 00000078  00000000  00000000  00000548  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  9 .text.SplitRawData 000001ac  00000000  00000000  000005c0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.CopyADCDataToMCUData 000001d0  00000000  00000000  0000076c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.PackData 00000138  00000000  00000000  0000093c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 12 .text.SwapARMDataBuffer 00000230  00000000  00000000  00000a74  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 13 .rodata.SwapARMDataBuffer 00000018  00000000  00000000  00000ca4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 14 .debug_info   00000d07  00000000  00000000  00000cbc  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 15 .debug_abbrev 000001de  00000000  00000000  000019c3  2**0                  CONTENTS, READONLY, DEBUGGING 16 .debug_loc    00000184  00000000  00000000  00001ba1  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 17 .debug_aranges 00000058  00000000  00000000  00001d25  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 18 .debug_macinfo 000450c4  00000000  00000000  00001d7d  2**0                  CONTENTS, READONLY, DEBUGGING 19 .debug_line   00000664  00000000  00000000  00046e41  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 20 .debug_str    00000841  00000000  00000000  000474a5  2**0                  CONTENTS, READONLY, DEBUGGING 21 .comment      0000007a  00000000  00000000  00047ce6  2**0                  CONTENTS, READONLY 22 .ARM.attributes 00000031  00000000  00000000  00047d60  2**0                  CONTENTS, READONLY 23 .debug_frame  00000104  00000000  00000000  00047d94  2**2                  CONTENTS, RELOC, READONLY, DEBUGGINGSYMBOL TABLE:00000000 l    df *ABS*	00000000 Process.c00000000 l    d  .text	00000000 .text00000000 l    d  .data	00000000 .data00000000 l    d  .bss	00000000 .bss00000000 l    d  .bss.chDataCnt	00000000 .bss.chDataCnt00000000 l     O .bss.chDataCnt	00000004 chDataCnt00000000 l    d  .bss.overflowCnt	00000000 .bss.overflowCnt00000000 l     O .bss.overflowCnt	00000001 overflowCnt00000000 l    d  .text.MainLoop	00000000 .text.MainLoop00000000 l     F .text.ReadADCData	000000e0 ReadADCData00000000 l     F .text.Process	000003a8 Process00000000 l    d  .text.ReadADCData	00000000 .text.ReadADCData00000000 l    d  .text.Process	00000000 .text.Process00000000 l     F .text.SplitRawData	000001ac SplitRawData00000000 l     F .text.PackData	00000138 PackData00000000 l    d  .text.TransmitMCUData	00000000 .text.TransmitMCUData00000000 l    d  .text.SplitRawData	00000000 .text.SplitRawData00000000 l    d  .text.CopyADCDataToMCUData	00000000 .text.CopyADCDataToMCUData00000000 l     F .text.CopyADCDataToMCUData	000001d0 CopyADCDataToMCUData00000000 l    d  .text.PackData	00000000 .text.PackData00000000 l    d  .text.SwapARMDataBuffer	00000000 .text.SwapARMDataBuffer00000000 l    d  .rodata.SwapARMDataBuffer	00000000 .rodata.SwapARMDataBuffer00000000 l    d  .debug_info	00000000 .debug_info00000000 l    d  .debug_abbrev	00000000 .debug_abbrev00000000 l    d  .debug_loc	00000000 .debug_loc00000000 l    d  .debug_aranges	00000000 .debug_aranges00000000 l    d  .debug_macinfo	00000000 .debug_macinfo00000000 l    d  .debug_line	00000000 .debug_line00000000 l    d  .debug_str	00000000 .debug_str00000000 l    d  .debug_frame	00000000 .debug_frame00000000 l    d  .comment	00000000 .comment00000000 l    d  .ARM.attributes	00000000 .ARM.attributes00000068       O *COM*	00000004 tADC00000008       O *COM*	00000004 tADCPtr000011a2       O *COM*	00000004 tMCU00000004       O *COM*	00000004 tMCUPtr00001980       O *COM*	00000004 tARM00000004       O *COM*	00000004 tARMPtr00000004       O *COM*	00000004 masterSPI0DevData00000004       O *COM*	00000004 slaveSPI1DevData00000004       O *COM*	00000004 masterSPIRxDMADevData00000004       O *COM*	00000004 masterSPITxDMADevData00000004       O *COM*	00000004 slaveSPIRxDMADevData00000004       O *COM*	00000004 slaveSPITxDMADevData00000004       O *COM*	00000004 dmaControllerDevData00000004       O *COM*	00000004 portA1DevData00000004       O *COM*	00000004 portB2DevData00000004       O *COM*	00000004 portC4DevData00000004       O *COM*	00000004 portE0DevData00000004       O *COM*	00000004 portA5DevData00000004       O *COM*	00000004 portB1DevData00000004       O *COM*	00000004 portC8DevData00000004       O *COM*	00000004 portE1DevData00000004       O *COM*	00000004 portA2DevData00000004       O *COM*	00000004 portE29DevData00000000 g     F .text.MainLoop	0000008c MainLoop00000000         *UND*	00000000 EINT_AD_NOT_DRDY0_Enable00000000         *UND*	00000000 EINT_SYNC_INT_Enable00000000         *UND*	00000000 isStart00000000         *UND*	00000000 EnableADCSPI00000000         *UND*	00000000 ADCReadContinuousData00000000         *UND*	00000000 DisableADCSPI00000000         *UND*	00000000 FirLPF4000000000 g     F .text.TransmitMCUData	00000078 TransmitMCUData00000000         *UND*	00000000 BitIO_UPRDY_SetVal00000000         *UND*	00000000 SPI1SendData00000000         *UND*	00000000 BitIO_UPRDY_ClrVal00000000         *UND*	00000000 RAW_DATA_HEAD00000000         *UND*	00000000 __aeabi_uidivmod00000000 g     F .text.SwapARMDataBuffer	00000230 SwapARMDataBufferDisassembly of section .text.MainLoop:00000000 <MainLoop>: *     @return *          void *//* ===================================================================*/void MainLoop(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;    extern volatile bool isStart;    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = TRUE;   4:	4b1b      	ldr	r3, [pc, #108]	; (74 <MainLoop+0x74>)   6:	681b      	ldr	r3, [r3, #0]   8:	785a      	ldrb	r2, [r3, #1]   a:	2110      	movs	r1, #16   c:	430a      	orrs	r2, r1   e:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = TRUE;  10:	4b18      	ldr	r3, [pc, #96]	; (74 <MainLoop+0x74>)  12:	681b      	ldr	r3, [r3, #0]  14:	785a      	ldrb	r2, [r3, #1]  16:	2108      	movs	r1, #8  18:	430a      	orrs	r2, r1  1a:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI1RxDMATransCompleted = TRUE;  1c:	4b15      	ldr	r3, [pc, #84]	; (74 <MainLoop+0x74>)  1e:	681b      	ldr	r3, [r3, #0]  20:	785a      	ldrb	r2, [r3, #1]  22:	2140      	movs	r1, #64	; 0x40  24:	430a      	orrs	r2, r1  26:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted = TRUE;  28:	4b12      	ldr	r3, [pc, #72]	; (74 <MainLoop+0x74>)  2a:	681b      	ldr	r3, [r3, #0]  2c:	785a      	ldrb	r2, [r3, #1]  2e:	2120      	movs	r1, #32  30:	430a      	orrs	r2, r1  32:	705a      	strb	r2, [r3, #1]//    SPI0_BR = (SPI_BR_SPPR(0x02) | SPI_BR_SPR(0x02));   /* Set baud rage register, 1M */    SPI0_BR = (SPI_BR_SPPR(0x01) | SPI_BR_SPR(0x00)); /* Set baud rate register,6M */  34:	4b10      	ldr	r3, [pc, #64]	; (78 <MainLoop+0x78>)  36:	2210      	movs	r2, #16  38:	709a      	strb	r2, [r3, #2]//    SPI0_BR = (SPI_BR_SPPR(0x00) | SPI_BR_SPR(0x00)); /* Set baud rate register,12M */    /* Enable PortA's interrupt. */    EIntADNotReady0Enable(EINT_AD_NOT_DRDY0);  3a:	4b10      	ldr	r3, [pc, #64]	; (7c <MainLoop+0x7c>)  3c:	681b      	ldr	r3, [r3, #0]  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <EINT_AD_NOT_DRDY0_Enable>			40: R_ARM_THM_CALL	EINT_AD_NOT_DRDY0_Enable//    EIntADNotReady1Enable(EINT_AD_NOT_DRDY1);    EIntSyncInterruptEnable(EINT_SYNC_INT);  44:	4b0e      	ldr	r3, [pc, #56]	; (80 <MainLoop+0x80>)  46:	681b      	ldr	r3, [r3, #0]  48:	1c18      	adds	r0, r3, #0  4a:	f7ff fffe 	bl	0 <EINT_SYNC_INT_Enable>			4a: R_ARM_THM_CALL	EINT_SYNC_INT_Enable    NVIC_ISER |= NVIC_ISER_SETENA(0x40000000);      /* Enable PortA's hardware interrupt */  4e:	4b0d      	ldr	r3, [pc, #52]	; (84 <MainLoop+0x84>)  50:	4a0c      	ldr	r2, [pc, #48]	; (84 <MainLoop+0x84>)  52:	6812      	ldr	r2, [r2, #0]  54:	2180      	movs	r1, #128	; 0x80  56:	05c9      	lsls	r1, r1, #23  58:	430a      	orrs	r2, r1  5a:	601a      	str	r2, [r3, #0]    SwapARMDataBuffer();    GPIOB_PDOR |= 0x06U;    /* B1, B2, start 2 ADCs. */#endif#ifndef TEST    while(!isStart);  5c:	46c0      	nop			; (mov r8, r8)  5e:	4b0a      	ldr	r3, [pc, #40]	; (88 <MainLoop+0x88>)  60:	781b      	ldrb	r3, [r3, #0]  62:	b2db      	uxtb	r3, r3  64:	2b00      	cmp	r3, #0  66:	d0fa      	beq.n	5e <MainLoop+0x5e>//        SwapARMDataBuffer();    /* Swap the data buffer if needed. */#ifdef TEST        IOUploadReadySetVal();#endif        /* If data of ADC is ready, read it. */        ReadADCData();  68:	f7ff fffe 	bl	0 <MainLoop>			68: R_ARM_THM_CALL	ReadADCData#ifdef TEST        IOUploadReadyClrVal();#endif        /* Processing the Data. */        Process();  6c:	f7ff fffe 	bl	0 <MainLoop>			6c: R_ARM_THM_CALL	Process        //Process(eADC1);        /*  If the ARM requires data, transmit. */        //TransmitMCUData();    }  70:	e7fa      	b.n	68 <MainLoop+0x68>  72:	46c0      	nop			; (mov r8, r8)  74:	00000000 	.word	0x00000000			74: R_ARM_ABS32	tMCUPtr  78:	40076000 	.word	0x40076000	...			7c: R_ARM_ABS32	portA1DevData			80: R_ARM_ABS32	portA2DevData  84:	e000e100 	.word	0xe000e100  88:	00000000 	.word	0x00000000			88: R_ARM_ABS32	isStartDisassembly of section .text.ReadADCData:00000000 <ReadADCData>: *     @return *          void *//* ===================================================================*/static void ReadADCData(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0#ifdef TEST    while(!tADCPtr[eADC0]->adcStatus.isDataReady);#endif#ifndef TEST    if(tADCPtr[eADC0]->adcStatus.isDataReady)// && tADCPtr[eADC1]->adcStatus.isDataReady)   4:	4b34      	ldr	r3, [pc, #208]	; (d8 <ReadADCData+0xd8>)   6:	681b      	ldr	r3, [r3, #0]   8:	781b      	ldrb	r3, [r3, #0]   a:	b2da      	uxtb	r2, r3   c:	2301      	movs	r3, #1   e:	4013      	ands	r3, r2  10:	b2db      	uxtb	r3, r3  12:	2b00      	cmp	r3, #0  14:	d05d      	beq.n	d2 <ReadADCData+0xd2>#endif    {        EnableADCSPI(eADC0);  16:	2000      	movs	r0, #0  18:	f7ff fffe 	bl	0 <EnableADCSPI>			18: R_ARM_THM_CALL	EnableADCSPI        ADCReadContinuousData(tADCPtr[eADC0]->adcData.rawData, RAW_DATA_SIZE);  1c:	4b2e      	ldr	r3, [pc, #184]	; (d8 <ReadADCData+0xd8>)  1e:	681b      	ldr	r3, [r3, #0]  20:	3310      	adds	r3, #16  22:	1c18      	adds	r0, r3, #0  24:	2113      	movs	r1, #19  26:	f7ff fffe 	bl	0 <ADCReadContinuousData>			26: R_ARM_THM_CALL	ADCReadContinuousData        tMCUPtr->mcuStatus.isReceivingADCData = TRUE;  2a:	4b2c      	ldr	r3, [pc, #176]	; (dc <ReadADCData+0xdc>)  2c:	681b      	ldr	r3, [r3, #0]  2e:	781a      	ldrb	r2, [r3, #0]  30:	2101      	movs	r1, #1  32:	430a      	orrs	r2, r1  34:	701a      	strb	r2, [r3, #0]//        tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;//        tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;        tADCPtr[eADC0]->adcStatus.adcDataStatus = eReceiving;  36:	4b28      	ldr	r3, [pc, #160]	; (d8 <ReadADCData+0xd8>)  38:	681b      	ldr	r3, [r3, #0]  3a:	2200      	movs	r2, #0  3c:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC0]->adcStatus.transmitionContent = eData;  3e:	4b26      	ldr	r3, [pc, #152]	; (d8 <ReadADCData+0xd8>)  40:	681b      	ldr	r3, [r3, #0]  42:	2201      	movs	r2, #1  44:	705a      	strb	r2, [r3, #1]//        while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);        DisableADCSPI(eADC0);  46:	2000      	movs	r0, #0  48:	f7ff fffe 	bl	0 <DisableADCSPI>			48: R_ARM_THM_CALL	DisableADCSPI        tMCUPtr->mcuStatus.isReceivingADCData = FALSE;  4c:	4b23      	ldr	r3, [pc, #140]	; (dc <ReadADCData+0xdc>)  4e:	681b      	ldr	r3, [r3, #0]  50:	781a      	ldrb	r2, [r3, #0]  52:	2101      	movs	r1, #1  54:	438a      	bics	r2, r1  56:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC0]->adcStatus.isDataReady = FALSE;  58:	4b1f      	ldr	r3, [pc, #124]	; (d8 <ReadADCData+0xd8>)  5a:	681b      	ldr	r3, [r3, #0]  5c:	781a      	ldrb	r2, [r3, #0]  5e:	2101      	movs	r1, #1  60:	438a      	bics	r2, r1  62:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC0]->adcStatus.adcDataStatus = eReceived;  64:	4b1c      	ldr	r3, [pc, #112]	; (d8 <ReadADCData+0xd8>)  66:	681b      	ldr	r3, [r3, #0]  68:	2201      	movs	r2, #1  6a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC0]->adcStatus.transmitionContent = eNothing;  6c:	4b1a      	ldr	r3, [pc, #104]	; (d8 <ReadADCData+0xd8>)  6e:	681b      	ldr	r3, [r3, #0]  70:	22ff      	movs	r2, #255	; 0xff  72:	705a      	strb	r2, [r3, #1]        //Process(eADC0);        EnableADCSPI(eADC1);  74:	2001      	movs	r0, #1  76:	f7ff fffe 	bl	0 <EnableADCSPI>			76: R_ARM_THM_CALL	EnableADCSPI        ADCReadContinuousData(tADCPtr[eADC1]->adcData.rawData, RAW_DATA_SIZE);  7a:	4b17      	ldr	r3, [pc, #92]	; (d8 <ReadADCData+0xd8>)  7c:	685b      	ldr	r3, [r3, #4]  7e:	3310      	adds	r3, #16  80:	1c18      	adds	r0, r3, #0  82:	2113      	movs	r1, #19  84:	f7ff fffe 	bl	0 <ADCReadContinuousData>			84: R_ARM_THM_CALL	ADCReadContinuousData        tMCUPtr->mcuStatus.isReceivingADCData = TRUE;  88:	4b14      	ldr	r3, [pc, #80]	; (dc <ReadADCData+0xdc>)  8a:	681b      	ldr	r3, [r3, #0]  8c:	781a      	ldrb	r2, [r3, #0]  8e:	2101      	movs	r1, #1  90:	430a      	orrs	r2, r1  92:	701a      	strb	r2, [r3, #0]//        tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;//        tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;        tADCPtr[eADC1]->adcStatus.adcDataStatus = eReceiving;  94:	4b10      	ldr	r3, [pc, #64]	; (d8 <ReadADCData+0xd8>)  96:	685b      	ldr	r3, [r3, #4]  98:	2200      	movs	r2, #0  9a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.transmitionContent = eData;  9c:	4b0e      	ldr	r3, [pc, #56]	; (d8 <ReadADCData+0xd8>)  9e:	685b      	ldr	r3, [r3, #4]  a0:	2201      	movs	r2, #1  a2:	705a      	strb	r2, [r3, #1]//        while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);        DisableADCSPI(eADC1);  a4:	2001      	movs	r0, #1  a6:	f7ff fffe 	bl	0 <DisableADCSPI>			a6: R_ARM_THM_CALL	DisableADCSPI        tMCUPtr->mcuStatus.isReceivingADCData = FALSE;  aa:	4b0c      	ldr	r3, [pc, #48]	; (dc <ReadADCData+0xdc>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	781a      	ldrb	r2, [r3, #0]  b0:	2101      	movs	r1, #1  b2:	438a      	bics	r2, r1  b4:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC1]->adcStatus.isDataReady = FALSE;  b6:	4b08      	ldr	r3, [pc, #32]	; (d8 <ReadADCData+0xd8>)  b8:	685b      	ldr	r3, [r3, #4]  ba:	781a      	ldrb	r2, [r3, #0]  bc:	2101      	movs	r1, #1  be:	438a      	bics	r2, r1  c0:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC1]->adcStatus.adcDataStatus = eReceived;  c2:	4b05      	ldr	r3, [pc, #20]	; (d8 <ReadADCData+0xd8>)  c4:	685b      	ldr	r3, [r3, #4]  c6:	2201      	movs	r2, #1  c8:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.transmitionContent = eNothing;  ca:	4b03      	ldr	r3, [pc, #12]	; (d8 <ReadADCData+0xd8>)  cc:	685b      	ldr	r3, [r3, #4]  ce:	22ff      	movs	r2, #255	; 0xff  d0:	705a      	strb	r2, [r3, #1]//        tADCPtr[adcFlag]->adcStatus.adcDataStatus = eReceived;//        tADCPtr[adcFlag]->adcStatus.transmitionContent = eNothing;////        Process(adcFlag);//    }}  d2:	46bd      	mov	sp, r7  d4:	bd80      	pop	{r7, pc}  d6:	46c0      	nop			; (mov r8, r8)	...			d8: R_ARM_ABS32	tADCPtr			dc: R_ARM_ABS32	tMCUPtrDisassembly of section .text.Process:00000000 <Process>: *     @return *          void *//* ===================================================================*/static void Process(void){   0:	b5b0      	push	{r4, r5, r7, lr}   2:	af00      	add	r7, sp, #0    extern TADCPtr tADCPtr[USING_ADC_COUNT];    if(eReceived == tADCPtr[eADC0]->adcStatus.adcDataStatus   4:	4bd3      	ldr	r3, [pc, #844]	; (354 <Process+0x354>)   6:	681b      	ldr	r3, [r3, #0]   8:	789b      	ldrb	r3, [r3, #2]   a:	b2db      	uxtb	r3, r3   c:	b25b      	sxtb	r3, r3   e:	2b01      	cmp	r3, #1  10:	d000      	beq.n	14 <Process+0x14>  12:	e19c      	b.n	34e <Process+0x34e>            && eReceived == tADCPtr[eADC0]->adcStatus.adcDataStatus)  14:	4bcf      	ldr	r3, [pc, #828]	; (354 <Process+0x354>)  16:	681b      	ldr	r3, [r3, #0]  18:	789b      	ldrb	r3, [r3, #2]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	2b01      	cmp	r3, #1  20:	d000      	beq.n	24 <Process+0x24>  22:	e194      	b.n	34e <Process+0x34e>    {        SplitRawData();  24:	f7ff fffe 	bl	0 <Process>			24: R_ARM_THM_CALL	SplitRawData        tADCPtr[eADC0]->adcStatus.adcDataStatus = eIdle;  28:	4bca      	ldr	r3, [pc, #808]	; (354 <Process+0x354>)  2a:	681b      	ldr	r3, [r3, #0]  2c:	22ff      	movs	r2, #255	; 0xff  2e:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.adcDataStatus = eIdle;  30:	4bc8      	ldr	r3, [pc, #800]	; (354 <Process+0x354>)  32:	685b      	ldr	r3, [r3, #4]  34:	22ff      	movs	r2, #255	; 0xff  36:	709a      	strb	r2, [r3, #2]        //CopyADCDataToMCUData();        tMCUPtr->mcuData.channelData[0][0][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[0], tMCUPtr->mcuData.filteredBuffer[0][0]);  38:	4bc7      	ldr	r3, [pc, #796]	; (358 <Process+0x358>)  3a:	681c      	ldr	r4, [r3, #0]  3c:	4bc7      	ldr	r3, [pc, #796]	; (35c <Process+0x35c>)  3e:	681d      	ldr	r5, [r3, #0]  40:	4bc4      	ldr	r3, [pc, #784]	; (354 <Process+0x354>)  42:	681b      	ldr	r3, [r3, #0]  44:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  46:	4bc4      	ldr	r3, [pc, #784]	; (358 <Process+0x358>)  48:	681b      	ldr	r3, [r3, #0]  4a:	49c5      	ldr	r1, [pc, #788]	; (360 <Process+0x360>)  4c:	185b      	adds	r3, r3, r1  4e:	b212      	sxth	r2, r2  50:	1c10      	adds	r0, r2, #0  52:	1c19      	adds	r1, r3, #0  54:	f7ff fffe 	bl	0 <FirLPF40>			54: R_ARM_THM_CALL	FirLPF40  58:	1c03      	adds	r3, r0, #0  5a:	b29a      	uxth	r2, r3  5c:	006b      	lsls	r3, r5, #1  5e:	18e3      	adds	r3, r4, r3  60:	3302      	adds	r3, #2  62:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][1][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[1], tMCUPtr->mcuData.filteredBuffer[0][1]);  64:	4bbc      	ldr	r3, [pc, #752]	; (358 <Process+0x358>)  66:	681c      	ldr	r4, [r3, #0]  68:	4bbc      	ldr	r3, [pc, #752]	; (35c <Process+0x35c>)  6a:	681d      	ldr	r5, [r3, #0]  6c:	4bb9      	ldr	r3, [pc, #740]	; (354 <Process+0x354>)  6e:	681b      	ldr	r3, [r3, #0]  70:	8cda      	ldrh	r2, [r3, #38]	; 0x26  72:	4bb9      	ldr	r3, [pc, #740]	; (358 <Process+0x358>)  74:	681b      	ldr	r3, [r3, #0]  76:	49bb      	ldr	r1, [pc, #748]	; (364 <Process+0x364>)  78:	185b      	adds	r3, r3, r1  7a:	b212      	sxth	r2, r2  7c:	1c10      	adds	r0, r2, #0  7e:	1c19      	adds	r1, r3, #0  80:	f7ff fffe 	bl	0 <FirLPF40>			80: R_ARM_THM_CALL	FirLPF40  84:	1c03      	adds	r3, r0, #0  86:	b29a      	uxth	r2, r3  88:	1c2b      	adds	r3, r5, #0  8a:	3364      	adds	r3, #100	; 0x64  8c:	005b      	lsls	r3, r3, #1  8e:	18e3      	adds	r3, r4, r3  90:	3302      	adds	r3, #2  92:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][2][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[2], tMCUPtr->mcuData.filteredBuffer[0][2]);  94:	4bb0      	ldr	r3, [pc, #704]	; (358 <Process+0x358>)  96:	681c      	ldr	r4, [r3, #0]  98:	4bb0      	ldr	r3, [pc, #704]	; (35c <Process+0x35c>)  9a:	681d      	ldr	r5, [r3, #0]  9c:	4bad      	ldr	r3, [pc, #692]	; (354 <Process+0x354>)  9e:	681b      	ldr	r3, [r3, #0]  a0:	8d1a      	ldrh	r2, [r3, #40]	; 0x28  a2:	4bad      	ldr	r3, [pc, #692]	; (358 <Process+0x358>)  a4:	681b      	ldr	r3, [r3, #0]  a6:	49b0      	ldr	r1, [pc, #704]	; (368 <Process+0x368>)  a8:	185b      	adds	r3, r3, r1  aa:	b212      	sxth	r2, r2  ac:	1c10      	adds	r0, r2, #0  ae:	1c19      	adds	r1, r3, #0  b0:	f7ff fffe 	bl	0 <FirLPF40>			b0: R_ARM_THM_CALL	FirLPF40  b4:	1c03      	adds	r3, r0, #0  b6:	b29a      	uxth	r2, r3  b8:	1c2b      	adds	r3, r5, #0  ba:	33c8      	adds	r3, #200	; 0xc8  bc:	005b      	lsls	r3, r3, #1  be:	18e3      	adds	r3, r4, r3  c0:	3302      	adds	r3, #2  c2:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][3][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[3], tMCUPtr->mcuData.filteredBuffer[0][3]);  c4:	4ba4      	ldr	r3, [pc, #656]	; (358 <Process+0x358>)  c6:	681c      	ldr	r4, [r3, #0]  c8:	4ba4      	ldr	r3, [pc, #656]	; (35c <Process+0x35c>)  ca:	681d      	ldr	r5, [r3, #0]  cc:	4ba1      	ldr	r3, [pc, #644]	; (354 <Process+0x354>)  ce:	681b      	ldr	r3, [r3, #0]  d0:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a  d2:	4ba1      	ldr	r3, [pc, #644]	; (358 <Process+0x358>)  d4:	681b      	ldr	r3, [r3, #0]  d6:	49a5      	ldr	r1, [pc, #660]	; (36c <Process+0x36c>)  d8:	185b      	adds	r3, r3, r1  da:	b212      	sxth	r2, r2  dc:	1c10      	adds	r0, r2, #0  de:	1c19      	adds	r1, r3, #0  e0:	f7ff fffe 	bl	0 <FirLPF40>			e0: R_ARM_THM_CALL	FirLPF40  e4:	1c03      	adds	r3, r0, #0  e6:	b29a      	uxth	r2, r3  e8:	2196      	movs	r1, #150	; 0x96  ea:	0049      	lsls	r1, r1, #1  ec:	186b      	adds	r3, r5, r1  ee:	005b      	lsls	r3, r3, #1  f0:	18e3      	adds	r3, r4, r3  f2:	3302      	adds	r3, #2  f4:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][4][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[4], tMCUPtr->mcuData.filteredBuffer[0][4]);  f6:	4b98      	ldr	r3, [pc, #608]	; (358 <Process+0x358>)  f8:	681c      	ldr	r4, [r3, #0]  fa:	4b98      	ldr	r3, [pc, #608]	; (35c <Process+0x35c>)  fc:	681d      	ldr	r5, [r3, #0]  fe:	4b95      	ldr	r3, [pc, #596]	; (354 <Process+0x354>) 100:	681b      	ldr	r3, [r3, #0] 102:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c 104:	4b94      	ldr	r3, [pc, #592]	; (358 <Process+0x358>) 106:	681b      	ldr	r3, [r3, #0] 108:	4999      	ldr	r1, [pc, #612]	; (370 <Process+0x370>) 10a:	185b      	adds	r3, r3, r1 10c:	b212      	sxth	r2, r2 10e:	1c10      	adds	r0, r2, #0 110:	1c19      	adds	r1, r3, #0 112:	f7ff fffe 	bl	0 <FirLPF40>			112: R_ARM_THM_CALL	FirLPF40 116:	1c03      	adds	r3, r0, #0 118:	b29a      	uxth	r2, r3 11a:	21c8      	movs	r1, #200	; 0xc8 11c:	0049      	lsls	r1, r1, #1 11e:	186b      	adds	r3, r5, r1 120:	005b      	lsls	r3, r3, #1 122:	18e3      	adds	r3, r4, r3 124:	3302      	adds	r3, #2 126:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][5][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[5], tMCUPtr->mcuData.filteredBuffer[0][5]); 128:	4b8b      	ldr	r3, [pc, #556]	; (358 <Process+0x358>) 12a:	681c      	ldr	r4, [r3, #0] 12c:	4b8b      	ldr	r3, [pc, #556]	; (35c <Process+0x35c>) 12e:	681d      	ldr	r5, [r3, #0] 130:	4b88      	ldr	r3, [pc, #544]	; (354 <Process+0x354>) 132:	681b      	ldr	r3, [r3, #0] 134:	8dda      	ldrh	r2, [r3, #46]	; 0x2e 136:	4b88      	ldr	r3, [pc, #544]	; (358 <Process+0x358>) 138:	681b      	ldr	r3, [r3, #0] 13a:	498e      	ldr	r1, [pc, #568]	; (374 <Process+0x374>) 13c:	185b      	adds	r3, r3, r1 13e:	b212      	sxth	r2, r2 140:	1c10      	adds	r0, r2, #0 142:	1c19      	adds	r1, r3, #0 144:	f7ff fffe 	bl	0 <FirLPF40>			144: R_ARM_THM_CALL	FirLPF40 148:	1c03      	adds	r3, r0, #0 14a:	b29a      	uxth	r2, r3 14c:	21fa      	movs	r1, #250	; 0xfa 14e:	0049      	lsls	r1, r1, #1 150:	186b      	adds	r3, r5, r1 152:	005b      	lsls	r3, r3, #1 154:	18e3      	adds	r3, r4, r3 156:	3302      	adds	r3, #2 158:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][6][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[6], tMCUPtr->mcuData.filteredBuffer[0][6]); 15a:	4b7f      	ldr	r3, [pc, #508]	; (358 <Process+0x358>) 15c:	681c      	ldr	r4, [r3, #0] 15e:	4b7f      	ldr	r3, [pc, #508]	; (35c <Process+0x35c>) 160:	681d      	ldr	r5, [r3, #0] 162:	4b7c      	ldr	r3, [pc, #496]	; (354 <Process+0x354>) 164:	681b      	ldr	r3, [r3, #0] 166:	8e1a      	ldrh	r2, [r3, #48]	; 0x30 168:	4b7b      	ldr	r3, [pc, #492]	; (358 <Process+0x358>) 16a:	681b      	ldr	r3, [r3, #0] 16c:	4982      	ldr	r1, [pc, #520]	; (378 <Process+0x378>) 16e:	185b      	adds	r3, r3, r1 170:	b212      	sxth	r2, r2 172:	1c10      	adds	r0, r2, #0 174:	1c19      	adds	r1, r3, #0 176:	f7ff fffe 	bl	0 <FirLPF40>			176: R_ARM_THM_CALL	FirLPF40 17a:	1c03      	adds	r3, r0, #0 17c:	b29a      	uxth	r2, r3 17e:	2196      	movs	r1, #150	; 0x96 180:	0089      	lsls	r1, r1, #2 182:	186b      	adds	r3, r5, r1 184:	005b      	lsls	r3, r3, #1 186:	18e3      	adds	r3, r4, r3 188:	3302      	adds	r3, #2 18a:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[0][7][chDataCnt] = FirLPF40(tADCPtr[0]->adcData.channelData[7], tMCUPtr->mcuData.filteredBuffer[0][7]); 18c:	4b72      	ldr	r3, [pc, #456]	; (358 <Process+0x358>) 18e:	681c      	ldr	r4, [r3, #0] 190:	4b72      	ldr	r3, [pc, #456]	; (35c <Process+0x35c>) 192:	681d      	ldr	r5, [r3, #0] 194:	4b6f      	ldr	r3, [pc, #444]	; (354 <Process+0x354>) 196:	681b      	ldr	r3, [r3, #0] 198:	8e5a      	ldrh	r2, [r3, #50]	; 0x32 19a:	4b6f      	ldr	r3, [pc, #444]	; (358 <Process+0x358>) 19c:	681b      	ldr	r3, [r3, #0] 19e:	21ec      	movs	r1, #236	; 0xec 1a0:	0109      	lsls	r1, r1, #4 1a2:	185b      	adds	r3, r3, r1 1a4:	b212      	sxth	r2, r2 1a6:	1c10      	adds	r0, r2, #0 1a8:	1c19      	adds	r1, r3, #0 1aa:	f7ff fffe 	bl	0 <FirLPF40>			1aa: R_ARM_THM_CALL	FirLPF40 1ae:	1c03      	adds	r3, r0, #0 1b0:	b29a      	uxth	r2, r3 1b2:	21af      	movs	r1, #175	; 0xaf 1b4:	0089      	lsls	r1, r1, #2 1b6:	186b      	adds	r3, r5, r1 1b8:	005b      	lsls	r3, r3, #1 1ba:	18e3      	adds	r3, r4, r3 1bc:	3302      	adds	r3, #2 1be:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][0][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[0], tMCUPtr->mcuData.filteredBuffer[1][0]); 1c0:	4b65      	ldr	r3, [pc, #404]	; (358 <Process+0x358>) 1c2:	681c      	ldr	r4, [r3, #0] 1c4:	4b65      	ldr	r3, [pc, #404]	; (35c <Process+0x35c>) 1c6:	681d      	ldr	r5, [r3, #0] 1c8:	4b62      	ldr	r3, [pc, #392]	; (354 <Process+0x354>) 1ca:	685b      	ldr	r3, [r3, #4] 1cc:	8c9a      	ldrh	r2, [r3, #36]	; 0x24 1ce:	4b62      	ldr	r3, [pc, #392]	; (358 <Process+0x358>) 1d0:	681b      	ldr	r3, [r3, #0] 1d2:	496a      	ldr	r1, [pc, #424]	; (37c <Process+0x37c>) 1d4:	185b      	adds	r3, r3, r1 1d6:	b212      	sxth	r2, r2 1d8:	1c10      	adds	r0, r2, #0 1da:	1c19      	adds	r1, r3, #0 1dc:	f7ff fffe 	bl	0 <FirLPF40>			1dc: R_ARM_THM_CALL	FirLPF40 1e0:	1c03      	adds	r3, r0, #0 1e2:	b29a      	uxth	r2, r3 1e4:	21c8      	movs	r1, #200	; 0xc8 1e6:	0089      	lsls	r1, r1, #2 1e8:	186b      	adds	r3, r5, r1 1ea:	005b      	lsls	r3, r3, #1 1ec:	18e3      	adds	r3, r4, r3 1ee:	3302      	adds	r3, #2 1f0:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][1][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[1], tMCUPtr->mcuData.filteredBuffer[1][1]); 1f2:	4b59      	ldr	r3, [pc, #356]	; (358 <Process+0x358>) 1f4:	681c      	ldr	r4, [r3, #0] 1f6:	4b59      	ldr	r3, [pc, #356]	; (35c <Process+0x35c>) 1f8:	681d      	ldr	r5, [r3, #0] 1fa:	4b56      	ldr	r3, [pc, #344]	; (354 <Process+0x354>) 1fc:	685b      	ldr	r3, [r3, #4] 1fe:	8cda      	ldrh	r2, [r3, #38]	; 0x26 200:	4b55      	ldr	r3, [pc, #340]	; (358 <Process+0x358>) 202:	681b      	ldr	r3, [r3, #0] 204:	495e      	ldr	r1, [pc, #376]	; (380 <Process+0x380>) 206:	185b      	adds	r3, r3, r1 208:	b212      	sxth	r2, r2 20a:	1c10      	adds	r0, r2, #0 20c:	1c19      	adds	r1, r3, #0 20e:	f7ff fffe 	bl	0 <FirLPF40>			20e: R_ARM_THM_CALL	FirLPF40 212:	1c03      	adds	r3, r0, #0 214:	b29a      	uxth	r2, r3 216:	21e1      	movs	r1, #225	; 0xe1 218:	0089      	lsls	r1, r1, #2 21a:	186b      	adds	r3, r5, r1 21c:	005b      	lsls	r3, r3, #1 21e:	18e3      	adds	r3, r4, r3 220:	3302      	adds	r3, #2 222:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][2][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[2], tMCUPtr->mcuData.filteredBuffer[1][2]); 224:	4b4c      	ldr	r3, [pc, #304]	; (358 <Process+0x358>) 226:	681c      	ldr	r4, [r3, #0] 228:	4b4c      	ldr	r3, [pc, #304]	; (35c <Process+0x35c>) 22a:	681d      	ldr	r5, [r3, #0] 22c:	4b49      	ldr	r3, [pc, #292]	; (354 <Process+0x354>) 22e:	685b      	ldr	r3, [r3, #4] 230:	8d1a      	ldrh	r2, [r3, #40]	; 0x28 232:	4b49      	ldr	r3, [pc, #292]	; (358 <Process+0x358>) 234:	681b      	ldr	r3, [r3, #0] 236:	4953      	ldr	r1, [pc, #332]	; (384 <Process+0x384>) 238:	185b      	adds	r3, r3, r1 23a:	b212      	sxth	r2, r2 23c:	1c10      	adds	r0, r2, #0 23e:	1c19      	adds	r1, r3, #0 240:	f7ff fffe 	bl	0 <FirLPF40>			240: R_ARM_THM_CALL	FirLPF40 244:	1c03      	adds	r3, r0, #0 246:	b29a      	uxth	r2, r3 248:	21fa      	movs	r1, #250	; 0xfa 24a:	0089      	lsls	r1, r1, #2 24c:	186b      	adds	r3, r5, r1 24e:	005b      	lsls	r3, r3, #1 250:	18e3      	adds	r3, r4, r3 252:	3302      	adds	r3, #2 254:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][3][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[3], tMCUPtr->mcuData.filteredBuffer[1][3]); 256:	4b40      	ldr	r3, [pc, #256]	; (358 <Process+0x358>) 258:	681c      	ldr	r4, [r3, #0] 25a:	4b40      	ldr	r3, [pc, #256]	; (35c <Process+0x35c>) 25c:	681d      	ldr	r5, [r3, #0] 25e:	4b3d      	ldr	r3, [pc, #244]	; (354 <Process+0x354>) 260:	685b      	ldr	r3, [r3, #4] 262:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a 264:	4b3c      	ldr	r3, [pc, #240]	; (358 <Process+0x358>) 266:	681b      	ldr	r3, [r3, #0] 268:	4947      	ldr	r1, [pc, #284]	; (388 <Process+0x388>) 26a:	185b      	adds	r3, r3, r1 26c:	b212      	sxth	r2, r2 26e:	1c10      	adds	r0, r2, #0 270:	1c19      	adds	r1, r3, #0 272:	f7ff fffe 	bl	0 <FirLPF40>			272: R_ARM_THM_CALL	FirLPF40 276:	1c03      	adds	r3, r0, #0 278:	b29a      	uxth	r2, r3 27a:	4944      	ldr	r1, [pc, #272]	; (38c <Process+0x38c>) 27c:	186b      	adds	r3, r5, r1 27e:	005b      	lsls	r3, r3, #1 280:	18e3      	adds	r3, r4, r3 282:	3302      	adds	r3, #2 284:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][4][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[4], tMCUPtr->mcuData.filteredBuffer[1][4]); 286:	4b34      	ldr	r3, [pc, #208]	; (358 <Process+0x358>) 288:	681c      	ldr	r4, [r3, #0] 28a:	4b34      	ldr	r3, [pc, #208]	; (35c <Process+0x35c>) 28c:	681d      	ldr	r5, [r3, #0] 28e:	4b31      	ldr	r3, [pc, #196]	; (354 <Process+0x354>) 290:	685b      	ldr	r3, [r3, #4] 292:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c 294:	4b30      	ldr	r3, [pc, #192]	; (358 <Process+0x358>) 296:	681b      	ldr	r3, [r3, #0] 298:	493d      	ldr	r1, [pc, #244]	; (390 <Process+0x390>) 29a:	185b      	adds	r3, r3, r1 29c:	b212      	sxth	r2, r2 29e:	1c10      	adds	r0, r2, #0 2a0:	1c19      	adds	r1, r3, #0 2a2:	f7ff fffe 	bl	0 <FirLPF40>			2a2: R_ARM_THM_CALL	FirLPF40 2a6:	1c03      	adds	r3, r0, #0 2a8:	b29a      	uxth	r2, r3 2aa:	2196      	movs	r1, #150	; 0x96 2ac:	00c9      	lsls	r1, r1, #3 2ae:	186b      	adds	r3, r5, r1 2b0:	005b      	lsls	r3, r3, #1 2b2:	18e3      	adds	r3, r4, r3 2b4:	3302      	adds	r3, #2 2b6:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][5][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[5], tMCUPtr->mcuData.filteredBuffer[1][5]); 2b8:	4b27      	ldr	r3, [pc, #156]	; (358 <Process+0x358>) 2ba:	681c      	ldr	r4, [r3, #0] 2bc:	4b27      	ldr	r3, [pc, #156]	; (35c <Process+0x35c>) 2be:	681d      	ldr	r5, [r3, #0] 2c0:	4b24      	ldr	r3, [pc, #144]	; (354 <Process+0x354>) 2c2:	685b      	ldr	r3, [r3, #4] 2c4:	8dda      	ldrh	r2, [r3, #46]	; 0x2e 2c6:	4b24      	ldr	r3, [pc, #144]	; (358 <Process+0x358>) 2c8:	681b      	ldr	r3, [r3, #0] 2ca:	4932      	ldr	r1, [pc, #200]	; (394 <Process+0x394>) 2cc:	185b      	adds	r3, r3, r1 2ce:	b212      	sxth	r2, r2 2d0:	1c10      	adds	r0, r2, #0 2d2:	1c19      	adds	r1, r3, #0 2d4:	f7ff fffe 	bl	0 <FirLPF40>			2d4: R_ARM_THM_CALL	FirLPF40 2d8:	1c03      	adds	r3, r0, #0 2da:	b29a      	uxth	r2, r3 2dc:	492e      	ldr	r1, [pc, #184]	; (398 <Process+0x398>) 2de:	186b      	adds	r3, r5, r1 2e0:	005b      	lsls	r3, r3, #1 2e2:	18e3      	adds	r3, r4, r3 2e4:	3302      	adds	r3, #2 2e6:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][6][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[6], tMCUPtr->mcuData.filteredBuffer[1][6]); 2e8:	4b1b      	ldr	r3, [pc, #108]	; (358 <Process+0x358>) 2ea:	681c      	ldr	r4, [r3, #0] 2ec:	4b1b      	ldr	r3, [pc, #108]	; (35c <Process+0x35c>) 2ee:	681d      	ldr	r5, [r3, #0] 2f0:	4b18      	ldr	r3, [pc, #96]	; (354 <Process+0x354>) 2f2:	685b      	ldr	r3, [r3, #4] 2f4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30 2f6:	4b18      	ldr	r3, [pc, #96]	; (358 <Process+0x358>) 2f8:	681b      	ldr	r3, [r3, #0] 2fa:	4928      	ldr	r1, [pc, #160]	; (39c <Process+0x39c>) 2fc:	185b      	adds	r3, r3, r1 2fe:	b212      	sxth	r2, r2 300:	1c10      	adds	r0, r2, #0 302:	1c19      	adds	r1, r3, #0 304:	f7ff fffe 	bl	0 <FirLPF40>			304: R_ARM_THM_CALL	FirLPF40 308:	1c03      	adds	r3, r0, #0 30a:	b29a      	uxth	r2, r3 30c:	21af      	movs	r1, #175	; 0xaf 30e:	00c9      	lsls	r1, r1, #3 310:	186b      	adds	r3, r5, r1 312:	005b      	lsls	r3, r3, #1 314:	18e3      	adds	r3, r4, r3 316:	3302      	adds	r3, #2 318:	801a      	strh	r2, [r3, #0]        tMCUPtr->mcuData.channelData[1][7][chDataCnt] = FirLPF40(tADCPtr[1]->adcData.channelData[7], tMCUPtr->mcuData.filteredBuffer[1][7]); 31a:	4b0f      	ldr	r3, [pc, #60]	; (358 <Process+0x358>) 31c:	681c      	ldr	r4, [r3, #0] 31e:	4b0f      	ldr	r3, [pc, #60]	; (35c <Process+0x35c>) 320:	681d      	ldr	r5, [r3, #0] 322:	4b0c      	ldr	r3, [pc, #48]	; (354 <Process+0x354>) 324:	685b      	ldr	r3, [r3, #4] 326:	8e5a      	ldrh	r2, [r3, #50]	; 0x32 328:	4b0b      	ldr	r3, [pc, #44]	; (358 <Process+0x358>) 32a:	681b      	ldr	r3, [r3, #0] 32c:	491c      	ldr	r1, [pc, #112]	; (3a0 <Process+0x3a0>) 32e:	185b      	adds	r3, r3, r1 330:	b212      	sxth	r2, r2 332:	1c10      	adds	r0, r2, #0 334:	1c19      	adds	r1, r3, #0 336:	f7ff fffe 	bl	0 <FirLPF40>			336: R_ARM_THM_CALL	FirLPF40 33a:	1c03      	adds	r3, r0, #0 33c:	b29a      	uxth	r2, r3 33e:	4919      	ldr	r1, [pc, #100]	; (3a4 <Process+0x3a4>) 340:	186b      	adds	r3, r5, r1 342:	005b      	lsls	r3, r3, #1 344:	18e3      	adds	r3, r4, r3 346:	3302      	adds	r3, #2 348:	801a      	strh	r2, [r3, #0]        PackData(); 34a:	f7ff fffe 	bl	0 <Process>			34a: R_ARM_THM_CALL	PackData    }} 34e:	46bd      	mov	sp, r7 350:	bdb0      	pop	{r4, r5, r7, pc} 352:	46c0      	nop			; (mov r8, r8)	...			354: R_ARM_ABS32	tADCPtr			358: R_ARM_ABS32	tMCUPtr			35c: R_ARM_ABS32	.bss.chDataCnt 360:	00000c82 	.word	0x00000c82 364:	00000cd4 	.word	0x00000cd4 368:	00000d26 	.word	0x00000d26 36c:	00000d78 	.word	0x00000d78 370:	00000dca 	.word	0x00000dca 374:	00000e1c 	.word	0x00000e1c 378:	00000e6e 	.word	0x00000e6e 37c:	00000f12 	.word	0x00000f12 380:	00000f64 	.word	0x00000f64 384:	00000fb6 	.word	0x00000fb6 388:	00001008 	.word	0x00001008 38c:	0000044c 	.word	0x0000044c 390:	0000105a 	.word	0x0000105a 394:	000010ac 	.word	0x000010ac 398:	00000514 	.word	0x00000514 39c:	000010fe 	.word	0x000010fe 3a0:	00001150 	.word	0x00001150 3a4:	000005dc 	.word	0x000005dcDisassembly of section .text.TransmitMCUData:00000000 <TransmitMCUData>: *     @return *          void *//* ===================================================================*/void TransmitMCUData(void){   0:	af00b580 	.word	0xaf00b580    //if(//tARMPtr->armStatus.isRequiringData &&            //tARMPtr->armStatus.isUploadReady &&                //tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted)    //{        tARMPtr->armStatus.isRequiringData = FALSE;   4:	4b17      	ldr	r3, [pc, #92]	; (64 <TransmitMCUData+0x64>)   6:	681b      	ldr	r3, [r3, #0]   8:	781a      	ldrb	r2, [r3, #0]   a:	2101      	movs	r1, #1   c:	438a      	bics	r2, r1   e:	701a      	strb	r2, [r3, #0]        tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted = FALSE;  10:	4b15      	ldr	r3, [pc, #84]	; (68 <TransmitMCUData+0x68>)  12:	681b      	ldr	r3, [r3, #0]  14:	785a      	ldrb	r2, [r3, #1]  16:	2120      	movs	r1, #32  18:	438a      	bics	r2, r1  1a:	705a      	strb	r2, [r3, #1]        IOUploadReadySetVal();  1c:	4b13      	ldr	r3, [pc, #76]	; (6c <TransmitMCUData+0x6c>)  1e:	681b      	ldr	r3, [r3, #0]  20:	1c18      	adds	r0, r3, #0  22:	f7ff fffe 	bl	0 <BitIO_UPRDY_SetVal>			22: R_ARM_THM_CALL	BitIO_UPRDY_SetVal        SPI1SendData((LDD_DMA_TAddress)tARMPtr->foreBuffer, DATA_FRAME_LENGTH + 1);  26:	4b0f      	ldr	r3, [pc, #60]	; (64 <TransmitMCUData+0x64>)  28:	681a      	ldr	r2, [r3, #0]  2a:	4b11      	ldr	r3, [pc, #68]	; (70 <TransmitMCUData+0x70>)  2c:	58d3      	ldr	r3, [r2, r3]  2e:	1c1a      	adds	r2, r3, #0  30:	4b10      	ldr	r3, [pc, #64]	; (74 <TransmitMCUData+0x74>)  32:	1c10      	adds	r0, r2, #0  34:	1c19      	adds	r1, r3, #0  36:	f7ff fffe 	bl	0 <SPI1SendData>			36: R_ARM_THM_CALL	SPI1SendData        IOUploadReadyClrVal();  3a:	4b0c      	ldr	r3, [pc, #48]	; (6c <TransmitMCUData+0x6c>)  3c:	681b      	ldr	r3, [r3, #0]  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <BitIO_UPRDY_ClrVal>			40: R_ARM_THM_CALL	BitIO_UPRDY_ClrVal        //tARMPtr->armStatus.isTransmittingData = TRUE;        tARMPtr->armStatus.transmitionContent = eData;  44:	4b07      	ldr	r3, [pc, #28]	; (64 <TransmitMCUData+0x64>)  46:	681b      	ldr	r3, [r3, #0]  48:	2201      	movs	r2, #1  4a:	705a      	strb	r2, [r3, #1]//        tARMPtr->armStatus.isForeBufferEmpty = FALSE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eRead;  4c:	4b05      	ldr	r3, [pc, #20]	; (64 <TransmitMCUData+0x64>)  4e:	681b      	ldr	r3, [r3, #0]  50:	2201      	movs	r2, #1  52:	709a      	strb	r2, [r3, #2]        tARMPtr->armStatus.isUploadReady = FALSE;  54:	4b03      	ldr	r3, [pc, #12]	; (64 <TransmitMCUData+0x64>)  56:	681b      	ldr	r3, [r3, #0]  58:	781a      	ldrb	r2, [r3, #0]  5a:	2102      	movs	r1, #2  5c:	438a      	bics	r2, r1  5e:	701a      	strb	r2, [r3, #0]    //}}  60:	46bd      	mov	sp, r7  62:	bd80      	pop	{r7, pc}	...			64: R_ARM_ABS32	tARMPtr			68: R_ARM_ABS32	tMCUPtr			6c: R_ARM_ABS32	portE29DevData  70:	00001978 	.word	0x00001978  74:	00000cba 	.word	0x00000cbaDisassembly of section .text.SplitRawData:00000000 <SplitRawData>: *         	                                  so the data is invalid. *         	                - ERR_OK: Succeeded to split. *//* ===================================================================*/static LDD_TError SplitRawData(void){   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0    byte loffStatP;    byte loffStatN;    byte regGPIOData;    int16 channelData;    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)   6:	2300      	movs	r3, #0   8:	617b      	str	r3, [r7, #20]   a:	e0c2      	b.n	192 <SplitRawData+0x192>    {        head = ((tADCPtr[adcNum]->adcData.rawData[0] & 0xF0) >> 4) & 0x0F;       /* Split head byte from raw data. */   c:	4b65      	ldr	r3, [pc, #404]	; (1a4 <SplitRawData+0x1a4>)   e:	697a      	ldr	r2, [r7, #20]  10:	0092      	lsls	r2, r2, #2  12:	58d3      	ldr	r3, [r2, r3]  14:	7c1a      	ldrb	r2, [r3, #16]  16:	1c3b      	adds	r3, r7, #0  18:	330f      	adds	r3, #15  1a:	0912      	lsrs	r2, r2, #4  1c:	701a      	strb	r2, [r3, #0]        if(head != RAW_DATA_HEAD)                                   /* If the head byte is not right(0x0C), return with error. */  1e:	4b62      	ldr	r3, [pc, #392]	; (1a8 <SplitRawData+0x1a8>)  20:	781b      	ldrb	r3, [r3, #0]  22:	1c3a      	adds	r2, r7, #0  24:	320f      	adds	r2, #15  26:	7812      	ldrb	r2, [r2, #0]  28:	429a      	cmp	r2, r3  2a:	d007      	beq.n	3c <SplitRawData+0x3c>        {            err = ERR_PARAM_DATA;  2c:	1c3b      	adds	r3, r7, #0  2e:	330c      	adds	r3, #12  30:	2283      	movs	r2, #131	; 0x83  32:	801a      	strh	r2, [r3, #0]    #if DEBUG            PrintErrorMessage(err);            printf("%#x\n", head);    #endif            return err;  34:	1c3b      	adds	r3, r7, #0  36:	330c      	adds	r3, #12  38:	881b      	ldrh	r3, [r3, #0]  3a:	e0af      	b.n	19c <SplitRawData+0x19c>        }        loffStatP  = ((byte)(tADCPtr[adcNum]->adcData.rawData[0] & 0x0F) << 4) & 0xF0;  3c:	4b59      	ldr	r3, [pc, #356]	; (1a4 <SplitRawData+0x1a4>)  3e:	697a      	ldr	r2, [r7, #20]  40:	0092      	lsls	r2, r2, #2  42:	58d3      	ldr	r3, [r2, r3]  44:	7c1b      	ldrb	r3, [r3, #16]  46:	011a      	lsls	r2, r3, #4  48:	1c3b      	adds	r3, r7, #0  4a:	330b      	adds	r3, #11  4c:	701a      	strb	r2, [r3, #0]        loffStatP |= ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0xF0) >> 4) & 0x0F;  4e:	4b55      	ldr	r3, [pc, #340]	; (1a4 <SplitRawData+0x1a4>)  50:	697a      	ldr	r2, [r7, #20]  52:	0092      	lsls	r2, r2, #2  54:	58d3      	ldr	r3, [r2, r3]  56:	7c5b      	ldrb	r3, [r3, #17]  58:	091b      	lsrs	r3, r3, #4  5a:	b2db      	uxtb	r3, r3  5c:	b2da      	uxtb	r2, r3  5e:	1c3b      	adds	r3, r7, #0  60:	330b      	adds	r3, #11  62:	781b      	ldrb	r3, [r3, #0]  64:	4313      	orrs	r3, r2  66:	b2da      	uxtb	r2, r3  68:	1c3b      	adds	r3, r7, #0  6a:	330b      	adds	r3, #11  6c:	701a      	strb	r2, [r3, #0]        loffStatN  = ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0x0F) << 4) & 0xF0;  6e:	4b4d      	ldr	r3, [pc, #308]	; (1a4 <SplitRawData+0x1a4>)  70:	697a      	ldr	r2, [r7, #20]  72:	0092      	lsls	r2, r2, #2  74:	58d3      	ldr	r3, [r2, r3]  76:	7c5b      	ldrb	r3, [r3, #17]  78:	011a      	lsls	r2, r3, #4  7a:	1c3b      	adds	r3, r7, #0  7c:	330a      	adds	r3, #10  7e:	701a      	strb	r2, [r3, #0]        loffStatN |= ((byte)(tADCPtr[adcNum]->adcData.rawData[2] & 0xF0) >> 4) & 0x0F;  80:	4b48      	ldr	r3, [pc, #288]	; (1a4 <SplitRawData+0x1a4>)  82:	697a      	ldr	r2, [r7, #20]  84:	0092      	lsls	r2, r2, #2  86:	58d3      	ldr	r3, [r2, r3]  88:	7c9b      	ldrb	r3, [r3, #18]  8a:	091b      	lsrs	r3, r3, #4  8c:	b2db      	uxtb	r3, r3  8e:	b2da      	uxtb	r2, r3  90:	1c3b      	adds	r3, r7, #0  92:	330a      	adds	r3, #10  94:	781b      	ldrb	r3, [r3, #0]  96:	4313      	orrs	r3, r2  98:	b2da      	uxtb	r2, r3  9a:	1c3b      	adds	r3, r7, #0  9c:	330a      	adds	r3, #10  9e:	701a      	strb	r2, [r3, #0]        regGPIOData =  (byte)tADCPtr[adcNum]->adcData.rawData[2] & 0x0F;  a0:	4b40      	ldr	r3, [pc, #256]	; (1a4 <SplitRawData+0x1a4>)  a2:	697a      	ldr	r2, [r7, #20]  a4:	0092      	lsls	r2, r2, #2  a6:	58d3      	ldr	r3, [r2, r3]  a8:	7c99      	ldrb	r1, [r3, #18]  aa:	1c3b      	adds	r3, r7, #0  ac:	3309      	adds	r3, #9  ae:	220f      	movs	r2, #15  b0:	400a      	ands	r2, r1  b2:	701a      	strb	r2, [r3, #0]        //for(int i = 0; i < USING_CHANNEL_COUNT * BYTE_COUNT_PER_CHANNEL; i += 2)    /* Every channel's data is 2 Bytes. */        for(int i = 0; i < 16; i++)  b4:	2300      	movs	r3, #0  b6:	613b      	str	r3, [r7, #16]  b8:	e045      	b.n	146 <SplitRawData+0x146>        {            channelData = ((int16)tADCPtr[adcNum]->adcData.rawData[RAW_DATA_HEAD_SIZE + i] << 8) & 0xFF00;  ba:	4b3a      	ldr	r3, [pc, #232]	; (1a4 <SplitRawData+0x1a4>)  bc:	697a      	ldr	r2, [r7, #20]  be:	0092      	lsls	r2, r2, #2  c0:	58d1      	ldr	r1, [r2, r3]  c2:	693b      	ldr	r3, [r7, #16]  c4:	1cda      	adds	r2, r3, #3  c6:	2308      	movs	r3, #8  c8:	188a      	adds	r2, r1, r2  ca:	18d3      	adds	r3, r2, r3  cc:	7a1b      	ldrb	r3, [r3, #8]  ce:	021a      	lsls	r2, r3, #8  d0:	1dbb      	adds	r3, r7, #6  d2:	801a      	strh	r2, [r3, #0]            channelData |= (int16)tADCPtr[adcNum]->adcData.rawData[RAW_DATA_HEAD_SIZE + i + 1] & 0x00FF;  d4:	4b33      	ldr	r3, [pc, #204]	; (1a4 <SplitRawData+0x1a4>)  d6:	697a      	ldr	r2, [r7, #20]  d8:	0092      	lsls	r2, r2, #2  da:	58d1      	ldr	r1, [r2, r3]  dc:	693b      	ldr	r3, [r7, #16]  de:	1d1a      	adds	r2, r3, #4  e0:	2308      	movs	r3, #8  e2:	188a      	adds	r2, r1, r2  e4:	18d3      	adds	r3, r2, r3  e6:	7a1b      	ldrb	r3, [r3, #8]  e8:	1c19      	adds	r1, r3, #0  ea:	1dbb      	adds	r3, r7, #6  ec:	1dba      	adds	r2, r7, #6  ee:	8812      	ldrh	r2, [r2, #0]  f0:	430a      	orrs	r2, r1  f2:	801a      	strh	r2, [r3, #0]            if(eADC0 == adcNum)  f4:	697b      	ldr	r3, [r7, #20]  f6:	2b00      	cmp	r3, #0  f8:	d112      	bne.n	120 <SplitRawData+0x120>            {                //According to the hardware, the data from the 1st ADC should be reversed.                tADCPtr[adcNum]->adcData.channelData[USING_CHANNEL_COUNT - (i >> 1) - 1] = (channelData == 0x8000) ? 0x7FFF : (int16)(-channelData);  fa:	4b2a      	ldr	r3, [pc, #168]	; (1a4 <SplitRawData+0x1a4>)  fc:	697a      	ldr	r2, [r7, #20]  fe:	0092      	lsls	r2, r2, #2 100:	58d1      	ldr	r1, [r2, r3] 102:	693b      	ldr	r3, [r7, #16] 104:	105b      	asrs	r3, r3, #1 106:	2207      	movs	r2, #7 108:	1ad3      	subs	r3, r2, r3 10a:	1dba      	adds	r2, r7, #6 10c:	8812      	ldrh	r2, [r2, #0] 10e:	4252      	negs	r2, r2 110:	b292      	uxth	r2, r2 112:	b292      	uxth	r2, r2 114:	3310      	adds	r3, #16 116:	005b      	lsls	r3, r3, #1 118:	18cb      	adds	r3, r1, r3 11a:	3304      	adds	r3, #4 11c:	801a      	strh	r2, [r3, #0] 11e:	e00f      	b.n	140 <SplitRawData+0x140>            }            else if(eADC1 == adcNum) 120:	697b      	ldr	r3, [r7, #20] 122:	2b01      	cmp	r3, #1 124:	d10c      	bne.n	140 <SplitRawData+0x140>            {                tADCPtr[adcNum]->adcData.channelData[i >> 1] = (int16)channelData; 126:	4b1f      	ldr	r3, [pc, #124]	; (1a4 <SplitRawData+0x1a4>) 128:	697a      	ldr	r2, [r7, #20] 12a:	0092      	lsls	r2, r2, #2 12c:	58d2      	ldr	r2, [r2, r3] 12e:	693b      	ldr	r3, [r7, #16] 130:	105b      	asrs	r3, r3, #1 132:	3310      	adds	r3, #16 134:	005b      	lsls	r3, r3, #1 136:	18d3      	adds	r3, r2, r3 138:	3304      	adds	r3, #4 13a:	1dba      	adds	r2, r7, #6 13c:	8812      	ldrh	r2, [r2, #0] 13e:	801a      	strh	r2, [r3, #0]        loffStatN |= ((byte)(tADCPtr[adcNum]->adcData.rawData[2] & 0xF0) >> 4) & 0x0F;        regGPIOData =  (byte)tADCPtr[adcNum]->adcData.rawData[2] & 0x0F;        //for(int i = 0; i < USING_CHANNEL_COUNT * BYTE_COUNT_PER_CHANNEL; i += 2)    /* Every channel's data is 2 Bytes. */        for(int i = 0; i < 16; i++) 140:	693b      	ldr	r3, [r7, #16] 142:	3301      	adds	r3, #1 144:	613b      	str	r3, [r7, #16] 146:	693b      	ldr	r3, [r7, #16] 148:	2b0f      	cmp	r3, #15 14a:	ddb6      	ble.n	ba <SplitRawData+0xba>            {                tADCPtr[adcNum]->adcData.channelData[i >> 1] = (int16)channelData;            }        }        tADCPtr[adcNum]->adcData.head = (byte)head; 14c:	4b15      	ldr	r3, [pc, #84]	; (1a4 <SplitRawData+0x1a4>) 14e:	697a      	ldr	r2, [r7, #20] 150:	0092      	lsls	r2, r2, #2 152:	58d3      	ldr	r3, [r2, r3] 154:	1c3a      	adds	r2, r7, #0 156:	320f      	adds	r2, #15 158:	7812      	ldrb	r2, [r2, #0] 15a:	731a      	strb	r2, [r3, #12]        tADCPtr[adcNum]->adcData.loffStatP = (byte)loffStatP; 15c:	4b11      	ldr	r3, [pc, #68]	; (1a4 <SplitRawData+0x1a4>) 15e:	697a      	ldr	r2, [r7, #20] 160:	0092      	lsls	r2, r2, #2 162:	58d3      	ldr	r3, [r2, r3] 164:	1c3a      	adds	r2, r7, #0 166:	320b      	adds	r2, #11 168:	7812      	ldrb	r2, [r2, #0] 16a:	735a      	strb	r2, [r3, #13]        tADCPtr[adcNum]->adcData.loffStatN = (byte)loffStatN; 16c:	4b0d      	ldr	r3, [pc, #52]	; (1a4 <SplitRawData+0x1a4>) 16e:	697a      	ldr	r2, [r7, #20] 170:	0092      	lsls	r2, r2, #2 172:	58d3      	ldr	r3, [r2, r3] 174:	1c3a      	adds	r2, r7, #0 176:	320a      	adds	r2, #10 178:	7812      	ldrb	r2, [r2, #0] 17a:	739a      	strb	r2, [r3, #14]        tADCPtr[adcNum]->adcData.regGPIOData = (byte)regGPIOData; 17c:	4b09      	ldr	r3, [pc, #36]	; (1a4 <SplitRawData+0x1a4>) 17e:	697a      	ldr	r2, [r7, #20] 180:	0092      	lsls	r2, r2, #2 182:	58d3      	ldr	r3, [r2, r3] 184:	1c3a      	adds	r2, r7, #0 186:	3209      	adds	r2, #9 188:	7812      	ldrb	r2, [r2, #0] 18a:	73da      	strb	r2, [r3, #15]    byte loffStatP;    byte loffStatN;    byte regGPIOData;    int16 channelData;    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++) 18c:	697b      	ldr	r3, [r7, #20] 18e:	3301      	adds	r3, #1 190:	617b      	str	r3, [r7, #20] 192:	697b      	ldr	r3, [r7, #20] 194:	2b01      	cmp	r3, #1 196:	d800      	bhi.n	19a <SplitRawData+0x19a> 198:	e738      	b.n	c <SplitRawData+0xc>        tADCPtr[adcNum]->adcData.loffStatP = (byte)loffStatP;        tADCPtr[adcNum]->adcData.loffStatN = (byte)loffStatN;        tADCPtr[adcNum]->adcData.regGPIOData = (byte)regGPIOData;    }    return ERR_OK; 19a:	2300      	movs	r3, #0} 19c:	1c18      	adds	r0, r3, #0 19e:	46bd      	mov	sp, r7 1a0:	b006      	add	sp, #24 1a2:	bd80      	pop	{r7, pc}	...			1a4: R_ARM_ABS32	tADCPtr			1a8: R_ARM_ABS32	RAW_DATA_HEADDisassembly of section .text.CopyADCDataToMCUData:00000000 <CopyADCDataToMCUData>: *     @return *          void *//* ===================================================================*/static void CopyADCDataToMCUData(void){   0:	b590      	push	{r4, r7, lr}   2:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;//    static uint8 chDataCnt[USING_ADC_COUNT] = {0};    tMCUPtr->mcuData.channelData[0][0][chDataCnt] = tADCPtr[0]->adcData.channelData[0];   4:	4b6c      	ldr	r3, [pc, #432]	; (1b8 <CopyADCDataToMCUData+0x1b8>)   6:	6819      	ldr	r1, [r3, #0]   8:	4b6c      	ldr	r3, [pc, #432]	; (1bc <CopyADCDataToMCUData+0x1bc>)   a:	6818      	ldr	r0, [r3, #0]   c:	4b6c      	ldr	r3, [pc, #432]	; (1c0 <CopyADCDataToMCUData+0x1c0>)   e:	681b      	ldr	r3, [r3, #0]  10:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  12:	0043      	lsls	r3, r0, #1  14:	18cb      	adds	r3, r1, r3  16:	3302      	adds	r3, #2  18:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][1][chDataCnt] = tADCPtr[0]->adcData.channelData[1];  1a:	4b67      	ldr	r3, [pc, #412]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  1c:	6819      	ldr	r1, [r3, #0]  1e:	4b67      	ldr	r3, [pc, #412]	; (1bc <CopyADCDataToMCUData+0x1bc>)  20:	6818      	ldr	r0, [r3, #0]  22:	4b67      	ldr	r3, [pc, #412]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  24:	681b      	ldr	r3, [r3, #0]  26:	8cda      	ldrh	r2, [r3, #38]	; 0x26  28:	1c03      	adds	r3, r0, #0  2a:	3364      	adds	r3, #100	; 0x64  2c:	005b      	lsls	r3, r3, #1  2e:	18cb      	adds	r3, r1, r3  30:	3302      	adds	r3, #2  32:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][2][chDataCnt] = tADCPtr[0]->adcData.channelData[2];  34:	4b60      	ldr	r3, [pc, #384]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  36:	6819      	ldr	r1, [r3, #0]  38:	4b60      	ldr	r3, [pc, #384]	; (1bc <CopyADCDataToMCUData+0x1bc>)  3a:	6818      	ldr	r0, [r3, #0]  3c:	4b60      	ldr	r3, [pc, #384]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  3e:	681b      	ldr	r3, [r3, #0]  40:	8d1a      	ldrh	r2, [r3, #40]	; 0x28  42:	1c03      	adds	r3, r0, #0  44:	33c8      	adds	r3, #200	; 0xc8  46:	005b      	lsls	r3, r3, #1  48:	18cb      	adds	r3, r1, r3  4a:	3302      	adds	r3, #2  4c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][3][chDataCnt] = tADCPtr[0]->adcData.channelData[3];  4e:	4b5a      	ldr	r3, [pc, #360]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  50:	6819      	ldr	r1, [r3, #0]  52:	4b5a      	ldr	r3, [pc, #360]	; (1bc <CopyADCDataToMCUData+0x1bc>)  54:	6818      	ldr	r0, [r3, #0]  56:	4b5a      	ldr	r3, [pc, #360]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  58:	681b      	ldr	r3, [r3, #0]  5a:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a  5c:	2496      	movs	r4, #150	; 0x96  5e:	0064      	lsls	r4, r4, #1  60:	1903      	adds	r3, r0, r4  62:	005b      	lsls	r3, r3, #1  64:	18cb      	adds	r3, r1, r3  66:	3302      	adds	r3, #2  68:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][4][chDataCnt] = tADCPtr[0]->adcData.channelData[4];  6a:	4b53      	ldr	r3, [pc, #332]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  6c:	6819      	ldr	r1, [r3, #0]  6e:	4b53      	ldr	r3, [pc, #332]	; (1bc <CopyADCDataToMCUData+0x1bc>)  70:	6818      	ldr	r0, [r3, #0]  72:	4b53      	ldr	r3, [pc, #332]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  74:	681b      	ldr	r3, [r3, #0]  76:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c  78:	24c8      	movs	r4, #200	; 0xc8  7a:	0064      	lsls	r4, r4, #1  7c:	1903      	adds	r3, r0, r4  7e:	005b      	lsls	r3, r3, #1  80:	18cb      	adds	r3, r1, r3  82:	3302      	adds	r3, #2  84:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][5][chDataCnt] = tADCPtr[0]->adcData.channelData[5];  86:	4b4c      	ldr	r3, [pc, #304]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  88:	6819      	ldr	r1, [r3, #0]  8a:	4b4c      	ldr	r3, [pc, #304]	; (1bc <CopyADCDataToMCUData+0x1bc>)  8c:	6818      	ldr	r0, [r3, #0]  8e:	4b4c      	ldr	r3, [pc, #304]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  90:	681b      	ldr	r3, [r3, #0]  92:	8dda      	ldrh	r2, [r3, #46]	; 0x2e  94:	24fa      	movs	r4, #250	; 0xfa  96:	0064      	lsls	r4, r4, #1  98:	1903      	adds	r3, r0, r4  9a:	005b      	lsls	r3, r3, #1  9c:	18cb      	adds	r3, r1, r3  9e:	3302      	adds	r3, #2  a0:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][6][chDataCnt] = tADCPtr[0]->adcData.channelData[6];  a2:	4b45      	ldr	r3, [pc, #276]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  a4:	6819      	ldr	r1, [r3, #0]  a6:	4b45      	ldr	r3, [pc, #276]	; (1bc <CopyADCDataToMCUData+0x1bc>)  a8:	6818      	ldr	r0, [r3, #0]  aa:	4b45      	ldr	r3, [pc, #276]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	8e1a      	ldrh	r2, [r3, #48]	; 0x30  b0:	2496      	movs	r4, #150	; 0x96  b2:	00a4      	lsls	r4, r4, #2  b4:	1903      	adds	r3, r0, r4  b6:	005b      	lsls	r3, r3, #1  b8:	18cb      	adds	r3, r1, r3  ba:	3302      	adds	r3, #2  bc:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][7][chDataCnt] = tADCPtr[0]->adcData.channelData[7];  be:	4b3e      	ldr	r3, [pc, #248]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  c0:	6819      	ldr	r1, [r3, #0]  c2:	4b3e      	ldr	r3, [pc, #248]	; (1bc <CopyADCDataToMCUData+0x1bc>)  c4:	6818      	ldr	r0, [r3, #0]  c6:	4b3e      	ldr	r3, [pc, #248]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  c8:	681b      	ldr	r3, [r3, #0]  ca:	8e5a      	ldrh	r2, [r3, #50]	; 0x32  cc:	24af      	movs	r4, #175	; 0xaf  ce:	00a4      	lsls	r4, r4, #2  d0:	1903      	adds	r3, r0, r4  d2:	005b      	lsls	r3, r3, #1  d4:	18cb      	adds	r3, r1, r3  d6:	3302      	adds	r3, #2  d8:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][0][chDataCnt] = tADCPtr[1]->adcData.channelData[0];  da:	4b37      	ldr	r3, [pc, #220]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  dc:	6819      	ldr	r1, [r3, #0]  de:	4b37      	ldr	r3, [pc, #220]	; (1bc <CopyADCDataToMCUData+0x1bc>)  e0:	6818      	ldr	r0, [r3, #0]  e2:	4b37      	ldr	r3, [pc, #220]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  e4:	685b      	ldr	r3, [r3, #4]  e6:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  e8:	24c8      	movs	r4, #200	; 0xc8  ea:	00a4      	lsls	r4, r4, #2  ec:	1903      	adds	r3, r0, r4  ee:	005b      	lsls	r3, r3, #1  f0:	18cb      	adds	r3, r1, r3  f2:	3302      	adds	r3, #2  f4:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][1][chDataCnt] = tADCPtr[1]->adcData.channelData[1];  f6:	4b30      	ldr	r3, [pc, #192]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  f8:	6819      	ldr	r1, [r3, #0]  fa:	4b30      	ldr	r3, [pc, #192]	; (1bc <CopyADCDataToMCUData+0x1bc>)  fc:	6818      	ldr	r0, [r3, #0]  fe:	4b30      	ldr	r3, [pc, #192]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 100:	685b      	ldr	r3, [r3, #4] 102:	8cda      	ldrh	r2, [r3, #38]	; 0x26 104:	24e1      	movs	r4, #225	; 0xe1 106:	00a4      	lsls	r4, r4, #2 108:	1903      	adds	r3, r0, r4 10a:	005b      	lsls	r3, r3, #1 10c:	18cb      	adds	r3, r1, r3 10e:	3302      	adds	r3, #2 110:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][2][chDataCnt] = tADCPtr[1]->adcData.channelData[2]; 112:	4b29      	ldr	r3, [pc, #164]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 114:	6819      	ldr	r1, [r3, #0] 116:	4b29      	ldr	r3, [pc, #164]	; (1bc <CopyADCDataToMCUData+0x1bc>) 118:	6818      	ldr	r0, [r3, #0] 11a:	4b29      	ldr	r3, [pc, #164]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 11c:	685b      	ldr	r3, [r3, #4] 11e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28 120:	24fa      	movs	r4, #250	; 0xfa 122:	00a4      	lsls	r4, r4, #2 124:	1903      	adds	r3, r0, r4 126:	005b      	lsls	r3, r3, #1 128:	18cb      	adds	r3, r1, r3 12a:	3302      	adds	r3, #2 12c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][3][chDataCnt] = tADCPtr[1]->adcData.channelData[3]; 12e:	4b22      	ldr	r3, [pc, #136]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 130:	6819      	ldr	r1, [r3, #0] 132:	4b22      	ldr	r3, [pc, #136]	; (1bc <CopyADCDataToMCUData+0x1bc>) 134:	6818      	ldr	r0, [r3, #0] 136:	4b22      	ldr	r3, [pc, #136]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 138:	685b      	ldr	r3, [r3, #4] 13a:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a 13c:	4c21      	ldr	r4, [pc, #132]	; (1c4 <CopyADCDataToMCUData+0x1c4>) 13e:	1903      	adds	r3, r0, r4 140:	005b      	lsls	r3, r3, #1 142:	18cb      	adds	r3, r1, r3 144:	3302      	adds	r3, #2 146:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][4][chDataCnt] = tADCPtr[1]->adcData.channelData[4]; 148:	4b1b      	ldr	r3, [pc, #108]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 14a:	6819      	ldr	r1, [r3, #0] 14c:	4b1b      	ldr	r3, [pc, #108]	; (1bc <CopyADCDataToMCUData+0x1bc>) 14e:	6818      	ldr	r0, [r3, #0] 150:	4b1b      	ldr	r3, [pc, #108]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 152:	685b      	ldr	r3, [r3, #4] 154:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c 156:	2496      	movs	r4, #150	; 0x96 158:	00e4      	lsls	r4, r4, #3 15a:	1903      	adds	r3, r0, r4 15c:	005b      	lsls	r3, r3, #1 15e:	18cb      	adds	r3, r1, r3 160:	3302      	adds	r3, #2 162:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][5][chDataCnt] = tADCPtr[1]->adcData.channelData[5]; 164:	4b14      	ldr	r3, [pc, #80]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 166:	6819      	ldr	r1, [r3, #0] 168:	4b14      	ldr	r3, [pc, #80]	; (1bc <CopyADCDataToMCUData+0x1bc>) 16a:	6818      	ldr	r0, [r3, #0] 16c:	4b14      	ldr	r3, [pc, #80]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 16e:	685b      	ldr	r3, [r3, #4] 170:	8dda      	ldrh	r2, [r3, #46]	; 0x2e 172:	4c15      	ldr	r4, [pc, #84]	; (1c8 <CopyADCDataToMCUData+0x1c8>) 174:	1903      	adds	r3, r0, r4 176:	005b      	lsls	r3, r3, #1 178:	18cb      	adds	r3, r1, r3 17a:	3302      	adds	r3, #2 17c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][6][chDataCnt] = tADCPtr[1]->adcData.channelData[6]; 17e:	4b0e      	ldr	r3, [pc, #56]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 180:	6819      	ldr	r1, [r3, #0] 182:	4b0e      	ldr	r3, [pc, #56]	; (1bc <CopyADCDataToMCUData+0x1bc>) 184:	6818      	ldr	r0, [r3, #0] 186:	4b0e      	ldr	r3, [pc, #56]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 188:	685b      	ldr	r3, [r3, #4] 18a:	8e1a      	ldrh	r2, [r3, #48]	; 0x30 18c:	24af      	movs	r4, #175	; 0xaf 18e:	00e4      	lsls	r4, r4, #3 190:	1903      	adds	r3, r0, r4 192:	005b      	lsls	r3, r3, #1 194:	18cb      	adds	r3, r1, r3 196:	3302      	adds	r3, #2 198:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][7][chDataCnt] = tADCPtr[1]->adcData.channelData[7]; 19a:	4b07      	ldr	r3, [pc, #28]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 19c:	6819      	ldr	r1, [r3, #0] 19e:	4b07      	ldr	r3, [pc, #28]	; (1bc <CopyADCDataToMCUData+0x1bc>) 1a0:	6818      	ldr	r0, [r3, #0] 1a2:	4b07      	ldr	r3, [pc, #28]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 1a4:	685b      	ldr	r3, [r3, #4] 1a6:	8e5a      	ldrh	r2, [r3, #50]	; 0x32 1a8:	4c08      	ldr	r4, [pc, #32]	; (1cc <CopyADCDataToMCUData+0x1cc>) 1aa:	1903      	adds	r3, r0, r4 1ac:	005b      	lsls	r3, r3, #1 1ae:	18cb      	adds	r3, r1, r3 1b0:	3302      	adds	r3, #2 1b2:	801a      	strh	r2, [r3, #0]//    chDataCnt[adcFlag]++;//    chDataCnt[adcFlag] %= CHANNEL_DATA_COUNT;} 1b4:	46bd      	mov	sp, r7 1b6:	bd90      	pop	{r4, r7, pc}	...			1b8: R_ARM_ABS32	tMCUPtr			1bc: R_ARM_ABS32	.bss.chDataCnt			1c0: R_ARM_ABS32	tADCPtr 1c4:	0000044c 	.word	0x0000044c 1c8:	00000514 	.word	0x00000514 1cc:	000005dc 	.word	0x000005dcDisassembly of section .text.PackData:00000000 <PackData>: *     @return *         	void *//* ===================================================================*/static void PackData(void){   0:	b084b5b0 	.word	0xb084b5b0   4:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;    extern TARMPtr tARMPtr;//    static int chDataCnt[USING_ADC_COUNT] = {0};    int off;    if(eFull == tARMPtr->armStatus.backBufferStatus || eOverflow == tARMPtr->armStatus.backBufferStatus)   6:	4b47      	ldr	r3, [pc, #284]	; (124 <PackData+0x124>)   8:	681b      	ldr	r3, [r3, #0]   a:	78db      	ldrb	r3, [r3, #3]   c:	b2db      	uxtb	r3, r3   e:	b25b      	sxtb	r3, r3  10:	2b03      	cmp	r3, #3  12:	d006      	beq.n	22 <PackData+0x22>  14:	4b43      	ldr	r3, [pc, #268]	; (124 <PackData+0x124>)  16:	681b      	ldr	r3, [r3, #0]  18:	78db      	ldrb	r3, [r3, #3]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	2b04      	cmp	r3, #4  20:	d10a      	bne.n	38 <PackData+0x38>    {        tARMPtr->armStatus.backBufferStatus = eOverflow;  22:	4b40      	ldr	r3, [pc, #256]	; (124 <PackData+0x124>)  24:	681b      	ldr	r3, [r3, #0]  26:	2204      	movs	r2, #4  28:	70da      	strb	r2, [r3, #3]        overflowCnt++;  2a:	4b3f      	ldr	r3, [pc, #252]	; (128 <PackData+0x128>)  2c:	781b      	ldrb	r3, [r3, #0]  2e:	3301      	adds	r3, #1  30:	b2da      	uxtb	r2, r3  32:	4b3d      	ldr	r3, [pc, #244]	; (128 <PackData+0x128>)  34:	701a      	strb	r2, [r3, #0]        return;  36:	e071      	b.n	11c <PackData+0x11c>    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)  38:	2300      	movs	r3, #0  3a:	60fb      	str	r3, [r7, #12]  3c:	e04f      	b.n	de <PackData+0xde>    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)  3e:	2300      	movs	r3, #0  40:	60bb      	str	r3, [r7, #8]  42:	e046      	b.n	d2 <PackData+0xd2>                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum     // The ADC0's data is in the front of ADC1's data.                        + 3 * (channelNum + 1)                                  // Every channel's data pack has a head of 3 bits.                            + CHANNEL_DATA_COUNT * 2 * channelNum               // every channel's data is 200 bits apart of the 3-bit head.                                + chDataCnt * 2;                                // every channel's data at one time is 2 bits.            */            off = 1624 * adcNum  44:	68fb      	ldr	r3, [r7, #12]  46:	22cb      	movs	r2, #203	; 0xcb  48:	00d2      	lsls	r2, r2, #3  4a:	435a      	muls	r2, r3                    + 203 * channelNum  4c:	68bb      	ldr	r3, [r7, #8]  4e:	21cb      	movs	r1, #203	; 0xcb  50:	434b      	muls	r3, r1  52:	18d2      	adds	r2, r2, r3                    + (chDataCnt << 1)  54:	4b35      	ldr	r3, [pc, #212]	; (12c <PackData+0x12c>)  56:	681b      	ldr	r3, [r3, #0]  58:	005b      	lsls	r3, r3, #1  5a:	18d3      	adds	r3, r2, r3                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum     // The ADC0's data is in the front of ADC1's data.                        + 3 * (channelNum + 1)                                  // Every channel's data pack has a head of 3 bits.                            + CHANNEL_DATA_COUNT * 2 * channelNum               // every channel's data is 200 bits apart of the 3-bit head.                                + chDataCnt * 2;                                // every channel's data at one time is 2 bits.            */            off = 1624 * adcNum  5c:	330b      	adds	r3, #11  5e:	607b      	str	r3, [r7, #4]            /*            off = (adcNum << 10) + (adcNum << 9) + (adcNum << 6) + (adcNum << 4) + (adcNum << 3)                    + (channelNum << 7) + (channelNum << 6) + (channelNum << 3) + (channelNum << 1) + channelNum                    + 11;            */            tARMPtr->backBuffer[off] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] >> 8 & 0xFFU;  60:	4b30      	ldr	r3, [pc, #192]	; (124 <PackData+0x124>)  62:	681a      	ldr	r2, [r3, #0]  64:	4b32      	ldr	r3, [pc, #200]	; (130 <PackData+0x130>)  66:	58d2      	ldr	r2, [r2, r3]  68:	687b      	ldr	r3, [r7, #4]  6a:	18d2      	adds	r2, r2, r3  6c:	4b31      	ldr	r3, [pc, #196]	; (134 <PackData+0x134>)  6e:	6819      	ldr	r1, [r3, #0]  70:	4b2e      	ldr	r3, [pc, #184]	; (12c <PackData+0x12c>)  72:	681b      	ldr	r3, [r3, #0]  74:	68bc      	ldr	r4, [r7, #8]  76:	68f8      	ldr	r0, [r7, #12]  78:	2564      	movs	r5, #100	; 0x64  7a:	436c      	muls	r4, r5  7c:	25c8      	movs	r5, #200	; 0xc8  7e:	00ad      	lsls	r5, r5, #2  80:	4368      	muls	r0, r5  82:	1820      	adds	r0, r4, r0  84:	18c3      	adds	r3, r0, r3  86:	005b      	lsls	r3, r3, #1  88:	18cb      	adds	r3, r1, r3  8a:	3302      	adds	r3, #2  8c:	881b      	ldrh	r3, [r3, #0]  8e:	b21b      	sxth	r3, r3  90:	121b      	asrs	r3, r3, #8  92:	b29b      	uxth	r3, r3  94:	b2db      	uxtb	r3, r3  96:	7013      	strb	r3, [r2, #0]            tARMPtr->backBuffer[off + 1] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] & 0xFFU;  98:	4b22      	ldr	r3, [pc, #136]	; (124 <PackData+0x124>)  9a:	681a      	ldr	r2, [r3, #0]  9c:	4b24      	ldr	r3, [pc, #144]	; (130 <PackData+0x130>)  9e:	58d2      	ldr	r2, [r2, r3]  a0:	687b      	ldr	r3, [r7, #4]  a2:	3301      	adds	r3, #1  a4:	18d2      	adds	r2, r2, r3  a6:	4b23      	ldr	r3, [pc, #140]	; (134 <PackData+0x134>)  a8:	6819      	ldr	r1, [r3, #0]  aa:	4b20      	ldr	r3, [pc, #128]	; (12c <PackData+0x12c>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	68bc      	ldr	r4, [r7, #8]  b0:	68f8      	ldr	r0, [r7, #12]  b2:	2564      	movs	r5, #100	; 0x64  b4:	436c      	muls	r4, r5  b6:	25c8      	movs	r5, #200	; 0xc8  b8:	00ad      	lsls	r5, r5, #2  ba:	4368      	muls	r0, r5  bc:	1820      	adds	r0, r4, r0  be:	18c3      	adds	r3, r0, r3  c0:	005b      	lsls	r3, r3, #1  c2:	18cb      	adds	r3, r1, r3  c4:	3302      	adds	r3, #2  c6:	881b      	ldrh	r3, [r3, #0]  c8:	b2db      	uxtb	r3, r3  ca:	7013      	strb	r3, [r2, #0]        return;    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)  cc:	68bb      	ldr	r3, [r7, #8]  ce:	3301      	adds	r3, #1  d0:	60bb      	str	r3, [r7, #8]  d2:	68bb      	ldr	r3, [r7, #8]  d4:	2b07      	cmp	r3, #7  d6:	d9b5      	bls.n	44 <PackData+0x44>        tARMPtr->armStatus.backBufferStatus = eOverflow;        overflowCnt++;        return;    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)  d8:	68fb      	ldr	r3, [r7, #12]  da:	3301      	adds	r3, #1  dc:	60fb      	str	r3, [r7, #12]  de:	68fb      	ldr	r3, [r7, #12]  e0:	2b01      	cmp	r3, #1  e2:	d9ac      	bls.n	3e <PackData+0x3e>            tARMPtr->backBuffer[off] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] >> 8 & 0xFFU;            tARMPtr->backBuffer[off + 1] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] & 0xFFU;        }    }    chDataCnt++;  e4:	4b11      	ldr	r3, [pc, #68]	; (12c <PackData+0x12c>)  e6:	681b      	ldr	r3, [r3, #0]  e8:	1c5a      	adds	r2, r3, #1  ea:	4b10      	ldr	r3, [pc, #64]	; (12c <PackData+0x12c>)  ec:	601a      	str	r2, [r3, #0]    chDataCnt %= CHANNEL_DATA_COUNT;  ee:	4b0f      	ldr	r3, [pc, #60]	; (12c <PackData+0x12c>)  f0:	681b      	ldr	r3, [r3, #0]  f2:	1c18      	adds	r0, r3, #0  f4:	2164      	movs	r1, #100	; 0x64  f6:	f7ff fffe 	bl	0 <__aeabi_uidivmod>			f6: R_ARM_THM_CALL	__aeabi_uidivmod  fa:	1c0b      	adds	r3, r1, #0  fc:	1c1a      	adds	r2, r3, #0  fe:	4b0b      	ldr	r3, [pc, #44]	; (12c <PackData+0x12c>) 100:	601a      	str	r2, [r3, #0]    //chDataCnt = (chDataCnt != CHANNEL_DATA_COUNT) ? chDataCnt : 0;    if(!chDataCnt) 102:	4b0a      	ldr	r3, [pc, #40]	; (12c <PackData+0x12c>) 104:	681b      	ldr	r3, [r3, #0] 106:	2b00      	cmp	r3, #0 108:	d104      	bne.n	114 <PackData+0x114>    {//        tARMPtr->armStatus.isBackBufferEmpty = FALSE;//        tARMPtr->armStatus.isBackBufferFull = TRUE;        tARMPtr->armStatus.backBufferStatus = eFull; 10a:	4b06      	ldr	r3, [pc, #24]	; (124 <PackData+0x124>) 10c:	681b      	ldr	r3, [r3, #0] 10e:	2203      	movs	r2, #3 110:	70da      	strb	r2, [r3, #3] 112:	e003      	b.n	11c <PackData+0x11c>    else    {//        tARMPtr->armStatus.isBackBufferEmpty = FALSE;//        tARMPtr->armStatus.isBackBufferFull = FALSE;        tARMPtr->armStatus.backBufferStatus = eWrite; 114:	4b03      	ldr	r3, [pc, #12]	; (124 <PackData+0x124>) 116:	681b      	ldr	r3, [r3, #0] 118:	2202      	movs	r2, #2 11a:	70da      	strb	r2, [r3, #3]    }} 11c:	46bd      	mov	sp, r7 11e:	b004      	add	sp, #16 120:	bdb0      	pop	{r4, r5, r7, pc} 122:	46c0      	nop			; (mov r8, r8)	...			124: R_ARM_ABS32	tARMPtr			128: R_ARM_ABS32	.bss.overflowCnt			12c: R_ARM_ABS32	.bss.chDataCnt 130:	0000197c 	.word	0x0000197c 134:	00000000 	.word	0x00000000			134: R_ARM_ABS32	tMCUPtrDisassembly of section .text.SwapARMDataBuffer:00000000 <SwapARMDataBuffer>: *     @return *          void *//* ===================================================================*/void SwapARMDataBuffer(void){   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0    if(eNull == tARMPtr->armStatus.foreBufferStatus && eNull == tARMPtr->armStatus.backBufferStatus)   6:	4b83      	ldr	r3, [pc, #524]	; (214 <SwapARMDataBuffer+0x214>)   8:	681b      	ldr	r3, [r3, #0]   a:	789b      	ldrb	r3, [r3, #2]   c:	b2db      	uxtb	r3, r3   e:	b25b      	sxtb	r3, r3  10:	3301      	adds	r3, #1  12:	d146      	bne.n	a2 <SwapARMDataBuffer+0xa2>  14:	4b7f      	ldr	r3, [pc, #508]	; (214 <SwapARMDataBuffer+0x214>)  16:	681b      	ldr	r3, [r3, #0]  18:	78db      	ldrb	r3, [r3, #3]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	3301      	adds	r3, #1  20:	d13f      	bne.n	a2 <SwapARMDataBuffer+0xa2>    {        tARMPtr->foreBuffer = tARMPtr->armDataRight.dataFrame;  22:	4b7c      	ldr	r3, [pc, #496]	; (214 <SwapARMDataBuffer+0x214>)  24:	681a      	ldr	r2, [r3, #0]  26:	4b7b      	ldr	r3, [pc, #492]	; (214 <SwapARMDataBuffer+0x214>)  28:	681b      	ldr	r3, [r3, #0]  2a:	487b      	ldr	r0, [pc, #492]	; (218 <SwapARMDataBuffer+0x218>)  2c:	1819      	adds	r1, r3, r0  2e:	4b7b      	ldr	r3, [pc, #492]	; (21c <SwapARMDataBuffer+0x21c>)  30:	50d1      	str	r1, [r2, r3]        tARMPtr->backBuffer = tARMPtr->armDataLeft.dataFrame;  32:	4b78      	ldr	r3, [pc, #480]	; (214 <SwapARMDataBuffer+0x214>)  34:	681a      	ldr	r2, [r3, #0]  36:	4b77      	ldr	r3, [pc, #476]	; (214 <SwapARMDataBuffer+0x214>)  38:	681b      	ldr	r3, [r3, #0]  3a:	1d19      	adds	r1, r3, #4  3c:	4b78      	ldr	r3, [pc, #480]	; (220 <SwapARMDataBuffer+0x220>)  3e:	50d1      	str	r1, [r2, r3]//        tARMPtr->armStatus.isForeBufferEmpty = FALSE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;//        tARMPtr->armStatus.isBackBufferEmpty = TRUE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eEmpty;  40:	4b74      	ldr	r3, [pc, #464]	; (214 <SwapARMDataBuffer+0x214>)  42:	681b      	ldr	r3, [r3, #0]  44:	2200      	movs	r2, #0  46:	709a      	strb	r2, [r3, #2]        tARMPtr->armStatus.backBufferStatus = eEmpty;  48:	4b72      	ldr	r3, [pc, #456]	; (214 <SwapARMDataBuffer+0x214>)  4a:	681b      	ldr	r3, [r3, #0]  4c:	2200      	movs	r2, #0  4e:	70da      	strb	r2, [r3, #3]        tARMPtr->armStatus.isUploadReady = FALSE;  50:	4b70      	ldr	r3, [pc, #448]	; (214 <SwapARMDataBuffer+0x214>)  52:	681b      	ldr	r3, [r3, #0]  54:	781a      	ldrb	r2, [r3, #0]  56:	2102      	movs	r1, #2  58:	438a      	bics	r2, r1  5a:	701a      	strb	r2, [r3, #0]        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  5c:	4b6d      	ldr	r3, [pc, #436]	; (214 <SwapARMDataBuffer+0x214>)  5e:	681a      	ldr	r2, [r3, #0]  60:	4b6e      	ldr	r3, [pc, #440]	; (21c <SwapARMDataBuffer+0x21c>)  62:	58d3      	ldr	r3, [r2, r3]  64:	1d9a      	adds	r2, r3, #6  66:	4b6b      	ldr	r3, [pc, #428]	; (214 <SwapARMDataBuffer+0x214>)  68:	6819      	ldr	r1, [r3, #0]  6a:	4b6c      	ldr	r3, [pc, #432]	; (21c <SwapARMDataBuffer+0x21c>)  6c:	58cb      	ldr	r3, [r1, r3]  6e:	3306      	adds	r3, #6  70:	7819      	ldrb	r1, [r3, #0]  72:	2301      	movs	r3, #1  74:	400b      	ands	r3, r1  76:	b2d9      	uxtb	r1, r3                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);  78:	4b66      	ldr	r3, [pc, #408]	; (214 <SwapARMDataBuffer+0x214>)  7a:	681b      	ldr	r3, [r3, #0]  7c:	789b      	ldrb	r3, [r3, #2]  7e:	b2db      	uxtb	r3, r3//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eEmpty;        tARMPtr->armStatus.backBufferStatus = eEmpty;        tARMPtr->armStatus.isUploadReady = FALSE;        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  80:	b2db      	uxtb	r3, r3  82:	005b      	lsls	r3, r3, #1  84:	b2d8      	uxtb	r0, r3  86:	230e      	movs	r3, #14  88:	4003      	ands	r3, r0  8a:	b2db      	uxtb	r3, r3  8c:	430b      	orrs	r3, r1  8e:	b2db      	uxtb	r3, r3  90:	7013      	strb	r3, [r2, #0]                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        tARMPtr->foreBuffer[7] = 0x0U;  92:	4b60      	ldr	r3, [pc, #384]	; (214 <SwapARMDataBuffer+0x214>)  94:	681a      	ldr	r2, [r3, #0]  96:	4b61      	ldr	r3, [pc, #388]	; (21c <SwapARMDataBuffer+0x21c>)  98:	58d3      	ldr	r3, [r2, r3]  9a:	3307      	adds	r3, #7  9c:	2200      	movs	r2, #0  9e:	701a      	strb	r2, [r3, #0]  a0:	e0af      	b.n	202 <SwapARMDataBuffer+0x202>    else    {        //tARMPtr->backBuffer[7] = tARMPtr->armStatus.backBufferStatus;        byte* temp;        temp = tARMPtr->foreBuffer;  a2:	4b5c      	ldr	r3, [pc, #368]	; (214 <SwapARMDataBuffer+0x214>)  a4:	681a      	ldr	r2, [r3, #0]  a6:	4b5d      	ldr	r3, [pc, #372]	; (21c <SwapARMDataBuffer+0x21c>)  a8:	58d3      	ldr	r3, [r2, r3]  aa:	60fb      	str	r3, [r7, #12]        tARMPtr->foreBuffer = tARMPtr->backBuffer;  ac:	4b59      	ldr	r3, [pc, #356]	; (214 <SwapARMDataBuffer+0x214>)  ae:	681a      	ldr	r2, [r3, #0]  b0:	4b58      	ldr	r3, [pc, #352]	; (214 <SwapARMDataBuffer+0x214>)  b2:	6819      	ldr	r1, [r3, #0]  b4:	4b5a      	ldr	r3, [pc, #360]	; (220 <SwapARMDataBuffer+0x220>)  b6:	58c9      	ldr	r1, [r1, r3]  b8:	4b58      	ldr	r3, [pc, #352]	; (21c <SwapARMDataBuffer+0x21c>)  ba:	50d1      	str	r1, [r2, r3]        tARMPtr->backBuffer = temp;  bc:	4b55      	ldr	r3, [pc, #340]	; (214 <SwapARMDataBuffer+0x214>)  be:	681a      	ldr	r2, [r3, #0]  c0:	4b57      	ldr	r3, [pc, #348]	; (220 <SwapARMDataBuffer+0x220>)  c2:	68f9      	ldr	r1, [r7, #12]  c4:	50d1      	str	r1, [r2, r3]        tARMPtr->armStatus.foreBufferStatus = tARMPtr->armStatus.backBufferStatus;  c6:	4b53      	ldr	r3, [pc, #332]	; (214 <SwapARMDataBuffer+0x214>)  c8:	681a      	ldr	r2, [r3, #0]  ca:	4b52      	ldr	r3, [pc, #328]	; (214 <SwapARMDataBuffer+0x214>)  cc:	681b      	ldr	r3, [r3, #0]  ce:	78db      	ldrb	r3, [r3, #3]  d0:	b2db      	uxtb	r3, r3  d2:	7093      	strb	r3, [r2, #2]        tARMPtr->armStatus.backBufferStatus = eEmpty;  d4:	4b4f      	ldr	r3, [pc, #316]	; (214 <SwapARMDataBuffer+0x214>)  d6:	681b      	ldr	r3, [r3, #0]  d8:	2200      	movs	r2, #0  da:	70da      	strb	r2, [r3, #3]        tARMPtr->armStatus.isUploadReady = FALSE;  dc:	4b4d      	ldr	r3, [pc, #308]	; (214 <SwapARMDataBuffer+0x214>)  de:	681b      	ldr	r3, [r3, #0]  e0:	781a      	ldrb	r2, [r3, #0]  e2:	2102      	movs	r1, #2  e4:	438a      	bics	r2, r1  e6:	701a      	strb	r2, [r3, #0]        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  e8:	4b4a      	ldr	r3, [pc, #296]	; (214 <SwapARMDataBuffer+0x214>)  ea:	681a      	ldr	r2, [r3, #0]  ec:	4b4b      	ldr	r3, [pc, #300]	; (21c <SwapARMDataBuffer+0x21c>)  ee:	58d3      	ldr	r3, [r2, r3]  f0:	1d9a      	adds	r2, r3, #6  f2:	4b48      	ldr	r3, [pc, #288]	; (214 <SwapARMDataBuffer+0x214>)  f4:	6819      	ldr	r1, [r3, #0]  f6:	4b49      	ldr	r3, [pc, #292]	; (21c <SwapARMDataBuffer+0x21c>)  f8:	58cb      	ldr	r3, [r1, r3]  fa:	3306      	adds	r3, #6  fc:	7819      	ldrb	r1, [r3, #0]  fe:	2301      	movs	r3, #1 100:	400b      	ands	r3, r1 102:	b2d9      	uxtb	r1, r3                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU); 104:	4b43      	ldr	r3, [pc, #268]	; (214 <SwapARMDataBuffer+0x214>) 106:	681b      	ldr	r3, [r3, #0] 108:	789b      	ldrb	r3, [r3, #2] 10a:	b2db      	uxtb	r3, r3        tARMPtr->backBuffer = temp;        tARMPtr->armStatus.foreBufferStatus = tARMPtr->armStatus.backBufferStatus;        tARMPtr->armStatus.backBufferStatus = eEmpty;        tARMPtr->armStatus.isUploadReady = FALSE;        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U) 10c:	b2db      	uxtb	r3, r3 10e:	005b      	lsls	r3, r3, #1 110:	b2d8      	uxtb	r0, r3 112:	230e      	movs	r3, #14 114:	4003      	ands	r3, r0 116:	b2db      	uxtb	r3, r3 118:	430b      	orrs	r3, r1 11a:	b2db      	uxtb	r3, r3 11c:	7013      	strb	r3, [r2, #0]                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        switch(tARMPtr->armStatus.foreBufferStatus) 11e:	4b3d      	ldr	r3, [pc, #244]	; (214 <SwapARMDataBuffer+0x214>) 120:	681b      	ldr	r3, [r3, #0] 122:	789b      	ldrb	r3, [r3, #2] 124:	b2db      	uxtb	r3, r3 126:	b25b      	sxtb	r3, r3 128:	3301      	adds	r3, #1 12a:	2b05      	cmp	r3, #5 12c:	d869      	bhi.n	202 <SwapARMDataBuffer+0x202> 12e:	009a      	lsls	r2, r3, #2 130:	4b3c      	ldr	r3, [pc, #240]	; (224 <SwapARMDataBuffer+0x224>) 132:	18d3      	adds	r3, r2, r3 134:	681b      	ldr	r3, [r3, #0] 136:	469f      	mov	pc, r3        {        case eOverflow:            tARMPtr->foreBuffer[7] = overflowCnt; 138:	4b36      	ldr	r3, [pc, #216]	; (214 <SwapARMDataBuffer+0x214>) 13a:	681a      	ldr	r2, [r3, #0] 13c:	4b37      	ldr	r3, [pc, #220]	; (21c <SwapARMDataBuffer+0x21c>) 13e:	58d3      	ldr	r3, [r2, r3] 140:	3307      	adds	r3, #7 142:	4a39      	ldr	r2, [pc, #228]	; (228 <SwapARMDataBuffer+0x228>) 144:	7812      	ldrb	r2, [r2, #0] 146:	701a      	strb	r2, [r3, #0]            break; 148:	e05b      	b.n	202 <SwapARMDataBuffer+0x202>        case eFull:            tARMPtr->foreBuffer[7] = 0x00U; 14a:	4b32      	ldr	r3, [pc, #200]	; (214 <SwapARMDataBuffer+0x214>) 14c:	681a      	ldr	r2, [r3, #0] 14e:	4b33      	ldr	r3, [pc, #204]	; (21c <SwapARMDataBuffer+0x21c>) 150:	58d3      	ldr	r3, [r2, r3] 152:	3307      	adds	r3, #7 154:	2200      	movs	r2, #0 156:	701a      	strb	r2, [r3, #0]            break; 158:	e053      	b.n	202 <SwapARMDataBuffer+0x202>        case eWrite:        {            int remainNum;            remainNum = CHANNEL_DATA_COUNT - chDataCnt; 15a:	4b34      	ldr	r3, [pc, #208]	; (22c <SwapARMDataBuffer+0x22c>) 15c:	681b      	ldr	r3, [r3, #0] 15e:	2264      	movs	r2, #100	; 0x64 160:	1ad3      	subs	r3, r2, r3 162:	60bb      	str	r3, [r7, #8]            tARMPtr->foreBuffer[7] = remainNum; 164:	4b2b      	ldr	r3, [pc, #172]	; (214 <SwapARMDataBuffer+0x214>) 166:	681a      	ldr	r2, [r3, #0] 168:	4b2c      	ldr	r3, [pc, #176]	; (21c <SwapARMDataBuffer+0x21c>) 16a:	58d3      	ldr	r3, [r2, r3] 16c:	3307      	adds	r3, #7 16e:	68ba      	ldr	r2, [r7, #8] 170:	b2d2      	uxtb	r2, r2 172:	701a      	strb	r2, [r3, #0]            //Fill the remaining position as the last value in the array.            int off;            //for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++)            for(int i = 0; i < 16; i++) 174:	2300      	movs	r3, #0 176:	617b      	str	r3, [r7, #20] 178:	e036      	b.n	1e8 <SwapARMDataBuffer+0x1e8>            {                for(int j = 0; j < remainNum; j++) 17a:	2300      	movs	r3, #0 17c:	613b      	str	r3, [r7, #16] 17e:	e02c      	b.n	1da <SwapARMDataBuffer+0x1da>                {                    off = 210 + 203 * i - ((remainNum - j) << 1); 180:	697b      	ldr	r3, [r7, #20] 182:	22cb      	movs	r2, #203	; 0xcb 184:	4353      	muls	r3, r2 186:	1c1a      	adds	r2, r3, #0 188:	32d2      	adds	r2, #210	; 0xd2 18a:	68b9      	ldr	r1, [r7, #8] 18c:	693b      	ldr	r3, [r7, #16] 18e:	1acb      	subs	r3, r1, r3 190:	005b      	lsls	r3, r3, #1 192:	1ad3      	subs	r3, r2, r3 194:	607b      	str	r3, [r7, #4]                    /*off = (i << 7) + (i << 6) + (i << 3) + (i << 1) + i                            - ((remainNum - j) << 1)                            + 210;*/                    tARMPtr->backBuffer[off] = tARMPtr->backBuffer[off - 2]; 196:	4b1f      	ldr	r3, [pc, #124]	; (214 <SwapARMDataBuffer+0x214>) 198:	681a      	ldr	r2, [r3, #0] 19a:	4b21      	ldr	r3, [pc, #132]	; (220 <SwapARMDataBuffer+0x220>) 19c:	58d2      	ldr	r2, [r2, r3] 19e:	687b      	ldr	r3, [r7, #4] 1a0:	18d2      	adds	r2, r2, r3 1a2:	4b1c      	ldr	r3, [pc, #112]	; (214 <SwapARMDataBuffer+0x214>) 1a4:	6819      	ldr	r1, [r3, #0] 1a6:	4b1e      	ldr	r3, [pc, #120]	; (220 <SwapARMDataBuffer+0x220>) 1a8:	58c9      	ldr	r1, [r1, r3] 1aa:	687b      	ldr	r3, [r7, #4] 1ac:	3b02      	subs	r3, #2 1ae:	18cb      	adds	r3, r1, r3 1b0:	781b      	ldrb	r3, [r3, #0] 1b2:	7013      	strb	r3, [r2, #0]                    tARMPtr->backBuffer[off + 1] = tARMPtr->backBuffer[off - 1]; 1b4:	4b17      	ldr	r3, [pc, #92]	; (214 <SwapARMDataBuffer+0x214>) 1b6:	681a      	ldr	r2, [r3, #0] 1b8:	4b19      	ldr	r3, [pc, #100]	; (220 <SwapARMDataBuffer+0x220>) 1ba:	58d2      	ldr	r2, [r2, r3] 1bc:	687b      	ldr	r3, [r7, #4] 1be:	3301      	adds	r3, #1 1c0:	18d2      	adds	r2, r2, r3 1c2:	4b14      	ldr	r3, [pc, #80]	; (214 <SwapARMDataBuffer+0x214>) 1c4:	6819      	ldr	r1, [r3, #0] 1c6:	4b16      	ldr	r3, [pc, #88]	; (220 <SwapARMDataBuffer+0x220>) 1c8:	58c9      	ldr	r1, [r1, r3] 1ca:	687b      	ldr	r3, [r7, #4] 1cc:	3b01      	subs	r3, #1 1ce:	18cb      	adds	r3, r1, r3 1d0:	781b      	ldrb	r3, [r3, #0] 1d2:	7013      	strb	r3, [r2, #0]            //Fill the remaining position as the last value in the array.            int off;            //for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++)            for(int i = 0; i < 16; i++)            {                for(int j = 0; j < remainNum; j++) 1d4:	693b      	ldr	r3, [r7, #16] 1d6:	3301      	adds	r3, #1 1d8:	613b      	str	r3, [r7, #16] 1da:	693a      	ldr	r2, [r7, #16] 1dc:	68bb      	ldr	r3, [r7, #8] 1de:	429a      	cmp	r2, r3 1e0:	dbce      	blt.n	180 <SwapARMDataBuffer+0x180>            remainNum = CHANNEL_DATA_COUNT - chDataCnt;            tARMPtr->foreBuffer[7] = remainNum;            //Fill the remaining position as the last value in the array.            int off;            //for(int i = 0; i < USING_ADC_COUNT * USING_CHANNEL_COUNT; i++)            for(int i = 0; i < 16; i++) 1e2:	697b      	ldr	r3, [r7, #20] 1e4:	3301      	adds	r3, #1 1e6:	617b      	str	r3, [r7, #20] 1e8:	697b      	ldr	r3, [r7, #20] 1ea:	2b0f      	cmp	r3, #15 1ec:	ddc5      	ble.n	17a <SwapARMDataBuffer+0x17a>//                            tARMPtr->backBuffer[off + 1] = tARMPtr->backBuffer[off - 1];//                        }//                    }//                }//            }            break; 1ee:	e008      	b.n	202 <SwapARMDataBuffer+0x202>        }        case eRead:            break;        case eEmpty:        case eIdle:            tARMPtr->foreBuffer[7] = CHANNEL_DATA_COUNT; 1f0:	4b08      	ldr	r3, [pc, #32]	; (214 <SwapARMDataBuffer+0x214>) 1f2:	681a      	ldr	r2, [r3, #0] 1f4:	4b09      	ldr	r3, [pc, #36]	; (21c <SwapARMDataBuffer+0x21c>) 1f6:	58d3      	ldr	r3, [r2, r3] 1f8:	3307      	adds	r3, #7 1fa:	2264      	movs	r2, #100	; 0x64 1fc:	701a      	strb	r2, [r3, #0]            break; 1fe:	e000      	b.n	202 <SwapARMDataBuffer+0x202>//                }//            }            break;        }        case eRead:            break; 200:	46c0      	nop			; (mov r8, r8)            tARMPtr->foreBuffer[7] = CHANNEL_DATA_COUNT;            break;        }    }    chDataCnt = 0; 202:	4b0a      	ldr	r3, [pc, #40]	; (22c <SwapARMDataBuffer+0x22c>) 204:	2200      	movs	r2, #0 206:	601a      	str	r2, [r3, #0]    overflowCnt = 0; 208:	4b07      	ldr	r3, [pc, #28]	; (228 <SwapARMDataBuffer+0x228>) 20a:	2200      	movs	r2, #0 20c:	701a      	strb	r2, [r3, #0]} 20e:	46bd      	mov	sp, r7 210:	b006      	add	sp, #24 212:	bd80      	pop	{r7, pc} 214:	00000000 	.word	0x00000000			214: R_ARM_ABS32	tARMPtr 218:	00000cbd 	.word	0x00000cbd 21c:	00001978 	.word	0x00001978 220:	0000197c 	.word	0x0000197c	...			224: R_ARM_ABS32	.rodata.SwapARMDataBuffer			228: R_ARM_ABS32	.bss.overflowCnt			22c: R_ARM_ABS32	.bss.chDataCnt
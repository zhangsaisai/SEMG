Sources\Process.o:     file format elf32-littlearmSources\Process.oarchitecture: arm, flags 0x00000011:HAS_RELOC, HAS_SYMSstart address 0x00000000private flags = 5000000: [Version5 EABI]Sections:Idx Name          Size      VMA       LMA       File off  Algn  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC  3 .bss.chDataCnt 00000004  00000000  00000000  00000034  2**2                  ALLOC  4 .bss.overflowCnt 00000001  00000000  00000000  00000034  2**0                  ALLOC  5 .text.MainLoop 0000008c  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  6 .text.ReadADCData 000000e0  00000000  00000000  000000c0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  7 .text.Process 00000044  00000000  00000000  000001a0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  8 .text.TransmitMCUData 00000078  00000000  00000000  000001e4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  9 .text.SplitRawData 000001c4  00000000  00000000  0000025c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.CopyADCDataToMCUData 000001d0  00000000  00000000  00000420  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.PackData 00000150  00000000  00000000  000005f0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 12 .text.SwapARMDataBuffer 00000230  00000000  00000000  00000740  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 13 .rodata.SwapARMDataBuffer 00000018  00000000  00000000  00000970  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA 14 .debug_info   00000d07  00000000  00000000  00000988  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 15 .debug_abbrev 000001de  00000000  00000000  0000168f  2**0                  CONTENTS, READONLY, DEBUGGING 16 .debug_loc    00000184  00000000  00000000  0000186d  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 17 .debug_aranges 00000058  00000000  00000000  000019f1  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 18 .debug_macinfo 000450ae  00000000  00000000  00001a49  2**0                  CONTENTS, READONLY, DEBUGGING 19 .debug_line   00000640  00000000  00000000  00046af7  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 20 .debug_str    00000872  00000000  00000000  00047137  2**0                  CONTENTS, READONLY, DEBUGGING 21 .comment      0000007a  00000000  00000000  000479a9  2**0                  CONTENTS, READONLY 22 .ARM.attributes 00000031  00000000  00000000  00047a23  2**0                  CONTENTS, READONLY 23 .debug_frame  00000100  00000000  00000000  00047a54  2**2                  CONTENTS, RELOC, READONLY, DEBUGGINGSYMBOL TABLE:00000000 l    df *ABS*	00000000 Process.c00000000 l    d  .text	00000000 .text00000000 l    d  .data	00000000 .data00000000 l    d  .bss	00000000 .bss00000000 l    d  .bss.chDataCnt	00000000 .bss.chDataCnt00000000 l     O .bss.chDataCnt	00000004 chDataCnt00000000 l    d  .bss.overflowCnt	00000000 .bss.overflowCnt00000000 l     O .bss.overflowCnt	00000001 overflowCnt00000000 l    d  .text.MainLoop	00000000 .text.MainLoop00000000 l     F .text.ReadADCData	000000e0 ReadADCData00000000 l     F .text.Process	00000044 Process00000000 l    d  .text.ReadADCData	00000000 .text.ReadADCData00000000 l    d  .text.Process	00000000 .text.Process00000000 l     F .text.SplitRawData	000001c4 SplitRawData00000000 l     F .text.CopyADCDataToMCUData	000001d0 CopyADCDataToMCUData00000000 l     F .text.PackData	00000150 PackData00000000 l    d  .text.TransmitMCUData	00000000 .text.TransmitMCUData00000000 l    d  .text.SplitRawData	00000000 .text.SplitRawData00000000 l    d  .text.CopyADCDataToMCUData	00000000 .text.CopyADCDataToMCUData00000000 l    d  .text.PackData	00000000 .text.PackData00000000 l    d  .text.SwapARMDataBuffer	00000000 .text.SwapARMDataBuffer00000000 l    d  .rodata.SwapARMDataBuffer	00000000 .rodata.SwapARMDataBuffer00000000 l    d  .debug_info	00000000 .debug_info00000000 l    d  .debug_abbrev	00000000 .debug_abbrev00000000 l    d  .debug_loc	00000000 .debug_loc00000000 l    d  .debug_aranges	00000000 .debug_aranges00000000 l    d  .debug_macinfo	00000000 .debug_macinfo00000000 l    d  .debug_line	00000000 .debug_line00000000 l    d  .debug_str	00000000 .debug_str00000000 l    d  .debug_frame	00000000 .debug_frame00000000 l    d  .comment	00000000 .comment00000000 l    d  .ARM.attributes	00000000 .ARM.attributes00000068       O *COM*	00000004 tADC00000008       O *COM*	00000004 tADCPtr00001902       O *COM*	00000004 tMCU00000004       O *COM*	00000004 tMCUPtr00001980       O *COM*	00000004 tARM00000004       O *COM*	00000004 tARMPtr00000004       O *COM*	00000004 masterSPI0DevData00000004       O *COM*	00000004 slaveSPI1DevData00000004       O *COM*	00000004 masterSPIRxDMADevData00000004       O *COM*	00000004 masterSPITxDMADevData00000004       O *COM*	00000004 slaveSPIRxDMADevData00000004       O *COM*	00000004 slaveSPITxDMADevData00000004       O *COM*	00000004 dmaControllerDevData00000004       O *COM*	00000004 portA1DevData00000004       O *COM*	00000004 portB2DevData00000004       O *COM*	00000004 portC4DevData00000004       O *COM*	00000004 portE0DevData00000004       O *COM*	00000004 portA5DevData00000004       O *COM*	00000004 portB1DevData00000004       O *COM*	00000004 portC8DevData00000004       O *COM*	00000004 portE1DevData00000004       O *COM*	00000004 portA2DevData00000004       O *COM*	00000004 portE29DevData00000000 g     F .text.MainLoop	0000008c MainLoop00000000         *UND*	00000000 EINT_AD_NOT_DRDY0_Enable00000000         *UND*	00000000 EINT_SYNC_INT_Enable00000000         *UND*	00000000 isStart00000000         *UND*	00000000 EnableADCSPI00000000         *UND*	00000000 ADCReadContinuousData00000000         *UND*	00000000 DisableADCSPI00000000 g     F .text.TransmitMCUData	00000078 TransmitMCUData00000000         *UND*	00000000 BitIO_UPRDY_SetVal00000000         *UND*	00000000 SPI1SendData00000000         *UND*	00000000 BitIO_UPRDY_ClrVal00000000         *UND*	00000000 RAW_DATA_HEAD00000000         *UND*	00000000 BYTE_COUNT_PER_CHANNEL00000000         *UND*	00000000 __aeabi_uidivmod00000000         *UND*	00000000 DATA_FRAME_HEAD_SIZE00000000 g     F .text.SwapARMDataBuffer	00000230 SwapARMDataBufferDisassembly of section .text.MainLoop:00000000 <MainLoop>: *     @return *          void *//* ===================================================================*/void MainLoop(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;    extern volatile bool isStart;    tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = TRUE;   4:	4b1b      	ldr	r3, [pc, #108]	; (74 <MainLoop+0x74>)   6:	681b      	ldr	r3, [r3, #0]   8:	785a      	ldrb	r2, [r3, #1]   a:	2110      	movs	r1, #16   c:	430a      	orrs	r2, r1   e:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = TRUE;  10:	4b18      	ldr	r3, [pc, #96]	; (74 <MainLoop+0x74>)  12:	681b      	ldr	r3, [r3, #0]  14:	785a      	ldrb	r2, [r3, #1]  16:	2108      	movs	r1, #8  18:	430a      	orrs	r2, r1  1a:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI1RxDMATransCompleted = TRUE;  1c:	4b15      	ldr	r3, [pc, #84]	; (74 <MainLoop+0x74>)  1e:	681b      	ldr	r3, [r3, #0]  20:	785a      	ldrb	r2, [r3, #1]  22:	2140      	movs	r1, #64	; 0x40  24:	430a      	orrs	r2, r1  26:	705a      	strb	r2, [r3, #1]    tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted = TRUE;  28:	4b12      	ldr	r3, [pc, #72]	; (74 <MainLoop+0x74>)  2a:	681b      	ldr	r3, [r3, #0]  2c:	785a      	ldrb	r2, [r3, #1]  2e:	2120      	movs	r1, #32  30:	430a      	orrs	r2, r1  32:	705a      	strb	r2, [r3, #1]//    SPI0_BR = (SPI_BR_SPPR(0x02) | SPI_BR_SPR(0x02));   /* Set baud rage register, 1M */    SPI0_BR = (SPI_BR_SPPR(0x01) | SPI_BR_SPR(0x00)); /* Set baud rate register,6M */  34:	4b10      	ldr	r3, [pc, #64]	; (78 <MainLoop+0x78>)  36:	2210      	movs	r2, #16  38:	709a      	strb	r2, [r3, #2]//    SPI0_BR = (SPI_BR_SPPR(0x00) | SPI_BR_SPR(0x00)); /* Set baud rate register,12M */    /* Enable PortA's interrupt. */    EIntADNotReady0Enable(EINT_AD_NOT_DRDY0);  3a:	4b10      	ldr	r3, [pc, #64]	; (7c <MainLoop+0x7c>)  3c:	681b      	ldr	r3, [r3, #0]  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <EINT_AD_NOT_DRDY0_Enable>			40: R_ARM_THM_CALL	EINT_AD_NOT_DRDY0_Enable//    EIntADNotReady1Enable(EINT_AD_NOT_DRDY1);    EIntSyncInterruptEnable(EINT_SYNC_INT);  44:	4b0e      	ldr	r3, [pc, #56]	; (80 <MainLoop+0x80>)  46:	681b      	ldr	r3, [r3, #0]  48:	1c18      	adds	r0, r3, #0  4a:	f7ff fffe 	bl	0 <EINT_SYNC_INT_Enable>			4a: R_ARM_THM_CALL	EINT_SYNC_INT_Enable    NVIC_ISER |= NVIC_ISER_SETENA(0x40000000);      /* Enable PortA's hardware interrupt */  4e:	4b0d      	ldr	r3, [pc, #52]	; (84 <MainLoop+0x84>)  50:	4a0c      	ldr	r2, [pc, #48]	; (84 <MainLoop+0x84>)  52:	6812      	ldr	r2, [r2, #0]  54:	2180      	movs	r1, #128	; 0x80  56:	05c9      	lsls	r1, r1, #23  58:	430a      	orrs	r2, r1  5a:	601a      	str	r2, [r3, #0]    //ADCStartConvertByCommand(eADC0);    //ADCStartConvertByCommand(eADC1);    /* Start ADC's conversion at the same time by Pull the start pin high. *///    tARMPtr->backBuffer = tARMPtr->armDataLeft.dataFrame;//    GPIOB_PDOR |= 0x06U;    /* B1, B2 */    while(!isStart);  5c:	46c0      	nop			; (mov r8, r8)  5e:	4b0a      	ldr	r3, [pc, #40]	; (88 <MainLoop+0x88>)  60:	781b      	ldrb	r3, [r3, #0]  62:	b2db      	uxtb	r3, r3  64:	2b00      	cmp	r3, #0  66:	d0fa      	beq.n	5e <MainLoop+0x5e>    for(;;)    {//        SwapARMDataBuffer();    /* Swap the data buffer if needed. */        /* If data of ADC is ready, read it. */        ReadADCData();  68:	f7ff fffe 	bl	0 <MainLoop>			68: R_ARM_THM_CALL	ReadADCData        /* Processing the Data. */        Process();  6c:	f7ff fffe 	bl	0 <MainLoop>			6c: R_ARM_THM_CALL	Process        //Process(eADC1);        /*  If the ARM requires data, transmit. */        //TransmitMCUData();    }  70:	e7fa      	b.n	68 <MainLoop+0x68>  72:	46c0      	nop			; (mov r8, r8)  74:	00000000 	.word	0x00000000			74: R_ARM_ABS32	tMCUPtr  78:	40076000 	.word	0x40076000	...			7c: R_ARM_ABS32	portA1DevData			80: R_ARM_ABS32	portA2DevData  84:	e000e100 	.word	0xe000e100  88:	00000000 	.word	0x00000000			88: R_ARM_ABS32	isStartDisassembly of section .text.ReadADCData:00000000 <ReadADCData>: *     @return *          void *//* ===================================================================*/static void ReadADCData(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TADCPtr tADCPtr[USING_ADC_COUNT];    //EADCFlag adcFlag;    if(tADCPtr[eADC0]->adcStatus.isDataReady)// && tADCPtr[eADC1]->adcStatus.isDataReady)   4:	4b34      	ldr	r3, [pc, #208]	; (d8 <ReadADCData+0xd8>)   6:	681b      	ldr	r3, [r3, #0]   8:	781b      	ldrb	r3, [r3, #0]   a:	b2da      	uxtb	r2, r3   c:	2301      	movs	r3, #1   e:	4013      	ands	r3, r2  10:	b2db      	uxtb	r3, r3  12:	2b00      	cmp	r3, #0  14:	d05d      	beq.n	d2 <ReadADCData+0xd2>    {        EnableADCSPI(eADC0);  16:	2000      	movs	r0, #0  18:	f7ff fffe 	bl	0 <EnableADCSPI>			18: R_ARM_THM_CALL	EnableADCSPI        ADCReadContinuousData(tADCPtr[eADC0]->adcData.rawData, RAW_DATA_SIZE);  1c:	4b2e      	ldr	r3, [pc, #184]	; (d8 <ReadADCData+0xd8>)  1e:	681b      	ldr	r3, [r3, #0]  20:	3310      	adds	r3, #16  22:	1c18      	adds	r0, r3, #0  24:	2113      	movs	r1, #19  26:	f7ff fffe 	bl	0 <ADCReadContinuousData>			26: R_ARM_THM_CALL	ADCReadContinuousData        tMCUPtr->mcuStatus.isReceivingADCData = TRUE;  2a:	4b2c      	ldr	r3, [pc, #176]	; (dc <ReadADCData+0xdc>)  2c:	681b      	ldr	r3, [r3, #0]  2e:	781a      	ldrb	r2, [r3, #0]  30:	2101      	movs	r1, #1  32:	430a      	orrs	r2, r1  34:	701a      	strb	r2, [r3, #0]//        tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;//        tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;        tADCPtr[eADC0]->adcStatus.adcDataStatus = eReceiving;  36:	4b28      	ldr	r3, [pc, #160]	; (d8 <ReadADCData+0xd8>)  38:	681b      	ldr	r3, [r3, #0]  3a:	2200      	movs	r2, #0  3c:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC0]->adcStatus.transmitionContent = eData;  3e:	4b26      	ldr	r3, [pc, #152]	; (d8 <ReadADCData+0xd8>)  40:	681b      	ldr	r3, [r3, #0]  42:	2201      	movs	r2, #1  44:	705a      	strb	r2, [r3, #1]//        while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);        DisableADCSPI(eADC0);  46:	2000      	movs	r0, #0  48:	f7ff fffe 	bl	0 <DisableADCSPI>			48: R_ARM_THM_CALL	DisableADCSPI        tMCUPtr->mcuStatus.isReceivingADCData = FALSE;  4c:	4b23      	ldr	r3, [pc, #140]	; (dc <ReadADCData+0xdc>)  4e:	681b      	ldr	r3, [r3, #0]  50:	781a      	ldrb	r2, [r3, #0]  52:	2101      	movs	r1, #1  54:	438a      	bics	r2, r1  56:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC0]->adcStatus.isDataReady = FALSE;  58:	4b1f      	ldr	r3, [pc, #124]	; (d8 <ReadADCData+0xd8>)  5a:	681b      	ldr	r3, [r3, #0]  5c:	781a      	ldrb	r2, [r3, #0]  5e:	2101      	movs	r1, #1  60:	438a      	bics	r2, r1  62:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC0]->adcStatus.adcDataStatus = eReceived;  64:	4b1c      	ldr	r3, [pc, #112]	; (d8 <ReadADCData+0xd8>)  66:	681b      	ldr	r3, [r3, #0]  68:	2201      	movs	r2, #1  6a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC0]->adcStatus.transmitionContent = eNothing;  6c:	4b1a      	ldr	r3, [pc, #104]	; (d8 <ReadADCData+0xd8>)  6e:	681b      	ldr	r3, [r3, #0]  70:	22ff      	movs	r2, #255	; 0xff  72:	705a      	strb	r2, [r3, #1]        //Process(eADC0);        EnableADCSPI(eADC1);  74:	2001      	movs	r0, #1  76:	f7ff fffe 	bl	0 <EnableADCSPI>			76: R_ARM_THM_CALL	EnableADCSPI        ADCReadContinuousData(tADCPtr[eADC1]->adcData.rawData, RAW_DATA_SIZE);  7a:	4b17      	ldr	r3, [pc, #92]	; (d8 <ReadADCData+0xd8>)  7c:	685b      	ldr	r3, [r3, #4]  7e:	3310      	adds	r3, #16  80:	1c18      	adds	r0, r3, #0  82:	2113      	movs	r1, #19  84:	f7ff fffe 	bl	0 <ADCReadContinuousData>			84: R_ARM_THM_CALL	ADCReadContinuousData        tMCUPtr->mcuStatus.isReceivingADCData = TRUE;  88:	4b14      	ldr	r3, [pc, #80]	; (dc <ReadADCData+0xdc>)  8a:	681b      	ldr	r3, [r3, #0]  8c:	781a      	ldrb	r2, [r3, #0]  8e:	2101      	movs	r1, #1  90:	430a      	orrs	r2, r1  92:	701a      	strb	r2, [r3, #0]//        tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted = FALSE;//        tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted = FALSE;        tADCPtr[eADC1]->adcStatus.adcDataStatus = eReceiving;  94:	4b10      	ldr	r3, [pc, #64]	; (d8 <ReadADCData+0xd8>)  96:	685b      	ldr	r3, [r3, #4]  98:	2200      	movs	r2, #0  9a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.transmitionContent = eData;  9c:	4b0e      	ldr	r3, [pc, #56]	; (d8 <ReadADCData+0xd8>)  9e:	685b      	ldr	r3, [r3, #4]  a0:	2201      	movs	r2, #1  a2:	705a      	strb	r2, [r3, #1]//        while(!tMCUPtr->mcuStatus.isSPI0RxDMATransCompleted || !tMCUPtr->mcuStatus.isSPI0TxDMATransCompleted);        DisableADCSPI(eADC1);  a4:	2001      	movs	r0, #1  a6:	f7ff fffe 	bl	0 <DisableADCSPI>			a6: R_ARM_THM_CALL	DisableADCSPI        tMCUPtr->mcuStatus.isReceivingADCData = FALSE;  aa:	4b0c      	ldr	r3, [pc, #48]	; (dc <ReadADCData+0xdc>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	781a      	ldrb	r2, [r3, #0]  b0:	2101      	movs	r1, #1  b2:	438a      	bics	r2, r1  b4:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC1]->adcStatus.isDataReady = FALSE;  b6:	4b08      	ldr	r3, [pc, #32]	; (d8 <ReadADCData+0xd8>)  b8:	685b      	ldr	r3, [r3, #4]  ba:	781a      	ldrb	r2, [r3, #0]  bc:	2101      	movs	r1, #1  be:	438a      	bics	r2, r1  c0:	701a      	strb	r2, [r3, #0]        tADCPtr[eADC1]->adcStatus.adcDataStatus = eReceived;  c2:	4b05      	ldr	r3, [pc, #20]	; (d8 <ReadADCData+0xd8>)  c4:	685b      	ldr	r3, [r3, #4]  c6:	2201      	movs	r2, #1  c8:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.transmitionContent = eNothing;  ca:	4b03      	ldr	r3, [pc, #12]	; (d8 <ReadADCData+0xd8>)  cc:	685b      	ldr	r3, [r3, #4]  ce:	22ff      	movs	r2, #255	; 0xff  d0:	705a      	strb	r2, [r3, #1]//        tADCPtr[adcFlag]->adcStatus.adcDataStatus = eReceived;//        tADCPtr[adcFlag]->adcStatus.transmitionContent = eNothing;////        Process(adcFlag);//    }}  d2:	46bd      	mov	sp, r7  d4:	bd80      	pop	{r7, pc}  d6:	46c0      	nop			; (mov r8, r8)	...			d8: R_ARM_ABS32	tADCPtr			dc: R_ARM_ABS32	tMCUPtrDisassembly of section .text.Process:00000000 <Process>: *     @return *          void *//* ===================================================================*/static void Process(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    extern TADCPtr tADCPtr[USING_ADC_COUNT];    if(eReceived == tADCPtr[eADC0]->adcStatus.adcDataStatus   4:	4b0e      	ldr	r3, [pc, #56]	; (40 <Process+0x40>)   6:	681b      	ldr	r3, [r3, #0]   8:	789b      	ldrb	r3, [r3, #2]   a:	b2db      	uxtb	r3, r3   c:	b25b      	sxtb	r3, r3   e:	2b01      	cmp	r3, #1  10:	d114      	bne.n	3c <Process+0x3c>            && eReceived == tADCPtr[eADC0]->adcStatus.adcDataStatus)  12:	4b0b      	ldr	r3, [pc, #44]	; (40 <Process+0x40>)  14:	681b      	ldr	r3, [r3, #0]  16:	789b      	ldrb	r3, [r3, #2]  18:	b2db      	uxtb	r3, r3  1a:	b25b      	sxtb	r3, r3  1c:	2b01      	cmp	r3, #1  1e:	d10d      	bne.n	3c <Process+0x3c>    {        SplitRawData();  20:	f7ff fffe 	bl	0 <Process>			20: R_ARM_THM_CALL	SplitRawData        tADCPtr[eADC0]->adcStatus.adcDataStatus = eIdle;  24:	4b06      	ldr	r3, [pc, #24]	; (40 <Process+0x40>)  26:	681b      	ldr	r3, [r3, #0]  28:	22ff      	movs	r2, #255	; 0xff  2a:	709a      	strb	r2, [r3, #2]        tADCPtr[eADC1]->adcStatus.adcDataStatus = eIdle;  2c:	4b04      	ldr	r3, [pc, #16]	; (40 <Process+0x40>)  2e:	685b      	ldr	r3, [r3, #4]  30:	22ff      	movs	r2, #255	; 0xff  32:	709a      	strb	r2, [r3, #2]        CopyADCDataToMCUData();  34:	f7ff fffe 	bl	0 <Process>			34: R_ARM_THM_CALL	CopyADCDataToMCUData        PackData();  38:	f7ff fffe 	bl	0 <Process>			38: R_ARM_THM_CALL	PackData    }}  3c:	46bd      	mov	sp, r7  3e:	bd80      	pop	{r7, pc}  40:	00000000 	.word	0x00000000			40: R_ARM_ABS32	tADCPtrDisassembly of section .text.TransmitMCUData:00000000 <TransmitMCUData>: *     @return *          void *//* ===================================================================*/void TransmitMCUData(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0    //if(//tARMPtr->armStatus.isRequiringData &&            //tARMPtr->armStatus.isUploadReady &&                //tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted)    //{        tARMPtr->armStatus.isRequiringData = FALSE;   4:	4b17      	ldr	r3, [pc, #92]	; (64 <TransmitMCUData+0x64>)   6:	681b      	ldr	r3, [r3, #0]   8:	781a      	ldrb	r2, [r3, #0]   a:	2101      	movs	r1, #1   c:	438a      	bics	r2, r1   e:	701a      	strb	r2, [r3, #0]        tMCUPtr->mcuStatus.isSPI1TxDMATransCompleted = FALSE;  10:	4b15      	ldr	r3, [pc, #84]	; (68 <TransmitMCUData+0x68>)  12:	681b      	ldr	r3, [r3, #0]  14:	785a      	ldrb	r2, [r3, #1]  16:	2120      	movs	r1, #32  18:	438a      	bics	r2, r1  1a:	705a      	strb	r2, [r3, #1]        IOUploadReadySetVal();  1c:	4b13      	ldr	r3, [pc, #76]	; (6c <TransmitMCUData+0x6c>)  1e:	681b      	ldr	r3, [r3, #0]  20:	1c18      	adds	r0, r3, #0  22:	f7ff fffe 	bl	0 <BitIO_UPRDY_SetVal>			22: R_ARM_THM_CALL	BitIO_UPRDY_SetVal        SPI1SendData((LDD_DMA_TAddress)tARMPtr->foreBuffer, DATA_FRAME_LENGTH + 1);  26:	4b0f      	ldr	r3, [pc, #60]	; (64 <TransmitMCUData+0x64>)  28:	681a      	ldr	r2, [r3, #0]  2a:	4b11      	ldr	r3, [pc, #68]	; (70 <TransmitMCUData+0x70>)  2c:	58d3      	ldr	r3, [r2, r3]  2e:	1c1a      	adds	r2, r3, #0  30:	4b10      	ldr	r3, [pc, #64]	; (74 <TransmitMCUData+0x74>)  32:	1c10      	adds	r0, r2, #0  34:	1c19      	adds	r1, r3, #0  36:	f7ff fffe 	bl	0 <SPI1SendData>			36: R_ARM_THM_CALL	SPI1SendData        IOUploadReadyClrVal();  3a:	4b0c      	ldr	r3, [pc, #48]	; (6c <TransmitMCUData+0x6c>)  3c:	681b      	ldr	r3, [r3, #0]  3e:	1c18      	adds	r0, r3, #0  40:	f7ff fffe 	bl	0 <BitIO_UPRDY_ClrVal>			40: R_ARM_THM_CALL	BitIO_UPRDY_ClrVal        //tARMPtr->armStatus.isTransmittingData = TRUE;        tARMPtr->armStatus.transmitionContent = eData;  44:	4b07      	ldr	r3, [pc, #28]	; (64 <TransmitMCUData+0x64>)  46:	681b      	ldr	r3, [r3, #0]  48:	2201      	movs	r2, #1  4a:	705a      	strb	r2, [r3, #1]//        tARMPtr->armStatus.isForeBufferEmpty = FALSE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eRead;  4c:	4b05      	ldr	r3, [pc, #20]	; (64 <TransmitMCUData+0x64>)  4e:	681b      	ldr	r3, [r3, #0]  50:	2201      	movs	r2, #1  52:	709a      	strb	r2, [r3, #2]        tARMPtr->armStatus.isUploadReady = FALSE;  54:	4b03      	ldr	r3, [pc, #12]	; (64 <TransmitMCUData+0x64>)  56:	681b      	ldr	r3, [r3, #0]  58:	781a      	ldrb	r2, [r3, #0]  5a:	2102      	movs	r1, #2  5c:	438a      	bics	r2, r1  5e:	701a      	strb	r2, [r3, #0]    //}}  60:	46bd      	mov	sp, r7  62:	bd80      	pop	{r7, pc}	...			64: R_ARM_ABS32	tARMPtr			68: R_ARM_ABS32	tMCUPtr			6c: R_ARM_ABS32	portE29DevData  70:	00001978 	.word	0x00001978  74:	00000cba 	.word	0x00000cbaDisassembly of section .text.SplitRawData:00000000 <SplitRawData>: *         	                                  so the data is invalid. *         	                - ERR_OK: Succeeded to split. *//* ===================================================================*/static LDD_TError SplitRawData(void){   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0    byte loffStatP;    byte loffStatN;    byte regGPIOData;    int16 channelData;    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)   6:	2300      	movs	r3, #0   8:	617b      	str	r3, [r7, #20]   a:	e0cb      	b.n	1a4 <SplitRawData+0x1a4>    {        head = ((tADCPtr[adcNum]->adcData.rawData[0] & 0xF0) >> 4) & 0x0F;       /* Split head byte from raw data. */   c:	4b6a      	ldr	r3, [pc, #424]	; (1b8 <SplitRawData+0x1b8>)   e:	697a      	ldr	r2, [r7, #20]  10:	0092      	lsls	r2, r2, #2  12:	58d3      	ldr	r3, [r2, r3]  14:	7c1a      	ldrb	r2, [r3, #16]  16:	1c3b      	adds	r3, r7, #0  18:	330f      	adds	r3, #15  1a:	0912      	lsrs	r2, r2, #4  1c:	701a      	strb	r2, [r3, #0]        if(head != RAW_DATA_HEAD)                                   /* If the head byte is not right(0x0C), return with error. */  1e:	4b67      	ldr	r3, [pc, #412]	; (1bc <SplitRawData+0x1bc>)  20:	781b      	ldrb	r3, [r3, #0]  22:	1c3a      	adds	r2, r7, #0  24:	320f      	adds	r2, #15  26:	7812      	ldrb	r2, [r2, #0]  28:	429a      	cmp	r2, r3  2a:	d007      	beq.n	3c <SplitRawData+0x3c>        {            err = ERR_PARAM_DATA;  2c:	1c3b      	adds	r3, r7, #0  2e:	330c      	adds	r3, #12  30:	2283      	movs	r2, #131	; 0x83  32:	801a      	strh	r2, [r3, #0]    #if DEBUG            PrintErrorMessage(err);            printf("%#x\n", head);    #endif            return err;  34:	1c3b      	adds	r3, r7, #0  36:	330c      	adds	r3, #12  38:	881b      	ldrh	r3, [r3, #0]  3a:	e0b8      	b.n	1ae <SplitRawData+0x1ae>        }        loffStatP  = ((byte)(tADCPtr[adcNum]->adcData.rawData[0] & 0x0F) << 4) & 0xF0;  3c:	4b5e      	ldr	r3, [pc, #376]	; (1b8 <SplitRawData+0x1b8>)  3e:	697a      	ldr	r2, [r7, #20]  40:	0092      	lsls	r2, r2, #2  42:	58d3      	ldr	r3, [r2, r3]  44:	7c1b      	ldrb	r3, [r3, #16]  46:	011a      	lsls	r2, r3, #4  48:	1c3b      	adds	r3, r7, #0  4a:	330b      	adds	r3, #11  4c:	701a      	strb	r2, [r3, #0]        loffStatP |= ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0xF0) >> 4) & 0x0F;  4e:	4b5a      	ldr	r3, [pc, #360]	; (1b8 <SplitRawData+0x1b8>)  50:	697a      	ldr	r2, [r7, #20]  52:	0092      	lsls	r2, r2, #2  54:	58d3      	ldr	r3, [r2, r3]  56:	7c5b      	ldrb	r3, [r3, #17]  58:	091b      	lsrs	r3, r3, #4  5a:	b2db      	uxtb	r3, r3  5c:	b2da      	uxtb	r2, r3  5e:	1c3b      	adds	r3, r7, #0  60:	330b      	adds	r3, #11  62:	781b      	ldrb	r3, [r3, #0]  64:	4313      	orrs	r3, r2  66:	b2da      	uxtb	r2, r3  68:	1c3b      	adds	r3, r7, #0  6a:	330b      	adds	r3, #11  6c:	701a      	strb	r2, [r3, #0]        loffStatN  = ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0x0F) << 4) & 0xF0;  6e:	4b52      	ldr	r3, [pc, #328]	; (1b8 <SplitRawData+0x1b8>)  70:	697a      	ldr	r2, [r7, #20]  72:	0092      	lsls	r2, r2, #2  74:	58d3      	ldr	r3, [r2, r3]  76:	7c5b      	ldrb	r3, [r3, #17]  78:	011a      	lsls	r2, r3, #4  7a:	1c3b      	adds	r3, r7, #0  7c:	330a      	adds	r3, #10  7e:	701a      	strb	r2, [r3, #0]        loffStatN |= ((byte)(tADCPtr[adcNum]->adcData.rawData[2] & 0xF0) >> 4) & 0x0F;  80:	4b4d      	ldr	r3, [pc, #308]	; (1b8 <SplitRawData+0x1b8>)  82:	697a      	ldr	r2, [r7, #20]  84:	0092      	lsls	r2, r2, #2  86:	58d3      	ldr	r3, [r2, r3]  88:	7c9b      	ldrb	r3, [r3, #18]  8a:	091b      	lsrs	r3, r3, #4  8c:	b2db      	uxtb	r3, r3  8e:	b2da      	uxtb	r2, r3  90:	1c3b      	adds	r3, r7, #0  92:	330a      	adds	r3, #10  94:	781b      	ldrb	r3, [r3, #0]  96:	4313      	orrs	r3, r2  98:	b2da      	uxtb	r2, r3  9a:	1c3b      	adds	r3, r7, #0  9c:	330a      	adds	r3, #10  9e:	701a      	strb	r2, [r3, #0]        regGPIOData =  (byte)tADCPtr[adcNum]->adcData.rawData[2] & 0x0F;  a0:	4b45      	ldr	r3, [pc, #276]	; (1b8 <SplitRawData+0x1b8>)  a2:	697a      	ldr	r2, [r7, #20]  a4:	0092      	lsls	r2, r2, #2  a6:	58d3      	ldr	r3, [r2, r3]  a8:	7c99      	ldrb	r1, [r3, #18]  aa:	1c3b      	adds	r3, r7, #0  ac:	3309      	adds	r3, #9  ae:	220f      	movs	r2, #15  b0:	400a      	ands	r2, r1  b2:	701a      	strb	r2, [r3, #0]        for(int i = 0; i < USING_CHANNEL_COUNT * BYTE_COUNT_PER_CHANNEL; i += 2)    /* Every channel's data is 2 Bytes. */  b4:	2300      	movs	r3, #0  b6:	613b      	str	r3, [r7, #16]  b8:	e04b      	b.n	152 <SplitRawData+0x152>        {            channelData = ((int16)tADCPtr[adcNum]->adcData.rawData[RAW_DATA_HEAD_SIZE + i] << 8) & 0xFF00;  ba:	4b3f      	ldr	r3, [pc, #252]	; (1b8 <SplitRawData+0x1b8>)  bc:	697a      	ldr	r2, [r7, #20]  be:	0092      	lsls	r2, r2, #2  c0:	58d1      	ldr	r1, [r2, r3]  c2:	693b      	ldr	r3, [r7, #16]  c4:	1cda      	adds	r2, r3, #3  c6:	2308      	movs	r3, #8  c8:	188a      	adds	r2, r1, r2  ca:	18d3      	adds	r3, r2, r3  cc:	7a1b      	ldrb	r3, [r3, #8]  ce:	021a      	lsls	r2, r3, #8  d0:	1dbb      	adds	r3, r7, #6  d2:	801a      	strh	r2, [r3, #0]            channelData |= (int16)tADCPtr[adcNum]->adcData.rawData[RAW_DATA_HEAD_SIZE + i + 1] & 0x00FF;  d4:	4b38      	ldr	r3, [pc, #224]	; (1b8 <SplitRawData+0x1b8>)  d6:	697a      	ldr	r2, [r7, #20]  d8:	0092      	lsls	r2, r2, #2  da:	58d1      	ldr	r1, [r2, r3]  dc:	693b      	ldr	r3, [r7, #16]  de:	1d1a      	adds	r2, r3, #4  e0:	2308      	movs	r3, #8  e2:	188a      	adds	r2, r1, r2  e4:	18d3      	adds	r3, r2, r3  e6:	7a1b      	ldrb	r3, [r3, #8]  e8:	1c19      	adds	r1, r3, #0  ea:	1dbb      	adds	r3, r7, #6  ec:	1dba      	adds	r2, r7, #6  ee:	8812      	ldrh	r2, [r2, #0]  f0:	430a      	orrs	r2, r1  f2:	801a      	strh	r2, [r3, #0]            if(eADC0 == adcNum)  f4:	697b      	ldr	r3, [r7, #20]  f6:	2b00      	cmp	r3, #0  f8:	d115      	bne.n	126 <SplitRawData+0x126>            {                //According to the hardware, the data from the 1st ADC should be reversed.                tADCPtr[adcNum]->adcData.channelData[USING_CHANNEL_COUNT - (i / 2) - 1] = (channelData == 0x8000) ? 0x7FFF : (int16)(-channelData);  fa:	4b2f      	ldr	r3, [pc, #188]	; (1b8 <SplitRawData+0x1b8>)  fc:	697a      	ldr	r2, [r7, #20]  fe:	0092      	lsls	r2, r2, #2 100:	58d1      	ldr	r1, [r2, r3] 102:	693b      	ldr	r3, [r7, #16] 104:	2b00      	cmp	r3, #0 106:	da00      	bge.n	10a <SplitRawData+0x10a> 108:	3301      	adds	r3, #1 10a:	105b      	asrs	r3, r3, #1 10c:	2207      	movs	r2, #7 10e:	1ad3      	subs	r3, r2, r3 110:	1dba      	adds	r2, r7, #6 112:	8812      	ldrh	r2, [r2, #0] 114:	4252      	negs	r2, r2 116:	b292      	uxth	r2, r2 118:	b292      	uxth	r2, r2 11a:	3310      	adds	r3, #16 11c:	005b      	lsls	r3, r3, #1 11e:	18cb      	adds	r3, r1, r3 120:	3304      	adds	r3, #4 122:	801a      	strh	r2, [r3, #0] 124:	e012      	b.n	14c <SplitRawData+0x14c>            }            else if(eADC1 == adcNum) 126:	697b      	ldr	r3, [r7, #20] 128:	2b01      	cmp	r3, #1 12a:	d10f      	bne.n	14c <SplitRawData+0x14c>            {                tADCPtr[adcNum]->adcData.channelData[i / 2] = (int16)channelData; 12c:	4b22      	ldr	r3, [pc, #136]	; (1b8 <SplitRawData+0x1b8>) 12e:	697a      	ldr	r2, [r7, #20] 130:	0092      	lsls	r2, r2, #2 132:	58d2      	ldr	r2, [r2, r3] 134:	693b      	ldr	r3, [r7, #16] 136:	2b00      	cmp	r3, #0 138:	da00      	bge.n	13c <SplitRawData+0x13c> 13a:	3301      	adds	r3, #1 13c:	105b      	asrs	r3, r3, #1 13e:	3310      	adds	r3, #16 140:	005b      	lsls	r3, r3, #1 142:	18d3      	adds	r3, r2, r3 144:	3304      	adds	r3, #4 146:	1dba      	adds	r2, r7, #6 148:	8812      	ldrh	r2, [r2, #0] 14a:	801a      	strh	r2, [r3, #0]        loffStatN  = ((byte)(tADCPtr[adcNum]->adcData.rawData[1] & 0x0F) << 4) & 0xF0;        loffStatN |= ((byte)(tADCPtr[adcNum]->adcData.rawData[2] & 0xF0) >> 4) & 0x0F;        regGPIOData =  (byte)tADCPtr[adcNum]->adcData.rawData[2] & 0x0F;        for(int i = 0; i < USING_CHANNEL_COUNT * BYTE_COUNT_PER_CHANNEL; i += 2)    /* Every channel's data is 2 Bytes. */ 14c:	693b      	ldr	r3, [r7, #16] 14e:	3302      	adds	r3, #2 150:	613b      	str	r3, [r7, #16] 152:	693a      	ldr	r2, [r7, #16] 154:	4b1a      	ldr	r3, [pc, #104]	; (1c0 <SplitRawData+0x1c0>) 156:	781b      	ldrb	r3, [r3, #0] 158:	00db      	lsls	r3, r3, #3 15a:	429a      	cmp	r2, r3 15c:	d3ad      	bcc.n	ba <SplitRawData+0xba>            {                tADCPtr[adcNum]->adcData.channelData[i / 2] = (int16)channelData;            }        }        tADCPtr[adcNum]->adcData.head = (byte)head; 15e:	4b16      	ldr	r3, [pc, #88]	; (1b8 <SplitRawData+0x1b8>) 160:	697a      	ldr	r2, [r7, #20] 162:	0092      	lsls	r2, r2, #2 164:	58d3      	ldr	r3, [r2, r3] 166:	1c3a      	adds	r2, r7, #0 168:	320f      	adds	r2, #15 16a:	7812      	ldrb	r2, [r2, #0] 16c:	731a      	strb	r2, [r3, #12]        tADCPtr[adcNum]->adcData.loffStatP = (byte)loffStatP; 16e:	4b12      	ldr	r3, [pc, #72]	; (1b8 <SplitRawData+0x1b8>) 170:	697a      	ldr	r2, [r7, #20] 172:	0092      	lsls	r2, r2, #2 174:	58d3      	ldr	r3, [r2, r3] 176:	1c3a      	adds	r2, r7, #0 178:	320b      	adds	r2, #11 17a:	7812      	ldrb	r2, [r2, #0] 17c:	735a      	strb	r2, [r3, #13]        tADCPtr[adcNum]->adcData.loffStatN = (byte)loffStatN; 17e:	4b0e      	ldr	r3, [pc, #56]	; (1b8 <SplitRawData+0x1b8>) 180:	697a      	ldr	r2, [r7, #20] 182:	0092      	lsls	r2, r2, #2 184:	58d3      	ldr	r3, [r2, r3] 186:	1c3a      	adds	r2, r7, #0 188:	320a      	adds	r2, #10 18a:	7812      	ldrb	r2, [r2, #0] 18c:	739a      	strb	r2, [r3, #14]        tADCPtr[adcNum]->adcData.regGPIOData = (byte)regGPIOData; 18e:	4b0a      	ldr	r3, [pc, #40]	; (1b8 <SplitRawData+0x1b8>) 190:	697a      	ldr	r2, [r7, #20] 192:	0092      	lsls	r2, r2, #2 194:	58d3      	ldr	r3, [r2, r3] 196:	1c3a      	adds	r2, r7, #0 198:	3209      	adds	r2, #9 19a:	7812      	ldrb	r2, [r2, #0] 19c:	73da      	strb	r2, [r3, #15]    byte loffStatP;    byte loffStatN;    byte regGPIOData;    int16 channelData;    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++) 19e:	697b      	ldr	r3, [r7, #20] 1a0:	3301      	adds	r3, #1 1a2:	617b      	str	r3, [r7, #20] 1a4:	697b      	ldr	r3, [r7, #20] 1a6:	2b01      	cmp	r3, #1 1a8:	d800      	bhi.n	1ac <SplitRawData+0x1ac> 1aa:	e72f      	b.n	c <SplitRawData+0xc>        tADCPtr[adcNum]->adcData.loffStatP = (byte)loffStatP;        tADCPtr[adcNum]->adcData.loffStatN = (byte)loffStatN;        tADCPtr[adcNum]->adcData.regGPIOData = (byte)regGPIOData;    }    return ERR_OK; 1ac:	2300      	movs	r3, #0} 1ae:	1c18      	adds	r0, r3, #0 1b0:	46bd      	mov	sp, r7 1b2:	b006      	add	sp, #24 1b4:	bd80      	pop	{r7, pc} 1b6:	46c0      	nop			; (mov r8, r8)	...			1b8: R_ARM_ABS32	tADCPtr			1bc: R_ARM_ABS32	RAW_DATA_HEAD			1c0: R_ARM_ABS32	BYTE_COUNT_PER_CHANNELDisassembly of section .text.CopyADCDataToMCUData:00000000 <CopyADCDataToMCUData>: *     @return *          void *//* ===================================================================*/static void CopyADCDataToMCUData(void){   0:	b590      	push	{r4, r7, lr}   2:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;//    static uint8 chDataCnt[USING_ADC_COUNT] = {0};    tMCUPtr->mcuData.channelData[0][0][chDataCnt] = tADCPtr[0]->adcData.channelData[0];   4:	4b6c      	ldr	r3, [pc, #432]	; (1b8 <CopyADCDataToMCUData+0x1b8>)   6:	6819      	ldr	r1, [r3, #0]   8:	4b6c      	ldr	r3, [pc, #432]	; (1bc <CopyADCDataToMCUData+0x1bc>)   a:	6818      	ldr	r0, [r3, #0]   c:	4b6c      	ldr	r3, [pc, #432]	; (1c0 <CopyADCDataToMCUData+0x1c0>)   e:	681b      	ldr	r3, [r3, #0]  10:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  12:	0043      	lsls	r3, r0, #1  14:	18cb      	adds	r3, r1, r3  16:	3302      	adds	r3, #2  18:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][1][chDataCnt] = tADCPtr[0]->adcData.channelData[1];  1a:	4b67      	ldr	r3, [pc, #412]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  1c:	6819      	ldr	r1, [r3, #0]  1e:	4b67      	ldr	r3, [pc, #412]	; (1bc <CopyADCDataToMCUData+0x1bc>)  20:	6818      	ldr	r0, [r3, #0]  22:	4b67      	ldr	r3, [pc, #412]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  24:	681b      	ldr	r3, [r3, #0]  26:	8cda      	ldrh	r2, [r3, #38]	; 0x26  28:	1c03      	adds	r3, r0, #0  2a:	3364      	adds	r3, #100	; 0x64  2c:	005b      	lsls	r3, r3, #1  2e:	18cb      	adds	r3, r1, r3  30:	3302      	adds	r3, #2  32:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][2][chDataCnt] = tADCPtr[0]->adcData.channelData[2];  34:	4b60      	ldr	r3, [pc, #384]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  36:	6819      	ldr	r1, [r3, #0]  38:	4b60      	ldr	r3, [pc, #384]	; (1bc <CopyADCDataToMCUData+0x1bc>)  3a:	6818      	ldr	r0, [r3, #0]  3c:	4b60      	ldr	r3, [pc, #384]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  3e:	681b      	ldr	r3, [r3, #0]  40:	8d1a      	ldrh	r2, [r3, #40]	; 0x28  42:	1c03      	adds	r3, r0, #0  44:	33c8      	adds	r3, #200	; 0xc8  46:	005b      	lsls	r3, r3, #1  48:	18cb      	adds	r3, r1, r3  4a:	3302      	adds	r3, #2  4c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][3][chDataCnt] = tADCPtr[0]->adcData.channelData[3];  4e:	4b5a      	ldr	r3, [pc, #360]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  50:	6819      	ldr	r1, [r3, #0]  52:	4b5a      	ldr	r3, [pc, #360]	; (1bc <CopyADCDataToMCUData+0x1bc>)  54:	6818      	ldr	r0, [r3, #0]  56:	4b5a      	ldr	r3, [pc, #360]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  58:	681b      	ldr	r3, [r3, #0]  5a:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a  5c:	2496      	movs	r4, #150	; 0x96  5e:	0064      	lsls	r4, r4, #1  60:	1903      	adds	r3, r0, r4  62:	005b      	lsls	r3, r3, #1  64:	18cb      	adds	r3, r1, r3  66:	3302      	adds	r3, #2  68:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][4][chDataCnt] = tADCPtr[0]->adcData.channelData[4];  6a:	4b53      	ldr	r3, [pc, #332]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  6c:	6819      	ldr	r1, [r3, #0]  6e:	4b53      	ldr	r3, [pc, #332]	; (1bc <CopyADCDataToMCUData+0x1bc>)  70:	6818      	ldr	r0, [r3, #0]  72:	4b53      	ldr	r3, [pc, #332]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  74:	681b      	ldr	r3, [r3, #0]  76:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c  78:	24c8      	movs	r4, #200	; 0xc8  7a:	0064      	lsls	r4, r4, #1  7c:	1903      	adds	r3, r0, r4  7e:	005b      	lsls	r3, r3, #1  80:	18cb      	adds	r3, r1, r3  82:	3302      	adds	r3, #2  84:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][5][chDataCnt] = tADCPtr[0]->adcData.channelData[5];  86:	4b4c      	ldr	r3, [pc, #304]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  88:	6819      	ldr	r1, [r3, #0]  8a:	4b4c      	ldr	r3, [pc, #304]	; (1bc <CopyADCDataToMCUData+0x1bc>)  8c:	6818      	ldr	r0, [r3, #0]  8e:	4b4c      	ldr	r3, [pc, #304]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  90:	681b      	ldr	r3, [r3, #0]  92:	8dda      	ldrh	r2, [r3, #46]	; 0x2e  94:	24fa      	movs	r4, #250	; 0xfa  96:	0064      	lsls	r4, r4, #1  98:	1903      	adds	r3, r0, r4  9a:	005b      	lsls	r3, r3, #1  9c:	18cb      	adds	r3, r1, r3  9e:	3302      	adds	r3, #2  a0:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][6][chDataCnt] = tADCPtr[0]->adcData.channelData[6];  a2:	4b45      	ldr	r3, [pc, #276]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  a4:	6819      	ldr	r1, [r3, #0]  a6:	4b45      	ldr	r3, [pc, #276]	; (1bc <CopyADCDataToMCUData+0x1bc>)  a8:	6818      	ldr	r0, [r3, #0]  aa:	4b45      	ldr	r3, [pc, #276]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  ac:	681b      	ldr	r3, [r3, #0]  ae:	8e1a      	ldrh	r2, [r3, #48]	; 0x30  b0:	2496      	movs	r4, #150	; 0x96  b2:	00a4      	lsls	r4, r4, #2  b4:	1903      	adds	r3, r0, r4  b6:	005b      	lsls	r3, r3, #1  b8:	18cb      	adds	r3, r1, r3  ba:	3302      	adds	r3, #2  bc:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[0][7][chDataCnt] = tADCPtr[0]->adcData.channelData[7];  be:	4b3e      	ldr	r3, [pc, #248]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  c0:	6819      	ldr	r1, [r3, #0]  c2:	4b3e      	ldr	r3, [pc, #248]	; (1bc <CopyADCDataToMCUData+0x1bc>)  c4:	6818      	ldr	r0, [r3, #0]  c6:	4b3e      	ldr	r3, [pc, #248]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  c8:	681b      	ldr	r3, [r3, #0]  ca:	8e5a      	ldrh	r2, [r3, #50]	; 0x32  cc:	24af      	movs	r4, #175	; 0xaf  ce:	00a4      	lsls	r4, r4, #2  d0:	1903      	adds	r3, r0, r4  d2:	005b      	lsls	r3, r3, #1  d4:	18cb      	adds	r3, r1, r3  d6:	3302      	adds	r3, #2  d8:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][0][chDataCnt] = tADCPtr[1]->adcData.channelData[0];  da:	4b37      	ldr	r3, [pc, #220]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  dc:	6819      	ldr	r1, [r3, #0]  de:	4b37      	ldr	r3, [pc, #220]	; (1bc <CopyADCDataToMCUData+0x1bc>)  e0:	6818      	ldr	r0, [r3, #0]  e2:	4b37      	ldr	r3, [pc, #220]	; (1c0 <CopyADCDataToMCUData+0x1c0>)  e4:	685b      	ldr	r3, [r3, #4]  e6:	8c9a      	ldrh	r2, [r3, #36]	; 0x24  e8:	24c8      	movs	r4, #200	; 0xc8  ea:	00a4      	lsls	r4, r4, #2  ec:	1903      	adds	r3, r0, r4  ee:	005b      	lsls	r3, r3, #1  f0:	18cb      	adds	r3, r1, r3  f2:	3302      	adds	r3, #2  f4:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][1][chDataCnt] = tADCPtr[1]->adcData.channelData[1];  f6:	4b30      	ldr	r3, [pc, #192]	; (1b8 <CopyADCDataToMCUData+0x1b8>)  f8:	6819      	ldr	r1, [r3, #0]  fa:	4b30      	ldr	r3, [pc, #192]	; (1bc <CopyADCDataToMCUData+0x1bc>)  fc:	6818      	ldr	r0, [r3, #0]  fe:	4b30      	ldr	r3, [pc, #192]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 100:	685b      	ldr	r3, [r3, #4] 102:	8cda      	ldrh	r2, [r3, #38]	; 0x26 104:	24e1      	movs	r4, #225	; 0xe1 106:	00a4      	lsls	r4, r4, #2 108:	1903      	adds	r3, r0, r4 10a:	005b      	lsls	r3, r3, #1 10c:	18cb      	adds	r3, r1, r3 10e:	3302      	adds	r3, #2 110:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][2][chDataCnt] = tADCPtr[1]->adcData.channelData[2]; 112:	4b29      	ldr	r3, [pc, #164]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 114:	6819      	ldr	r1, [r3, #0] 116:	4b29      	ldr	r3, [pc, #164]	; (1bc <CopyADCDataToMCUData+0x1bc>) 118:	6818      	ldr	r0, [r3, #0] 11a:	4b29      	ldr	r3, [pc, #164]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 11c:	685b      	ldr	r3, [r3, #4] 11e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28 120:	24fa      	movs	r4, #250	; 0xfa 122:	00a4      	lsls	r4, r4, #2 124:	1903      	adds	r3, r0, r4 126:	005b      	lsls	r3, r3, #1 128:	18cb      	adds	r3, r1, r3 12a:	3302      	adds	r3, #2 12c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][3][chDataCnt] = tADCPtr[1]->adcData.channelData[3]; 12e:	4b22      	ldr	r3, [pc, #136]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 130:	6819      	ldr	r1, [r3, #0] 132:	4b22      	ldr	r3, [pc, #136]	; (1bc <CopyADCDataToMCUData+0x1bc>) 134:	6818      	ldr	r0, [r3, #0] 136:	4b22      	ldr	r3, [pc, #136]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 138:	685b      	ldr	r3, [r3, #4] 13a:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a 13c:	4c21      	ldr	r4, [pc, #132]	; (1c4 <CopyADCDataToMCUData+0x1c4>) 13e:	1903      	adds	r3, r0, r4 140:	005b      	lsls	r3, r3, #1 142:	18cb      	adds	r3, r1, r3 144:	3302      	adds	r3, #2 146:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][4][chDataCnt] = tADCPtr[1]->adcData.channelData[4]; 148:	4b1b      	ldr	r3, [pc, #108]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 14a:	6819      	ldr	r1, [r3, #0] 14c:	4b1b      	ldr	r3, [pc, #108]	; (1bc <CopyADCDataToMCUData+0x1bc>) 14e:	6818      	ldr	r0, [r3, #0] 150:	4b1b      	ldr	r3, [pc, #108]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 152:	685b      	ldr	r3, [r3, #4] 154:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c 156:	2496      	movs	r4, #150	; 0x96 158:	00e4      	lsls	r4, r4, #3 15a:	1903      	adds	r3, r0, r4 15c:	005b      	lsls	r3, r3, #1 15e:	18cb      	adds	r3, r1, r3 160:	3302      	adds	r3, #2 162:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][5][chDataCnt] = tADCPtr[1]->adcData.channelData[5]; 164:	4b14      	ldr	r3, [pc, #80]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 166:	6819      	ldr	r1, [r3, #0] 168:	4b14      	ldr	r3, [pc, #80]	; (1bc <CopyADCDataToMCUData+0x1bc>) 16a:	6818      	ldr	r0, [r3, #0] 16c:	4b14      	ldr	r3, [pc, #80]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 16e:	685b      	ldr	r3, [r3, #4] 170:	8dda      	ldrh	r2, [r3, #46]	; 0x2e 172:	4c15      	ldr	r4, [pc, #84]	; (1c8 <CopyADCDataToMCUData+0x1c8>) 174:	1903      	adds	r3, r0, r4 176:	005b      	lsls	r3, r3, #1 178:	18cb      	adds	r3, r1, r3 17a:	3302      	adds	r3, #2 17c:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][6][chDataCnt] = tADCPtr[1]->adcData.channelData[6]; 17e:	4b0e      	ldr	r3, [pc, #56]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 180:	6819      	ldr	r1, [r3, #0] 182:	4b0e      	ldr	r3, [pc, #56]	; (1bc <CopyADCDataToMCUData+0x1bc>) 184:	6818      	ldr	r0, [r3, #0] 186:	4b0e      	ldr	r3, [pc, #56]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 188:	685b      	ldr	r3, [r3, #4] 18a:	8e1a      	ldrh	r2, [r3, #48]	; 0x30 18c:	24af      	movs	r4, #175	; 0xaf 18e:	00e4      	lsls	r4, r4, #3 190:	1903      	adds	r3, r0, r4 192:	005b      	lsls	r3, r3, #1 194:	18cb      	adds	r3, r1, r3 196:	3302      	adds	r3, #2 198:	801a      	strh	r2, [r3, #0]    tMCUPtr->mcuData.channelData[1][7][chDataCnt] = tADCPtr[1]->adcData.channelData[7]; 19a:	4b07      	ldr	r3, [pc, #28]	; (1b8 <CopyADCDataToMCUData+0x1b8>) 19c:	6819      	ldr	r1, [r3, #0] 19e:	4b07      	ldr	r3, [pc, #28]	; (1bc <CopyADCDataToMCUData+0x1bc>) 1a0:	6818      	ldr	r0, [r3, #0] 1a2:	4b07      	ldr	r3, [pc, #28]	; (1c0 <CopyADCDataToMCUData+0x1c0>) 1a4:	685b      	ldr	r3, [r3, #4] 1a6:	8e5a      	ldrh	r2, [r3, #50]	; 0x32 1a8:	4c08      	ldr	r4, [pc, #32]	; (1cc <CopyADCDataToMCUData+0x1cc>) 1aa:	1903      	adds	r3, r0, r4 1ac:	005b      	lsls	r3, r3, #1 1ae:	18cb      	adds	r3, r1, r3 1b0:	3302      	adds	r3, #2 1b2:	801a      	strh	r2, [r3, #0]//    chDataCnt[adcFlag]++;//    chDataCnt[adcFlag] %= CHANNEL_DATA_COUNT;} 1b4:	46bd      	mov	sp, r7 1b6:	bd90      	pop	{r4, r7, pc}	...			1b8: R_ARM_ABS32	tMCUPtr			1bc: R_ARM_ABS32	.bss.chDataCnt			1c0: R_ARM_ABS32	tADCPtr 1c4:	0000044c 	.word	0x0000044c 1c8:	00000514 	.word	0x00000514 1cc:	000005dc 	.word	0x000005dcDisassembly of section .text.PackData:00000000 <PackData>: *     @return *         	void *//* ===================================================================*/static void PackData(void){   0:	b084b5b0 	.word	0xb084b5b0   4:	af00      	add	r7, sp, #0    extern TMCUPtr tMCUPtr;    extern TARMPtr tARMPtr;//    static int chDataCnt[USING_ADC_COUNT] = {0};    int off;    if(eFull == tARMPtr->armStatus.backBufferStatus || eOverflow == tARMPtr->armStatus.backBufferStatus)   6:	4b4c      	ldr	r3, [pc, #304]	; (138 <PackData+0x138>)   8:	681b      	ldr	r3, [r3, #0]   a:	78db      	ldrb	r3, [r3, #3]   c:	b2db      	uxtb	r3, r3   e:	b25b      	sxtb	r3, r3  10:	2b03      	cmp	r3, #3  12:	d006      	beq.n	22 <PackData+0x22>  14:	4b48      	ldr	r3, [pc, #288]	; (138 <PackData+0x138>)  16:	681b      	ldr	r3, [r3, #0]  18:	78db      	ldrb	r3, [r3, #3]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	2b04      	cmp	r3, #4  20:	d10a      	bne.n	38 <PackData+0x38>    {        tARMPtr->armStatus.backBufferStatus = eOverflow;  22:	4b45      	ldr	r3, [pc, #276]	; (138 <PackData+0x138>)  24:	681b      	ldr	r3, [r3, #0]  26:	2204      	movs	r2, #4  28:	70da      	strb	r2, [r3, #3]        overflowCnt++;  2a:	4b44      	ldr	r3, [pc, #272]	; (13c <PackData+0x13c>)  2c:	781b      	ldrb	r3, [r3, #0]  2e:	3301      	adds	r3, #1  30:	b2da      	uxtb	r2, r3  32:	4b42      	ldr	r3, [pc, #264]	; (13c <PackData+0x13c>)  34:	701a      	strb	r2, [r3, #0]        return;  36:	e07c      	b.n	132 <PackData+0x132>    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)  38:	2300      	movs	r3, #0  3a:	60fb      	str	r3, [r7, #12]  3c:	e05a      	b.n	f4 <PackData+0xf4>    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)  3e:	2300      	movs	r3, #0  40:	60bb      	str	r3, [r7, #8]  42:	e051      	b.n	e8 <PackData+0xe8>        {            /*            off = DATA_FRAME_HEAD_SIZE                                          // Head Bits in a pack, eg. 0xB7, MCU No., etc.                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum     // The ADC0's data is in the front of ADC1's data.  44:	4b3e      	ldr	r3, [pc, #248]	; (140 <PackData+0x140>)  46:	781b      	ldrb	r3, [r3, #0]  48:	1c19      	adds	r1, r3, #0  4a:	68bb      	ldr	r3, [r7, #8]  4c:	1c5a      	adds	r2, r3, #1  4e:	1c13      	adds	r3, r2, #0  50:	005b      	lsls	r3, r3, #1  52:	189b      	adds	r3, r3, r2  54:	1c1a      	adds	r2, r3, #0    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)        {            /*            off = DATA_FRAME_HEAD_SIZE                                          // Head Bits in a pack, eg. 0xB7, MCU No., etc.  56:	68fb      	ldr	r3, [r7, #12]  58:	20cb      	movs	r0, #203	; 0xcb  5a:	00c0      	lsls	r0, r0, #3  5c:	4343      	muls	r3, r0                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum     // The ADC0's data is in the front of ADC1's data.  5e:	18d3      	adds	r3, r2, r3  60:	18ca      	adds	r2, r1, r3                        + 3 * (channelNum + 1)                                  // Every channel's data pack has a head of 3 bits.                            + CHANNEL_DATA_COUNT * 2 * channelNum               // every channel's data is 200 bits apart of the 3-bit head.  62:	4b38      	ldr	r3, [pc, #224]	; (144 <PackData+0x144>)  64:	681b      	ldr	r3, [r3, #0]  66:	005b      	lsls	r3, r3, #1  68:	1c19      	adds	r1, r3, #0        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)        {            /*            off = DATA_FRAME_HEAD_SIZE                                          // Head Bits in a pack, eg. 0xB7, MCU No., etc.                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum     // The ADC0's data is in the front of ADC1's data.                        + 3 * (channelNum + 1)                                  // Every channel's data pack has a head of 3 bits.  6a:	68bb      	ldr	r3, [r7, #8]  6c:	20c8      	movs	r0, #200	; 0xc8  6e:	4343      	muls	r3, r0                            + CHANNEL_DATA_COUNT * 2 * channelNum               // every channel's data is 200 bits apart of the 3-bit head.  70:	18cb      	adds	r3, r1, r3  72:	18d3      	adds	r3, r2, r3    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)        {            /*  74:	607b      	str	r3, [r7, #4]            off = DATA_FRAME_HEAD_SIZE                                          // Head Bits in a pack, eg. 0xB7, MCU No., etc.                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum     // The ADC0's data is in the front of ADC1's data.                        + 3 * (channelNum + 1)                                  // Every channel's data pack has a head of 3 bits.                            + CHANNEL_DATA_COUNT * 2 * channelNum               // every channel's data is 200 bits apart of the 3-bit head.                                + chDataCnt * 2;                                // every channel's data at one time is 2 bits.  76:	4b30      	ldr	r3, [pc, #192]	; (138 <PackData+0x138>)  78:	681a      	ldr	r2, [r3, #0]  7a:	4b33      	ldr	r3, [pc, #204]	; (148 <PackData+0x148>)  7c:	58d2      	ldr	r2, [r2, r3]  7e:	687b      	ldr	r3, [r7, #4]  80:	18d2      	adds	r2, r2, r3  82:	4b32      	ldr	r3, [pc, #200]	; (14c <PackData+0x14c>)  84:	6819      	ldr	r1, [r3, #0]  86:	4b2f      	ldr	r3, [pc, #188]	; (144 <PackData+0x144>)  88:	681b      	ldr	r3, [r3, #0]  8a:	68bc      	ldr	r4, [r7, #8]  8c:	68f8      	ldr	r0, [r7, #12]  8e:	2564      	movs	r5, #100	; 0x64  90:	436c      	muls	r4, r5  92:	25c8      	movs	r5, #200	; 0xc8  94:	00ad      	lsls	r5, r5, #2  96:	4368      	muls	r0, r5  98:	1820      	adds	r0, r4, r0  9a:	18c3      	adds	r3, r0, r3  9c:	005b      	lsls	r3, r3, #1  9e:	18cb      	adds	r3, r1, r3  a0:	3302      	adds	r3, #2  a2:	881b      	ldrh	r3, [r3, #0]  a4:	b21b      	sxth	r3, r3  a6:	121b      	asrs	r3, r3, #8  a8:	b29b      	uxth	r3, r3  aa:	b2db      	uxtb	r3, r3  ac:	7013      	strb	r3, [r2, #0]            */  ae:	4b22      	ldr	r3, [pc, #136]	; (138 <PackData+0x138>)  b0:	681a      	ldr	r2, [r3, #0]  b2:	4b25      	ldr	r3, [pc, #148]	; (148 <PackData+0x148>)  b4:	58d2      	ldr	r2, [r2, r3]  b6:	687b      	ldr	r3, [r7, #4]  b8:	3301      	adds	r3, #1  ba:	18d2      	adds	r2, r2, r3  bc:	4b23      	ldr	r3, [pc, #140]	; (14c <PackData+0x14c>)  be:	6819      	ldr	r1, [r3, #0]  c0:	4b20      	ldr	r3, [pc, #128]	; (144 <PackData+0x144>)  c2:	681b      	ldr	r3, [r3, #0]  c4:	68bc      	ldr	r4, [r7, #8]  c6:	68f8      	ldr	r0, [r7, #12]  c8:	2564      	movs	r5, #100	; 0x64  ca:	436c      	muls	r4, r5  cc:	25c8      	movs	r5, #200	; 0xc8  ce:	00ad      	lsls	r5, r5, #2  d0:	4368      	muls	r0, r5  d2:	1820      	adds	r0, r4, r0  d4:	18c3      	adds	r3, r0, r3  d6:	005b      	lsls	r3, r3, #1  d8:	18cb      	adds	r3, r1, r3  da:	3302      	adds	r3, #2  dc:	881b      	ldrh	r3, [r3, #0]  de:	b2db      	uxtb	r3, r3  e0:	7013      	strb	r3, [r2, #0]        return;    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)    {        for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)  e2:	68bb      	ldr	r3, [r7, #8]  e4:	3301      	adds	r3, #1  e6:	60bb      	str	r3, [r7, #8]  e8:	68bb      	ldr	r3, [r7, #8]  ea:	2b07      	cmp	r3, #7  ec:	d9aa      	bls.n	44 <PackData+0x44>        tARMPtr->armStatus.backBufferStatus = eOverflow;        overflowCnt++;        return;    }    for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)  ee:	68fb      	ldr	r3, [r7, #12]  f0:	3301      	adds	r3, #1  f2:	60fb      	str	r3, [r7, #12]  f4:	68fb      	ldr	r3, [r7, #12]  f6:	2b01      	cmp	r3, #1  f8:	d9a1      	bls.n	3e <PackData+0x3e>                                + chDataCnt * 2;                                // every channel's data at one time is 2 bits.            */            /*            off = 1624 * adcNum                    + 203 * channelNum                    + (chDataCnt << 1)  fa:	4b12      	ldr	r3, [pc, #72]	; (144 <PackData+0x144>)  fc:	681b      	ldr	r3, [r3, #0]  fe:	1c5a      	adds	r2, r3, #1 100:	4b10      	ldr	r3, [pc, #64]	; (144 <PackData+0x144>) 102:	601a      	str	r2, [r3, #0]                    + 11; 104:	4b0f      	ldr	r3, [pc, #60]	; (144 <PackData+0x144>) 106:	681b      	ldr	r3, [r3, #0] 108:	1c18      	adds	r0, r3, #0 10a:	2164      	movs	r1, #100	; 0x64 10c:	f7ff fffe 	bl	0 <__aeabi_uidivmod>			10c: R_ARM_THM_CALL	__aeabi_uidivmod 110:	1c0b      	adds	r3, r1, #0 112:	1c1a      	adds	r2, r3, #0 114:	4b0b      	ldr	r3, [pc, #44]	; (144 <PackData+0x144>) 116:	601a      	str	r2, [r3, #0]            */ 118:	4b0a      	ldr	r3, [pc, #40]	; (144 <PackData+0x144>) 11a:	681b      	ldr	r3, [r3, #0] 11c:	2b00      	cmp	r3, #0 11e:	d104      	bne.n	12a <PackData+0x12a>            off = (adcNum << 10) + (adcNum << 9) + (adcNum << 6) + (adcNum << 4) + (adcNum << 3)                    + (channelNum << 7) + (channelNum << 6) + (channelNum << 3) + (channelNum << 1) + channelNum                    + 11;            tARMPtr->backBuffer[off] = tMCUPtr->mcuData.channelData[adcNum][channelNum][chDataCnt] >> 8 & 0xFFU; 120:	4b05      	ldr	r3, [pc, #20]	; (138 <PackData+0x138>) 122:	681b      	ldr	r3, [r3, #0] 124:	2203      	movs	r2, #3 126:	70da      	strb	r2, [r3, #3] 128:	e003      	b.n	132 <PackData+0x132>        }    }    chDataCnt++;    chDataCnt %= CHANNEL_DATA_COUNT;    if(!chDataCnt) 12a:	4b03      	ldr	r3, [pc, #12]	; (138 <PackData+0x138>) 12c:	681b      	ldr	r3, [r3, #0] 12e:	2202      	movs	r2, #2 130:	70da      	strb	r2, [r3, #3]    {//        tARMPtr->armStatus.isBackBufferEmpty = FALSE; 132:	46bd      	mov	sp, r7 134:	b004      	add	sp, #16 136:	bdb0      	pop	{r4, r5, r7, pc}	...			138: R_ARM_ABS32	tARMPtr			13c: R_ARM_ABS32	.bss.overflowCnt			140: R_ARM_ABS32	DATA_FRAME_HEAD_SIZE			144: R_ARM_ABS32	.bss.chDataCnt 148:	0000197c 	.word	0x0000197c 14c:	00000000 	.word	0x00000000			14c: R_ARM_ABS32	tMCUPtrDisassembly of section .text.SwapARMDataBuffer:00000000 <SwapARMDataBuffer>:/* * =================================================================== *     Method      : SwapARMDataBuffer (Module Process) *//*! *     @brief   0:	b580      	push	{r7, lr}   2:	b086      	sub	sp, #24   4:	af00      	add	r7, sp, #0 *          This method is called to swap the arm's data. Decide either the   6:	4b83      	ldr	r3, [pc, #524]	; (214 <SwapARMDataBuffer+0x214>)   8:	681b      	ldr	r3, [r3, #0]   a:	789b      	ldrb	r3, [r3, #2]   c:	b2db      	uxtb	r3, r3   e:	b25b      	sxtb	r3, r3  10:	3301      	adds	r3, #1  12:	d146      	bne.n	a2 <SwapARMDataBuffer+0xa2>  14:	4b7f      	ldr	r3, [pc, #508]	; (214 <SwapARMDataBuffer+0x214>)  16:	681b      	ldr	r3, [r3, #0]  18:	78db      	ldrb	r3, [r3, #3]  1a:	b2db      	uxtb	r3, r3  1c:	b25b      	sxtb	r3, r3  1e:	3301      	adds	r3, #1  20:	d13f      	bne.n	a2 <SwapARMDataBuffer+0xa2> *          armLeftData or armRightData is the foreground buffer or background *          buffer.  22:	4b7c      	ldr	r3, [pc, #496]	; (214 <SwapARMDataBuffer+0x214>)  24:	681a      	ldr	r2, [r3, #0]  26:	4b7b      	ldr	r3, [pc, #492]	; (214 <SwapARMDataBuffer+0x214>)  28:	681b      	ldr	r3, [r3, #0]  2a:	487b      	ldr	r0, [pc, #492]	; (218 <SwapARMDataBuffer+0x218>)  2c:	1819      	adds	r1, r3, r0  2e:	4b7b      	ldr	r3, [pc, #492]	; (21c <SwapARMDataBuffer+0x21c>)  30:	50d1      	str	r1, [r2, r3] *     @param  32:	4b78      	ldr	r3, [pc, #480]	; (214 <SwapARMDataBuffer+0x214>)  34:	681a      	ldr	r2, [r3, #0]  36:	4b77      	ldr	r3, [pc, #476]	; (214 <SwapARMDataBuffer+0x214>)  38:	681b      	ldr	r3, [r3, #0]  3a:	1d19      	adds	r1, r3, #4  3c:	4b78      	ldr	r3, [pc, #480]	; (220 <SwapARMDataBuffer+0x220>)  3e:	50d1      	str	r1, [r2, r3] *          void *     @return *          void *//* ===================================================================*/  40:	4b74      	ldr	r3, [pc, #464]	; (214 <SwapARMDataBuffer+0x214>)  42:	681b      	ldr	r3, [r3, #0]  44:	2200      	movs	r2, #0  46:	709a      	strb	r2, [r3, #2]void SwapARMDataBuffer(void)  48:	4b72      	ldr	r3, [pc, #456]	; (214 <SwapARMDataBuffer+0x214>)  4a:	681b      	ldr	r3, [r3, #0]  4c:	2200      	movs	r2, #0  4e:	70da      	strb	r2, [r3, #3]{  50:	4b70      	ldr	r3, [pc, #448]	; (214 <SwapARMDataBuffer+0x214>)  52:	681b      	ldr	r3, [r3, #0]  54:	781a      	ldrb	r2, [r3, #0]  56:	2102      	movs	r1, #2  58:	438a      	bics	r2, r1  5a:	701a      	strb	r2, [r3, #0]    if(eNull == tARMPtr->armStatus.foreBufferStatus && eNull == tARMPtr->armStatus.backBufferStatus)    {  5c:	4b6d      	ldr	r3, [pc, #436]	; (214 <SwapARMDataBuffer+0x214>)  5e:	681a      	ldr	r2, [r3, #0]  60:	4b6e      	ldr	r3, [pc, #440]	; (21c <SwapARMDataBuffer+0x21c>)  62:	58d3      	ldr	r3, [r2, r3]  64:	1d9a      	adds	r2, r3, #6  66:	4b6b      	ldr	r3, [pc, #428]	; (214 <SwapARMDataBuffer+0x214>)  68:	6819      	ldr	r1, [r3, #0]  6a:	4b6c      	ldr	r3, [pc, #432]	; (21c <SwapARMDataBuffer+0x21c>)  6c:	58cb      	ldr	r3, [r1, r3]  6e:	3306      	adds	r3, #6  70:	7819      	ldrb	r1, [r3, #0]  72:	2301      	movs	r3, #1  74:	400b      	ands	r3, r1  76:	b2d9      	uxtb	r1, r3        tARMPtr->foreBuffer = tARMPtr->armDataRight.dataFrame;  78:	4b66      	ldr	r3, [pc, #408]	; (214 <SwapARMDataBuffer+0x214>)  7a:	681b      	ldr	r3, [r3, #0]  7c:	789b      	ldrb	r3, [r3, #2]  7e:	b2db      	uxtb	r3, r3 *//* ===================================================================*/void SwapARMDataBuffer(void){    if(eNull == tARMPtr->armStatus.foreBufferStatus && eNull == tARMPtr->armStatus.backBufferStatus)    {  80:	b2db      	uxtb	r3, r3  82:	005b      	lsls	r3, r3, #1  84:	b2d8      	uxtb	r0, r3  86:	230e      	movs	r3, #14  88:	4003      	ands	r3, r0  8a:	b2db      	uxtb	r3, r3  8c:	430b      	orrs	r3, r1  8e:	b2db      	uxtb	r3, r3  90:	7013      	strb	r3, [r2, #0]        tARMPtr->foreBuffer = tARMPtr->armDataRight.dataFrame;        tARMPtr->backBuffer = tARMPtr->armDataLeft.dataFrame;//        tARMPtr->armStatus.isForeBufferEmpty = FALSE;  92:	4b60      	ldr	r3, [pc, #384]	; (214 <SwapARMDataBuffer+0x214>)  94:	681a      	ldr	r2, [r3, #0]  96:	4b61      	ldr	r3, [pc, #388]	; (21c <SwapARMDataBuffer+0x21c>)  98:	58d3      	ldr	r3, [r2, r3]  9a:	3307      	adds	r3, #7  9c:	2200      	movs	r2, #0  9e:	701a      	strb	r2, [r3, #0]  a0:	e0af      	b.n	202 <SwapARMDataBuffer+0x202>//        tARMPtr->armStatus.isBackBufferEmpty = TRUE;//        tARMPtr->armStatus.isForeBufferFull = FALSE;        tARMPtr->armStatus.foreBufferStatus = eEmpty;        tARMPtr->armStatus.backBufferStatus = eEmpty;        tARMPtr->armStatus.isUploadReady = FALSE;  a2:	4b5c      	ldr	r3, [pc, #368]	; (214 <SwapARMDataBuffer+0x214>)  a4:	681a      	ldr	r2, [r3, #0]  a6:	4b5d      	ldr	r3, [pc, #372]	; (21c <SwapARMDataBuffer+0x21c>)  a8:	58d3      	ldr	r3, [r2, r3]  aa:	60fb      	str	r3, [r7, #12]        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)  ac:	4b59      	ldr	r3, [pc, #356]	; (214 <SwapARMDataBuffer+0x214>)  ae:	681a      	ldr	r2, [r3, #0]  b0:	4b58      	ldr	r3, [pc, #352]	; (214 <SwapARMDataBuffer+0x214>)  b2:	6819      	ldr	r1, [r3, #0]  b4:	4b5a      	ldr	r3, [pc, #360]	; (220 <SwapARMDataBuffer+0x220>)  b6:	58c9      	ldr	r1, [r1, r3]  b8:	4b58      	ldr	r3, [pc, #352]	; (21c <SwapARMDataBuffer+0x21c>)  ba:	50d1      	str	r1, [r2, r3]                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);  bc:	4b55      	ldr	r3, [pc, #340]	; (214 <SwapARMDataBuffer+0x214>)  be:	681a      	ldr	r2, [r3, #0]  c0:	4b57      	ldr	r3, [pc, #348]	; (220 <SwapARMDataBuffer+0x220>)  c2:	68f9      	ldr	r1, [r7, #12]  c4:	50d1      	str	r1, [r2, r3]  c6:	4b53      	ldr	r3, [pc, #332]	; (214 <SwapARMDataBuffer+0x214>)  c8:	681a      	ldr	r2, [r3, #0]  ca:	4b52      	ldr	r3, [pc, #328]	; (214 <SwapARMDataBuffer+0x214>)  cc:	681b      	ldr	r3, [r3, #0]  ce:	78db      	ldrb	r3, [r3, #3]  d0:	b2db      	uxtb	r3, r3  d2:	7093      	strb	r3, [r2, #2]        tARMPtr->foreBuffer[7] = 0x0U;  d4:	4b4f      	ldr	r3, [pc, #316]	; (214 <SwapARMDataBuffer+0x214>)  d6:	681b      	ldr	r3, [r3, #0]  d8:	2200      	movs	r2, #0  da:	70da      	strb	r2, [r3, #3]    }  dc:	4b4d      	ldr	r3, [pc, #308]	; (214 <SwapARMDataBuffer+0x214>)  de:	681b      	ldr	r3, [r3, #0]  e0:	781a      	ldrb	r2, [r3, #0]  e2:	2102      	movs	r1, #2  e4:	438a      	bics	r2, r1  e6:	701a      	strb	r2, [r3, #0]    else    {  e8:	4b4a      	ldr	r3, [pc, #296]	; (214 <SwapARMDataBuffer+0x214>)  ea:	681a      	ldr	r2, [r3, #0]  ec:	4b4b      	ldr	r3, [pc, #300]	; (21c <SwapARMDataBuffer+0x21c>)  ee:	58d3      	ldr	r3, [r2, r3]  f0:	1d9a      	adds	r2, r3, #6  f2:	4b48      	ldr	r3, [pc, #288]	; (214 <SwapARMDataBuffer+0x214>)  f4:	6819      	ldr	r1, [r3, #0]  f6:	4b49      	ldr	r3, [pc, #292]	; (21c <SwapARMDataBuffer+0x21c>)  f8:	58cb      	ldr	r3, [r1, r3]  fa:	3306      	adds	r3, #6  fc:	7819      	ldrb	r1, [r3, #0]  fe:	2301      	movs	r3, #1 100:	400b      	ands	r3, r1 102:	b2d9      	uxtb	r1, r3        //tARMPtr->backBuffer[7] = tARMPtr->armStatus.backBufferStatus; 104:	4b43      	ldr	r3, [pc, #268]	; (214 <SwapARMDataBuffer+0x214>) 106:	681b      	ldr	r3, [r3, #0] 108:	789b      	ldrb	r3, [r3, #2] 10a:	b2db      	uxtb	r3, r3                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        tARMPtr->foreBuffer[7] = 0x0U;    }    else    { 10c:	b2db      	uxtb	r3, r3 10e:	005b      	lsls	r3, r3, #1 110:	b2d8      	uxtb	r0, r3 112:	230e      	movs	r3, #14 114:	4003      	ands	r3, r0 116:	b2db      	uxtb	r3, r3 118:	430b      	orrs	r3, r1 11a:	b2db      	uxtb	r3, r3 11c:	7013      	strb	r3, [r2, #0]        //tARMPtr->backBuffer[7] = tARMPtr->armStatus.backBufferStatus; 11e:	4b3d      	ldr	r3, [pc, #244]	; (214 <SwapARMDataBuffer+0x214>) 120:	681b      	ldr	r3, [r3, #0] 122:	789b      	ldrb	r3, [r3, #2] 124:	b2db      	uxtb	r3, r3 126:	b25b      	sxtb	r3, r3 128:	3301      	adds	r3, #1 12a:	2b05      	cmp	r3, #5 12c:	d869      	bhi.n	202 <SwapARMDataBuffer+0x202> 12e:	009a      	lsls	r2, r3, #2 130:	4b3c      	ldr	r3, [pc, #240]	; (224 <SwapARMDataBuffer+0x224>) 132:	18d3      	adds	r3, r2, r3 134:	681b      	ldr	r3, [r3, #0] 136:	469f      	mov	pc, r3        byte* temp;        temp = tARMPtr->foreBuffer;        tARMPtr->foreBuffer = tARMPtr->backBuffer; 138:	4b36      	ldr	r3, [pc, #216]	; (214 <SwapARMDataBuffer+0x214>) 13a:	681a      	ldr	r2, [r3, #0] 13c:	4b37      	ldr	r3, [pc, #220]	; (21c <SwapARMDataBuffer+0x21c>) 13e:	58d3      	ldr	r3, [r2, r3] 140:	3307      	adds	r3, #7 142:	4a39      	ldr	r2, [pc, #228]	; (228 <SwapARMDataBuffer+0x228>) 144:	7812      	ldrb	r2, [r2, #0] 146:	701a      	strb	r2, [r3, #0]        tARMPtr->backBuffer = temp; 148:	e05b      	b.n	202 <SwapARMDataBuffer+0x202>        tARMPtr->armStatus.foreBufferStatus = tARMPtr->armStatus.backBufferStatus;        tARMPtr->armStatus.backBufferStatus = eEmpty; 14a:	4b32      	ldr	r3, [pc, #200]	; (214 <SwapARMDataBuffer+0x214>) 14c:	681a      	ldr	r2, [r3, #0] 14e:	4b33      	ldr	r3, [pc, #204]	; (21c <SwapARMDataBuffer+0x21c>) 150:	58d3      	ldr	r3, [r2, r3] 152:	3307      	adds	r3, #7 154:	2200      	movs	r2, #0 156:	701a      	strb	r2, [r3, #0]        tARMPtr->armStatus.isUploadReady = FALSE; 158:	e053      	b.n	202 <SwapARMDataBuffer+0x202>        tARMPtr->foreBuffer[6] = (tARMPtr->foreBuffer[6] & 0x01U)                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        switch(tARMPtr->armStatus.foreBufferStatus) 15a:	4b34      	ldr	r3, [pc, #208]	; (22c <SwapARMDataBuffer+0x22c>) 15c:	681b      	ldr	r3, [r3, #0] 15e:	2264      	movs	r2, #100	; 0x64 160:	1ad3      	subs	r3, r2, r3 162:	60bb      	str	r3, [r7, #8]        { 164:	4b2b      	ldr	r3, [pc, #172]	; (214 <SwapARMDataBuffer+0x214>) 166:	681a      	ldr	r2, [r3, #0] 168:	4b2c      	ldr	r3, [pc, #176]	; (21c <SwapARMDataBuffer+0x21c>) 16a:	58d3      	ldr	r3, [r2, r3] 16c:	3307      	adds	r3, #7 16e:	68ba      	ldr	r2, [r7, #8] 170:	b2d2      	uxtb	r2, r2 172:	701a      	strb	r2, [r3, #0]        case eOverflow:            tARMPtr->foreBuffer[7] = overflowCnt;            break; 174:	2300      	movs	r3, #0 176:	617b      	str	r3, [r7, #20] 178:	e036      	b.n	1e8 <SwapARMDataBuffer+0x1e8>        case eFull:            tARMPtr->foreBuffer[7] = 0x00U; 17a:	2300      	movs	r3, #0 17c:	613b      	str	r3, [r7, #16] 17e:	e02c      	b.n	1da <SwapARMDataBuffer+0x1da>            break;        case eWrite: 180:	697b      	ldr	r3, [r7, #20] 182:	22cb      	movs	r2, #203	; 0xcb 184:	4353      	muls	r3, r2 186:	1c1a      	adds	r2, r3, #0 188:	32d2      	adds	r2, #210	; 0xd2 18a:	6939      	ldr	r1, [r7, #16] 18c:	68bb      	ldr	r3, [r7, #8] 18e:	1acb      	subs	r3, r1, r3 190:	005b      	lsls	r3, r3, #1 192:	18d3      	adds	r3, r2, r3 194:	607b      	str	r3, [r7, #4]        { 196:	4b1f      	ldr	r3, [pc, #124]	; (214 <SwapARMDataBuffer+0x214>) 198:	681a      	ldr	r2, [r3, #0] 19a:	4b21      	ldr	r3, [pc, #132]	; (220 <SwapARMDataBuffer+0x220>) 19c:	58d2      	ldr	r2, [r2, r3] 19e:	687b      	ldr	r3, [r7, #4] 1a0:	18d2      	adds	r2, r2, r3 1a2:	4b1c      	ldr	r3, [pc, #112]	; (214 <SwapARMDataBuffer+0x214>) 1a4:	6819      	ldr	r1, [r3, #0] 1a6:	4b1e      	ldr	r3, [pc, #120]	; (220 <SwapARMDataBuffer+0x220>) 1a8:	58c9      	ldr	r1, [r1, r3] 1aa:	687b      	ldr	r3, [r7, #4] 1ac:	3b02      	subs	r3, #2 1ae:	18cb      	adds	r3, r1, r3 1b0:	781b      	ldrb	r3, [r3, #0] 1b2:	7013      	strb	r3, [r2, #0]            int remainNum; 1b4:	4b17      	ldr	r3, [pc, #92]	; (214 <SwapARMDataBuffer+0x214>) 1b6:	681a      	ldr	r2, [r3, #0] 1b8:	4b19      	ldr	r3, [pc, #100]	; (220 <SwapARMDataBuffer+0x220>) 1ba:	58d2      	ldr	r2, [r2, r3] 1bc:	687b      	ldr	r3, [r7, #4] 1be:	3301      	adds	r3, #1 1c0:	18d2      	adds	r2, r2, r3 1c2:	4b14      	ldr	r3, [pc, #80]	; (214 <SwapARMDataBuffer+0x214>) 1c4:	6819      	ldr	r1, [r3, #0] 1c6:	4b16      	ldr	r3, [pc, #88]	; (220 <SwapARMDataBuffer+0x220>) 1c8:	58c9      	ldr	r1, [r1, r3] 1ca:	687b      	ldr	r3, [r7, #4] 1cc:	3b01      	subs	r3, #1 1ce:	18cb      	adds	r3, r1, r3 1d0:	781b      	ldrb	r3, [r3, #0] 1d2:	7013      	strb	r3, [r2, #0]        {        case eOverflow:            tARMPtr->foreBuffer[7] = overflowCnt;            break;        case eFull:            tARMPtr->foreBuffer[7] = 0x00U; 1d4:	693b      	ldr	r3, [r7, #16] 1d6:	3301      	adds	r3, #1 1d8:	613b      	str	r3, [r7, #16] 1da:	693a      	ldr	r2, [r7, #16] 1dc:	68bb      	ldr	r3, [r7, #8] 1de:	429a      	cmp	r2, r3 1e0:	dbce      	blt.n	180 <SwapARMDataBuffer+0x180>                               | ((tARMPtr->armStatus.foreBufferStatus << 1) & 0x0EU);        switch(tARMPtr->armStatus.foreBufferStatus)        {        case eOverflow:            tARMPtr->foreBuffer[7] = overflowCnt;            break; 1e2:	697b      	ldr	r3, [r7, #20] 1e4:	3301      	adds	r3, #1 1e6:	617b      	str	r3, [r7, #20] 1e8:	697b      	ldr	r3, [r7, #20] 1ea:	2b0f      	cmp	r3, #15 1ec:	d9c5      	bls.n	17a <SwapARMDataBuffer+0x17a>//            for(int i = 0; i < CHANNEL_DATA_COUNT; i++)//            {//                for(int adcNum = 0; adcNum < USING_ADC_COUNT; adcNum++)//                {//                    for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)//                    { 1ee:	e008      	b.n	202 <SwapARMDataBuffer+0x202>//                        for(int j = 0; j < remainNum; j++)//                        {//                            off = DATA_FRAME_HEAD_SIZE /* Head Bits in a pack, eg. 0xB7, MCU No., etc. *///                                    + USING_CHANNEL_COUNT * CHANNEL_PACKAGE_LENGTH * adcNum  /* The ADC0's data is in the front of ADC1's data. *///                                        + 3 * (channelNum + 1)  /* Every channel's data pack has a head of 3 bits. *///                                            + CHANNEL_DATA_COUNT * 2 * channelNum   /* every channel's data is 200 bits apart of the 3-bit head. */ 1f0:	4b08      	ldr	r3, [pc, #32]	; (214 <SwapARMDataBuffer+0x214>) 1f2:	681a      	ldr	r2, [r3, #0] 1f4:	4b09      	ldr	r3, [pc, #36]	; (21c <SwapARMDataBuffer+0x21c>) 1f6:	58d3      	ldr	r3, [r2, r3] 1f8:	3307      	adds	r3, #7 1fa:	2264      	movs	r2, #100	; 0x64 1fc:	701a      	strb	r2, [r3, #0]//                                                + (chDataCnt + j) * 2;   /* every channel's data at one time is 2 bits. */ 1fe:	e000      	b.n	202 <SwapARMDataBuffer+0x202>//                {//                    for(int channelNum = 0;  channelNum < USING_CHANNEL_COUNT; channelNum++)//                    {//                        for(int j = 0; j < remainNum; j++)//                        {//                            off = DATA_FRAME_HEAD_SIZE /* Head Bits in a pack, eg. 0xB7, MCU No., etc. */ 200:	46c0      	nop			; (mov r8, r8)//                                            + CHANNEL_DATA_COUNT * 2 * channelNum   /* every channel's data is 200 bits apart of the 3-bit head. *///                                                + (chDataCnt + j) * 2;   /* every channel's data at one time is 2 bits. *///                            tARMPtr->backBuffer[off] = tARMPtr->backBuffer[off - 2];//                            tARMPtr->backBuffer[off + 1] = tARMPtr->backBuffer[off - 1];//                        }//                    } 202:	4b0a      	ldr	r3, [pc, #40]	; (22c <SwapARMDataBuffer+0x22c>) 204:	2200      	movs	r2, #0 206:	601a      	str	r2, [r3, #0]//                } 208:	4b07      	ldr	r3, [pc, #28]	; (228 <SwapARMDataBuffer+0x228>) 20a:	2200      	movs	r2, #0 20c:	701a      	strb	r2, [r3, #0]//            } 20e:	46bd      	mov	sp, r7 210:	b006      	add	sp, #24 212:	bd80      	pop	{r7, pc} 214:	00000000 	.word	0x00000000			214: R_ARM_ABS32	tARMPtr 218:	00000cbd 	.word	0x00000cbd 21c:	00001978 	.word	0x00001978 220:	0000197c 	.word	0x0000197c	...			224: R_ARM_ABS32	.rodata.SwapARMDataBuffer			228: R_ARM_ABS32	.bss.overflowCnt			22c: R_ARM_ABS32	.bss.chDataCnt